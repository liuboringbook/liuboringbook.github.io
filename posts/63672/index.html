<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>高频考点 | 无聊才读书-博客</title><meta name="description" content="高频考点1. typeof类型判断 typeof 是否能正确判断类型？ instanceof能正确判断对象的原理是什么   type 对于原始类型，除了 null都可以只显示正确的类型  12345typeof 1 &#x2F;&#x2F;&#39;number&#39;typeof &#39;1&#39; &#x2F;&#x2F;&#39;string&#39;typeof undefined &#x2F;&#x2F;&#39;undefined&#39;typeof true &#x2F;&#x2F;&#39;boolean&#39;typeof S"><meta name="keywords" content="hello，总结"><meta name="author" content="刘如刚"><meta name="copyright" content="刘如刚"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.liurugang.cn/posts/63672/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="高频考点"><meta property="og:url" content="http://blog.liurugang.cn/posts/63672/"><meta property="og:site_name" content="无聊才读书-博客"><meta property="og:description" content="高频考点1. typeof类型判断 typeof 是否能正确判断类型？ instanceof能正确判断对象的原理是什么   type 对于原始类型，除了 null都可以只显示正确的类型  12345typeof 1 &#x2F;&#x2F;&#39;number&#39;typeof &#39;1&#39; &#x2F;&#x2F;&#39;string&#39;typeof undefined &#x2F;&#x2F;&#39;undefined&#39;typeof true &#x2F;&#x2F;&#39;boolean&#39;typeof S"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2021-06-02T15:30:53.636Z"><meta property="article:modified_time" content="2021-06-08T07:11:48.471Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="uni-app入坑" href="http://blog.liurugang.cn/posts/61960/"><link rel="next" title="前端面试题-续" href="http://blog.liurugang.cn/posts/25536/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-06-08 15:11:48'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/Chocolate1999/cdn/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/home/"><i class="fa-fw fab fa-phoenix-framework"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#高频考点"><span class="toc-number">1.</span> <span class="toc-text">高频考点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-typeof类型判断"><span class="toc-number">1.1.</span> <span class="toc-text">1. typeof类型判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-类型转换"><span class="toc-number">1.2.</span> <span class="toc-text">2.类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-This"><span class="toc-number">1.3.</span> <span class="toc-text">3. This</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-和-有什么区别"><span class="toc-number">1.4.</span> <span class="toc-text">4. &#x3D;&#x3D; 和&#x3D;&#x3D;&#x3D;有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-闭包"><span class="toc-number">1.5.</span> <span class="toc-text">5. 闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-深浅拷贝"><span class="toc-number">1.6.</span> <span class="toc-text">6. 深浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-原型"><span class="toc-number">1.7.</span> <span class="toc-text">7. 原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-var-let-及const区别"><span class="toc-number">1.8.</span> <span class="toc-text">8. var let 及const区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-原型继承和class继承"><span class="toc-number">1.9.</span> <span class="toc-text">9. 原型继承和class继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-实现一个简洁版的promise"><span class="toc-number">1.10.</span> <span class="toc-text">10. 实现一个简洁版的promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Event-Loop"><span class="toc-number">1.11.</span> <span class="toc-text">11. Event Loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-手写-call-apply-及bind函数"><span class="toc-number">1.12.</span> <span class="toc-text">12. 手写 call apply 及bind函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-new"><span class="toc-number">1.13.</span> <span class="toc-text">13. new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-instanceof-的原理"><span class="toc-number">1.14.</span> <span class="toc-text">14. instanceof 的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-事件机制"><span class="toc-number">1.15.</span> <span class="toc-text">15. 事件机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-注册事件"><span class="toc-number">1.16.</span> <span class="toc-text">16. 注册事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-跨域"><span class="toc-number">1.17.</span> <span class="toc-text">17. 跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-存储"><span class="toc-number">1.18.</span> <span class="toc-text">18. 存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-浏览器缓存机制"><span class="toc-number">1.19.</span> <span class="toc-text">19. 浏览器缓存机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-浏览器渲染原理"><span class="toc-number">1.20.</span> <span class="toc-text">20. 浏览器渲染原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-安全防范"><span class="toc-number">1.21.</span> <span class="toc-text">21. 安全防范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-性能优化"><span class="toc-number">1.22.</span> <span class="toc-text">22. 性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-MVVM-虚拟DOM-前端路由"><span class="toc-number">1.23.</span> <span class="toc-text">23. MVVM&#x2F;虚拟DOM&#x2F;前端路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Vue常考知识点"><span class="toc-number">1.24.</span> <span class="toc-text">24. Vue常考知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-TCP-UDP"><span class="toc-number">1.25.</span> <span class="toc-text">25. TCP&#x2F;UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-设计模式"><span class="toc-number">1.26.</span> <span class="toc-text">26. 设计模式</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">无聊才读书-博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/home/"><i class="fa-fw fab fa-phoenix-framework"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">高频考点</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-06-02 23:30:53"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-06-02</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-06-08 15:11:48"><i class="fas fa-history fa-fw"></i> 更新于 2021-06-08</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="高频考点"><a href="#高频考点" class="headerlink" title="高频考点"></a>高频考点</h1><h2 id="1-typeof类型判断"><a href="#1-typeof类型判断" class="headerlink" title="1. typeof类型判断"></a>1. typeof类型判断</h2><blockquote>
<p>typeof 是否能正确判断类型？ instanceof能正确判断对象的原理是什么</p>
</blockquote>
<ul>
<li>type 对于原始类型，除了 <code>null</code>都可以只显示正确的类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">//'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span> <span class="comment">//'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">//'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">//'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">//'symbol'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>typeof 对于对象来说，除了函数都会显示<code>object</code>,所以说<code>typeof</code>并不能准确判断变量到底是什么类型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">//'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">//'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">//'function'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们想判断一个对象的正确类型，这时候可以考虑使用<code>instanceof</code>,因为内部机制是通过原型链来判断的</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1 <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello world'</span></span><br><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1= <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello world'</span>)</span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于原始类型来说，逆向直接通过<code>instanceof</code> 来判断类型是不行的</p>
</blockquote>
<h2 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2.类型转换"></a>2.类型转换</h2><blockquote>
<p>在JS中类型转换只有三种情况，分别是</p>
<ul>
<li>转换为布尔值</li>
<li>转换为数字</li>
<li>转换为字符串</li>
</ul>
</blockquote>
<p>转为Boolean</p>
<blockquote>
<p>在条件判断时，除了 undefined , null ,false ,NaN,’ ‘,0,-0,其他所有值都转为true，包括所有对象</p>
</blockquote>
<p>对象转为原始类型</p>
<blockquote>
<p>对象在转换类型的时候，会调用内置的<code>[[ToPrimitive]]</code>函数，对于该函数来说，算法逻辑一般来说如下</p>
</blockquote>
<ul>
<li>如果已经是原型类型了，那就不需要转换了</li>
<li>调用<code>x.valueOf()</code>如果转换为基础类型，就返回转换的值</li>
<li>调用<code>x.toString()</code>，如果转换为基础类型，就返回转换的值</li>
<li>如果没有返回原型类型，就会报错</li>
</ul>
<blockquote>
<p>当然你也可以重写Symbol.toPrimitive，刚方法在转原始类型时调用优先级最高</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    valueOf()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>+ a <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>四则运算</p>
<blockquote>
<p>它有以下几个特点：</p>
<ul>
<li>运算中其中一方为字符串，那么久会把另一方也转换为字符串</li>
<li>如果一方不是字符串或数字，那么会将它转换为数字或者字符串</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+ <span class="string">'1'</span>  <span class="comment">//'11'</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span> <span class="comment">//2</span></span><br><span class="line"><span class="number">4</span>+ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//"41,2,3"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于第一行代码来说，触发特点一，所以将数字1转换为字符串，得到结果’11‘</li>
<li>对于第二行代码来说，触发特点二，所以将true转为数字1</li>
<li>对于第三行代码来说，触发特点二，所以将数组通过toString转为字符串1,2,3，得到结果41，2,3</li>
</ul>
<p>比较运算符</p>
<ul>
<li>如果是对象，就通过<code>toPrimitive</code>转换为对象</li>
<li>如果是字符串，就通过<code>unicode</code>字符索引来比较</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =&#123;</span><br><span class="line">    valueOf()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a&gt;<span class="number">-1</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在以上代码中，因为a是对象，所以会通过<code>valueOf</code>转换为原始类型再比较值</p>
</blockquote>
<h2 id="3-This"><a href="#3-This" class="headerlink" title="3. This"></a>3. This</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a =<span class="number">1</span></span><br><span class="line">foo()</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Foo()</span><br></pre></td></tr></table></figure>

<ul>
<li>对于直接调用foo 来说，不管foo函数放在什么地方，this一定是window</li>
<li>对于<code>obj.foo()</code>来说，我们只需要记住，谁调用了函数，谁就是<code>this</code>,所以在这个场景下<code>foo</code>函数中的<code>this</code>就是<code>obj</code>对象</li>
<li>对于<code>new</code>的方式来说，<code>this</code>被永远绑定在了<code>c</code>上面 不会被任何方式改变<code>this</code></li>
</ul>
<blockquote>
<p>说完了以上几种情况，其实很多代码中的<code>this</code>应该就没什么问题了，下面让我们看看箭头函数中的<code>this</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)<span class="comment">//window</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()())<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>首先箭头函数其实是没有<code>this</code>的，箭头函数中的<code>this</code>只取决包裹箭头函数的第一个普通函数的<code>this</code>。在这个例子中，因为包裹箭头函数的第一个普通函数是<code>a</code>,所以此时的<code>this</code>是<code>window</code>。另外对箭头函数使用<code>bind</code>这类函数是无效的</li>
<li>最后种情况也就是<code>bind</code>这些改变上下文的<code>API</code>了，对于这些函数来说，<code>this</code>取决于第一个参数，如果第一个参数为空，那么就是<code>window</code></li>
<li>无论我们给函数<code>bind</code>几次，<code>fn</code>中的<code>this</code>永远由第一次<code>bind</code>决定，所以结果永远是<code>window</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;</span><br><span class="line">fn.bind.bind(a)() <span class="comment">//window</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上就是<code>this</code>的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高来决定<code>this</code>最终指向哪里</p>
<p>首先，<code>new</code>的方式优先级最高，接下来是<code>bind</code>这些函数，然后是<code>obj.foo()</code>这种调用方式，最后是<code>foo</code>这种调用方式，同时，箭头函数的<code>this</code>一旦被绑定，就不会再被任何方式所改变</p>
</blockquote>
<h2 id="4-和-有什么区别"><a href="#4-和-有什么区别" class="headerlink" title="4. == 和===有什么区别"></a>4. == 和===有什么区别</h2><blockquote>
<p>对于<code>==</code>来说，如果对比双方的类型不一样的话，就会进行类型转换</p>
</blockquote>
<p>假如我们需要对比x和y是否相同，就会进行如下判断流程</p>
<ol>
<li><p>首先会判断两者类型是否相同，相同的话就是比大小了</p>
</li>
<li><p>类型不相同的话，那么就会进行类型转换</p>
</li>
<li><p>会先判断是否在对比<code>null</code>和<code>undefined</code>,是的话就会返回<code>true</code></p>
</li>
<li><p>判断两者类型是否为<code>string</code>和<code>number</code>，是的话就会将字符串转换为<code>number</code></p>
</li>
<li><p>判断其中一方是否为<code>boolean</code>.是的话就把<code>boolean</code>转为<code>number</code>再进行判断</p>
</li>
<li><p>判断其中一方是否为<code>Object</code>且另一方为<code>string</code>,<code>number</code>或者<code>symbol</code>，是的话就会把<code>object</code>转为原始类型再进行判断</p>
</li>
</ol>
<blockquote>
<p>对于<code>===</code>来说就简单多了，就是判断两者类型和值是否相同</p>
</blockquote>
<h2 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5. 闭包"></a>5. 闭包</h2><blockquote>
<p>闭包的定义其实很简单：函数A内部有一个函数B，函数B可以访问到函数A中的变量，那么函数B就是闭包</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a =<span class="number">1</span></span><br><span class="line">    <span class="built_in">window</span>.B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B() <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>闭包存在的意义就是让我们可以间接访问函数内部的变量</p>
<blockquote>
<p>经典面试题，循环中说那个闭包解决<code>var</code>定义函数的问题</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先因为<code>setTimeout</code>是个异步函数，所以会先把循环占全部执行完毕，这时候i就是6了，所以会输出一堆6</p>
</blockquote>
<p>解决办法有三种</p>
<ol>
<li><p>第一种是使用闭包的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    ;(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j)</span><br><span class="line">        &#125;,j*<span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上述代码汇总，我们首先使用了立即执行函数将<code>i</code>传入函数内部，这时候值就被固定在了参数j上面不会改变，当下次执行<code>timer</code>这个闭包的时候，就可以使用外部函数的变量j,从而达到目的</p>
</blockquote>
</li>
<li><p>第二种就是使用<code>setTimeout</code>的第三个参数，这个参数会被当做<code>timer</code>函数的参数传入</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>第三种就是使用<code>let</code>定义<code>i</code>了来解决问题，这个也是最为推荐的方式</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-深浅拷贝"><a href="#6-深浅拷贝" class="headerlink" title="6. 深浅拷贝"></a>6. 深浅拷贝</h2><p>浅拷贝</p>
<blockquote>
<p>首先可以通过<code>Object.assign</code>来解决这个问题，很多人认为这个函数是用来深拷贝的，其实并不是，<code>Object.assign</code>只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =&#123;</span><br><span class="line">    age:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;,a)</span><br><span class="line">a.age = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外我们还可以通过展开运算符<code>...</code>来实现浅拷贝</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =&#123;</span><br><span class="line">    age:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b =&#123;...a&#125;</span><br><span class="line">a.age =<span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用深拷贝</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =&#123;</span><br><span class="line">    age:<span class="number">1</span>,</span><br><span class="line">    jobs:&#123;</span><br><span class="line">        first: <span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b =&#123;...a&#125;</span><br><span class="line">a.jobs.first =<span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">//native</span></span><br></pre></td></tr></table></figure>

<p>深拷贝</p>
<blockquote>
<p>这个问题通常可以使用<code>JSON.parse(JSON.stringify(object))</code>来解决</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span>,</span><br><span class="line">    jobs:&#123;</span><br><span class="line">        first:<span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">a.jobs.first =<span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">//FE</span></span><br></pre></td></tr></table></figure>

<p>但是这个犯法也是有局限性的</p>
<ul>
<li>会忽略<code>undefined</code></li>
<li>会忽略<code>symbol</code></li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>
<h2 id="7-原型"><a href="#7-原型" class="headerlink" title="7. 原型"></a>7. 原型</h2><blockquote>
<p>原型链就是多个对象通过<code>__proto__</code>的方式连接了起来。为什么<code>obj</code>可以访问到<code>valueof</code>函数，就是因为<code>obj</code>通过原型链找到了<code>valueof</code>函数</p>
</blockquote>
<ul>
<li><p><code>Object</code>是所有对象的爸爸，所有对象都可以通过<code>__proto__</code>找到它</p>
</li>
<li><p><code>Function</code>是所有函数的爸爸，所有函数都可以通过<code>__proto__</code>找到它</p>
</li>
<li><p>函数的<code>prototype</code>是一个对象</p>
</li>
<li><p>对象的<code>__proto__</code>属性指向原型，<code>__proto__</code>将对象和原型连接起来组成了原型链</p>
</li>
</ul>
<h2 id="8-var-let-及const区别"><a href="#8-var-let-及const区别" class="headerlink" title="8. var let 及const区别"></a>8. var let 及const区别</h2><ul>
<li><p>函数提升优先变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</p>
</li>
<li><p><code>var</code>存在提升，我们能在声明之前使用。<code>let</code>，<code>const</code>因为暂时性死区的原因，不能在声明前使用</p>
</li>
<li><p><code>var</code>在全局作用域下声明变量会导致变量挂载在<code>window</code>上，其他两者不会</p>
</li>
<li><p><code>let</code>和<code>const</code>作用基本一致，但是后者声明的变量不能再次赋值</p>
</li>
</ul>
<h2 id="9-原型继承和class继承"><a href="#9-原型继承和class继承" class="headerlink" title="9. 原型继承和class继承"></a>9. 原型继承和class继承</h2><p>首先先来讲下class，其实在JS中并不存在类，class只是语法糖，本质还是函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line">Person <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>组合继承</p>
<blockquote>
<p>组合继承是最常用的继承方式</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val  =value</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype =<span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue()<span class="comment">//1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>以上继承的方式核心是在子类的构造函数中通过<code>Parent.call(this)</code>继承父类的属性，然后改变子类的原型为<code>new Parent()</code>来继承父类的函数</li>
<li>这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费</li>
</ul>
<p>寄生组合继承</p>
<blockquote>
<p>这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.val = value   </span><br><span class="line">&#125; </span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>,value)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype,&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:&#123;</span><br><span class="line">        value:Child,</span><br><span class="line">        enumerable:<span class="literal">false</span>,</span><br><span class="line">        writable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue() <span class="comment">//1</span></span><br><span class="line">child.instanceof Parent <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上继承实现的核心就是将父类的原型赋值给了子类，并将构造函数设置为子类，这样即解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p>
</blockquote>
<p>class继承</p>
<blockquote>
<p>以上两种继承方式都是通过原型去解决的，在ES6中，我们可以使用class去实现继承，并且实现起来很简单</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = value</span><br><span class="line">    &#125;</span><br><span class="line">    getValue()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    constrcutor(value)&#123;</span><br><span class="line">        <span class="keyword">super</span>(value)</span><br><span class="line">        <span class="keyword">this</span>.val = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue()<span class="comment">//1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>class 实现继承的核心在于使用<code>extends</code>表明继承自那个父类，并且在子类构造函数中必须嗲偶偶那个<code>super</code>，因为这段代码可以看成<code>Parent.call(this,value)</code></p>
</blockquote>
<h2 id="10-实现一个简洁版的promise"><a href="#10-实现一个简洁版的promise" class="headerlink" title="10. 实现一个简洁版的promise"></a>10. 实现一个简洁版的promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个常量用于表示状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING =<span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that =<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.state = PENDING</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//value 变量用于保存resolve或者reject中传入的值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于保存then中的回调，因为当执行完Promise时状态可能还是等待中，这时候应该把状态存储下来</span></span><br><span class="line">    that.resolvedCallbacks =[]</span><br><span class="line">    that.rejectedCallbacks =[]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//首先两个函数都得判断当前状态是否为等待中</span></span><br><span class="line">        <span class="keyword">if</span>(that.state ===PENDING)&#123;</span><br><span class="line">            that.state =RESOLVED</span><br><span class="line">            that.value = value</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//遍历回调数组并执行</span></span><br><span class="line">            that.resolvedCallbacks.map(<span class="function"><span class="params">cb</span>=&gt;</span>cb(that.value))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(that.state ===PENDING)&#123;</span><br><span class="line">            that.state = REJECTED</span><br><span class="line">            that.value = value</span><br><span class="line">            that.rejectedCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span>cb(that.value))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成以上两个函数以后，我们就该实现如何执行Promise中传入的函数了</span></span><br><span class="line">    <span class="keyword">try</span>()&#123;</span><br><span class="line">        fn(resolve,reject)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后我们来实现较为复杂的then函数</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFullfilled,onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that =<span class="keyword">this</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//判断两个参数是否为函数类型，因为这两个参数是可选参数</span></span><br><span class="line">    onFullfilled = <span class="keyword">typeof</span> onFullfilled === <span class="string">'function'</span> ? onFullfilled: <span class="function"><span class="params">v</span>=&gt;</span>v</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected: <span class="keyword">throw</span> e </span><br><span class="line">   <span class="comment">//当状态不是等待时，就去执行响应的函数。如果状态是等待态的话，就往回调函数中push</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.state === PENDING)&#123;</span><br><span class="line">        <span class="keyword">this</span>.resolvedCallbacks.push(onFullfilled)</span><br><span class="line">        <span class="keyword">this</span>.rejectedCallbacks.push(onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.state === RESOLVED)&#123;</span><br><span class="line">         onFullfilled(that.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.state === REJECTED)&#123;</span><br><span class="line">        onRejected(that.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-Event-Loop"><a href="#11-Event-Loop" class="headerlink" title="11. Event Loop"></a>11. Event Loop</h2><p>进程与线程</p>
<ul>
<li>JS是单线程执行的</li>
<li>进程描述了CPU在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小的单位，描述了执行一段指令所需要的时间</li>
</ul>
<blockquote>
<p>把这些概念拿到浏览器中国来说，当你打开一个Tab页时，其实就是创建了一个进程，一个进程中可以有很多个线程，比如渲染线程，JS引擎线程，HTTP请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁</p>
</blockquote>
<ul>
<li>上文说到了JS引擎线程和渲染线程，大家应该都知道，在JS运行的时候可能会阻止UI渲染，这说明了两个线程是互斥的，这其中的原因是因为JS可以修改DOM，如果在JS执行的时候UI线程还在工作，就可能导致不能安全的渲染UI。这其实也是单线程的好处，得益于JS是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处</li>
</ul>
<p>执行栈</p>
<p>可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</p>
<blockquote>
<p>当开始执行JS代码时，首先会执行一个<code>main</code>函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，foo函数后执行，当执行完毕后就从栈中弹出了</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>

<p>浏览器中的Event loop</p>
<blockquote>
<p>JS是门非阻塞单线程语言，因为在最初JS就是为了和浏览器交互诞生的。如果JS是门多线程语言话，我们在多个线程中处理DOM就可能发生问题</p>
</blockquote>
<ul>
<li>JS在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，就被挂起并加入到<code>Task</code>队列中。一旦执行栈为空，<code>Event Loop</code>就会从Task队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说JS中的异步还是同步行为</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>) <span class="comment">//先后顺序为 script start  script end setTimeout</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不同的任务源会被分配到不同的Task队列中，任务源可以分为微任务和宏任务。</p>
<p>微任务 </p>
<ul>
<li>process.nextTick</li>
<li>promise</li>
<li>Object.observe</li>
</ul>
<p>宏任务</p>
<ul>
<li>script</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>I/O</li>
<li>UI rendering</li>
<li>setTimeout</li>
</ul>
</blockquote>
<p>所以正确的一次Event Loop 顺序是这样的</p>
<ul>
<li>执行同步代码，这属于宏任务</li>
<li>执行栈为空，查询是否有微任务需要执行</li>
<li>执行所有的微任务</li>
<li>必要的话渲染UI</li>
<li>然后开始下一轮 Event loop ，执行宏任务中的异步代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;，<span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="12-手写-call-apply-及bind函数"><a href="#12-手写-call-apply-及bind函数" class="headerlink" title="12. 手写 call apply 及bind函数"></a>12. 手写 call apply 及bind函数</h2><ul>
<li>不传入第一个参数，那么上下文默认为<code>window</code></li>
<li>改变了this指向，让新的对象可以执行该函数，并能接收参数</li>
</ul>
<p>实现call</p>
<ul>
<li><p>首先<code>context</code>为可选参数，如果不传的话，默认上下文为<code>window</code></p>
</li>
<li><p>接下来给<code>context</code>创建一个<code>fn</code>属性，并将值设置为需要调用的函数</p>
</li>
<li><p>因为<code>call</code>可以传入多个参数作为调用的参数，所有需要将参数剥离出来</p>
</li>
<li><p>然后调用函数并将对象上的函数删除</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        thorw <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    context = context || <span class="built_in">window</span></span><br><span class="line">    context.fn = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> result = context.fn(...args)</span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>apply的实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  context = context || <span class="built_in">window</span> </span><br><span class="line">  context.fn = <span class="keyword">this</span> </span><br><span class="line">  <span class="keyword">let</span> result </span><br><span class="line">  <span class="comment">// 处理参数和 call 有区别 </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123; </span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]) </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    result = context.fn() </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">delete</span> context.fn </span><br><span class="line">  <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind的实现</p>
<ul>
<li>bind  返回了⼀个函数，对于函数来说有两种⽅式调⽤，⼀种是直接调⽤，⼀种是通过new  的⽅式，我们先来说直接调⽤的⽅式</li>
<li>对于直接调⽤来说，这⾥选择了 apply  的⽅式实现，但是对于参数需要注意以下情况：<br>因为 bind  可以实现类似这样的代码 f.bind(obj, 1)(2) ，所以我们需要将两边的参<br>数拼接起来，于是就有了这样的实现 args.concat(…arguments)</li>
<li>最后来说通过 new  的⽅式，在之前的章节中我们学习过如何判断 this ，对于 new  的情况来说，不会被任何⽅式改变 this ，所以对于这种情况我们需要忽略传⼊的 this</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> _this =<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//因为返回了一个函数，我们可以new F()，所以需要判断</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> F)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(..args, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context,args.concat(...arguments))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-new"><a href="#13-new" class="headerlink" title="13. new"></a>13. new</h2><p>在调用new的过程中发生四件事情</p>
<ul>
<li>新生成了一个对象</li>
<li>连接到原型</li>
<li>绑定 <code>this</code></li>
<li>返回新对象</li>
</ul>
<h2 id="14-instanceof-的原理"><a href="#14-instanceof-的原理" class="headerlink" title="14. instanceof 的原理"></a>14. instanceof 的原理</h2><p><code>instanceof</code>可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的<code>prototype</code></p>
<p>实现以下<code>instanceof</code></p>
<ul>
<li>首先获取类型的原型</li>
<li>然后获得对象的原型</li>
<li>然后一直循环判断对象的原型是否等于类型的原型，知道对象原型为<code>null</code>，因为原型链最终为<code>null</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">    left = left.__proto__</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left === <span class="literal">null</span> || left === <span class="literal">undefined</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prototype === left)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            left = left.__proto__</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-事件机制"><a href="#15-事件机制" class="headerlink" title="15. 事件机制"></a>15. 事件机制</h2><p>事件触发有三个阶段</p>
<ul>
<li><p><code>window</code>往事件触发处传播，遇到注册的捕获事件会触发</p>
</li>
<li><p>传播到事件触发处触发注册的事件</p>
</li>
<li><p>从事件触发处往<code>window</code>传播，遇到注册的冒泡事件会触发</p>
</li>
</ul>
<h2 id="16-注册事件"><a href="#16-注册事件" class="headerlink" title="16. 注册事件"></a>16. 注册事件</h2><blockquote>
<p>通常我们使用<code>addEventListener</code>注册事件，该函数的三个参数可以是布尔值，也可以是对象。对于布尔值<code>useCapture</code>参数来说，该参数默认值为false，<code>userCapture</code>决定了注册的事件是捕获事件还是冒泡事件。 该参数默认值为false</p>
<ul>
<li>capture： 布尔值，和<code>useCapture</code>作用一样</li>
<li>once: 布尔值，值为<code>true</code>表示该回调只会回调一次，调用后会移除监听</li>
<li>passive： 布尔值，表示永远不会调用<code>preventDefault</code></li>
</ul>
</blockquote>
<blockquote>
<p>一般来说，如果我们只希望事件只触发在目标上，这时候可以使用</p>
<p>stopPropagation来阻止事件的进一步传播，筒仓我们任务<code>stopPropagation</code>是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。</p>
</blockquote>
<p>事件代理</p>
<blockquote>
<p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelected(<span class="string">'#ul'</span>)</span></span><br><span class="line"><span class="actionscript">    ul.addEventListener(<span class="string">'click'</span>,(event)=&gt;&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.target)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>事件代理的方式相较于直接给目标注册事件来说，有以下优点</p>
<ul>
<li>节省内存</li>
<li>不需要给子节点注销事件</li>
</ul>
<h2 id="17-跨域"><a href="#17-跨域" class="headerlink" title="17. 跨域"></a>17. 跨域</h2><ul>
<li>因为浏览器处于安全考虑，有同源策略。如果协议，域名或者端口有一个不同就是跨域，Ajax请求会失败</li>
<li>主要是用来防止CSRF攻击的。简单点说，CSRF攻击是利用用户的登录态发起恶意请求</li>
<li>A网站可以被任意其他来源的Ajax访问到内容。如果你当前A网站还存在登录态，那么对方就可以通过Ajax获取你的任何信息。当然跨域并不能完全阻止CSRF。</li>
</ul>
<ol>
<li>JSONP原理</li>
</ol>
<p>利用<code>&lt;script&gt;</code>标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的JSON数据。JSONP请求一定需要对方的服务器做支持才行</p>
<p>JSON和AJAX对比</p>
<p><code>JSONP</code>和<code>AJAX</code>相同，都是客户端向服务端发送请求，从服务端获取数据的方式。但是<code>AJAX</code>属于同源策略，<code>JSONP</code>属于非同源策略</p>
<p> JSONP优缺点</p>
<p><code>JSONP</code>优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性，不安全可能会遭到xss攻击</p>
<p>JSONP的实现流程</p>
<ul>
<li>声明一个回调函数，其函数名当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)</li>
<li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给<code>script</code>的<code>src</code>，还要再这个地址中向服务器传递函数名(可以通过问号传参:?callback=show)</li>
<li>服务器接收到请求后，需要进行特殊的处理；把传递进来的函数名和它需要给你的数据拼接成一个字符串；</li>
<li>最后服务器把准备的数据通过<code>http</code>协议返回给客户端，客户端再调用执行之前声明的回调函数，对返回的数据进行操作</li>
</ul>
<ol start="2">
<li>cors</li>
</ol>
<p>CORS需要浏览器和后端同时支持。IE8和9通过<code>XDomainRequest</code>来实现</p>
<p>浏览器会自动进行CORS通信，实现CORS通信的关键是后端，只要有段实现了CORS，就实现了跨域。</p>
<p>服务端设置<code>Access-Control-Allow-Origin</code>就可以开始<code>CORS</code>。该属性表示哪些域名可以访问资源，如果设置通配符则表示网站都可以访问资源。</p>
<p>虽然设置CORS和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求</p>
<p>简单请求</p>
<p>只要同时满足以下两大条件，就属于简单请求</p>
<p>条件1：使用下列方法之一</p>
<ul>
<li>GET</li>
<li>HEAD</li>
<li>POST</li>
</ul>
<p>条件2：<code>Content-Type</code>的值仅限于以下三者之一：</p>
<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ul>
<p>请求中任意<code>XMLHttpRequestUpload</code>对象君没有注册任何事件监听器；<code>XMLHttpRequestUpload</code>对象可以使用<code>XMLHttpRequest.upload</code>属性访问</p>
<ol start="3">
<li>postMessage</li>
</ol>
<p><code>postMessage</code>是HTML5 XMLHttpRequest 的API，且是位数不多可以跨域操作的<code>window</code>属性之一，它可以用于解决以下方面的问题：</p>
<ul>
<li>页面和其打开新窗口的数据传递</li>
<li>多窗口之间信息传递</li>
<li>页面与嵌套的<code>iframe</code>消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<p><code>postMessage()</code>方法允许来自不不同源的脚本采用异步方式进行有限的通信，可以实现跨文档，多窗口，跨域消息传递</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message,targetOrigin, [transfer])</span><br></pre></td></tr></table></figure>

<ul>
<li>message: 将要发送到其他window的数据</li>
<li>targetOrigin 通过窗口的origin 属性来指定哪些窗口能接收消息事件，其值可以是字符串或者一个URI。在发送消息的时候，如果目标窗口的协议，主机地址或端口这三者的任意一项不匹配<code>targetOrigin</code>提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//a.html</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/b.html"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">id</span>=<span class="string">"frame"</span> <span class="attr">onload</span>=<span class="string">"load()"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">//内嵌在http://localhost:3000/a.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">   <span class="function"><span class="keyword">function</span> <span class="title">load</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">       <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>)</span></span><br><span class="line"><span class="actionscript">       frame.contentWindow.postMessage(<span class="string">'我爱你'</span>,<span class="string">'http://localhost:4000'</span>)<span class="comment">//发送数据</span></span></span><br><span class="line"><span class="javascript">       <span class="built_in">window</span>.onMessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; <span class="comment">//接收返回数据</span></span></span><br><span class="line"><span class="javascript">           <span class="built_in">console</span>.log(e.data) <span class="comment">//我不爱你</span></span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b.html</span></span><br><span class="line"><span class="built_in">window</span>.onmessage =<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data) <span class="comment">//我爱你</span></span><br><span class="line">    e.source.postMessage(<span class="string">'我不爱你'</span>,e,origin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>websocket</li>
</ol>
<p>websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的券双工通信，同时也是跨域的一种解决方案。<code>webSocket</code>是HTTP都是应用层协议，都基于TCP协议。但是<code>WebSocket</code>是一种双向通信协议，在建立连接之后，<code>WebSocket</code>的<code>server</code>与<code>client</code>都能主动向对方发送或接收数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//socket.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:3000'</span>);</span></span><br><span class="line"><span class="actionscript">    socket.onopen = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        socket.send(<span class="string">'我爱你'</span>); <span class="comment">//向服务器发送数据</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    socket.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.data); <span class="comment">//接收服务器返回的数据</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">let</span> express =<span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="keyword">let</span> webSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>)</span><br><span class="line"><span class="keyword">let</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123;<span class="attr">port</span>:<span class="number">3000</span>&#125;)</span><br><span class="line">wss.on(<span class="string">'connection'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ws</span>)</span>&#123;</span><br><span class="line">    ws.on(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">        ws.send(<span class="string">'我不爱你'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>document.domain</li>
</ol>
<ul>
<li>GIA方式只能用于主域名相同的情况下，比如<code>a.test.com</code>和<code>b.test.com</code>适用于该方式</li>
<li>只需要给页面添加<code>document.domain=&#39;test.com&#39;</code>表示主域名都相同就可以实现跨域</li>
</ul>
<h2 id="18-存储"><a href="#18-存储" class="headerlink" title="18. 存储"></a>18. 存储</h2><ul>
<li>cookie`是网站为了标示用户身份而储存用户本地终端上的数据</li>
<li>cookie数据始终在同源的http请求中携带,即会在浏览器和服务器间来回传递</li>
<li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li>
<li>存储大小<ul>
<li><code>cookie</code>数据大小不能超过4k</li>
<li><code>sessionStorge</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</li>
</ul>
</li>
<li>有限时间<ul>
<li><code>localStorage</code>存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>
<li><code>sessionStorage</code>数据在当前浏览器窗口关闭后自动删除</li>
<li><code>cookie</code>设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>
</li>
</ul>
<h2 id="19-浏览器缓存机制"><a href="#19-浏览器缓存机制" class="headerlink" title="19. 浏览器缓存机制"></a>19. 浏览器缓存机制</h2><ul>
<li>缓存可以说是性能优化中简单高效的一种优化方式，它可以显著减少网络传输所带来的损耗</li>
<li>对于一个数据请求来说，可以分为发起网络请求，后端处理，浏览器响应三个步骤。</li>
</ul>
<p>缓存策略</p>
<blockquote>
<p>通常浏览器缓存策略分为两种；强缓存和协商缓存，并且缓存策略都是通过设置<code>HTTP Header</code>来实现的</p>
</blockquote>
<p>强缓存</p>
<blockquote>
<p>强缓存可以通过设置<code>HTTP Header</code>实现:<code>Expires</code>和<code>Cache-Control</code>。强缓存在缓存期间不需要请求，<code>state code</code> 为200</p>
</blockquote>
<p>Expires</p>
<blockquote>
<p>Expires 是HTTP/1的产物，表示资源会在<code>wed,22 Oct 2018 08:41:00 GMT</code>后过期，需要再次请求。并且<code>Expires</code>受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Oct <span class="number">2018</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure>

<p>Cache-control</p>
<ul>
<li><p><code>Cache-control</code>出现在HTTP/1.1优先级高于<code>Expires</code>。该属性值表示资源会在<code>30</code>秒后过期，需要再次请求</p>
</li>
<li><p><code>Cache-Control</code>可以在请求头或者响应头中设置，并且可以组合使用多种指令</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-control: max-age&#x3D;30</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等</p>
</blockquote>
<p>协商缓存</p>
<ul>
<li>如果缓存过期了，就需要发起验证资源是否有更新。协商缓存可以通过设置两种<code>HTTP Header</code>实现<code>Last-Modified</code>和<code>ETag</code></li>
<li>当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回304状态码，并且更新浏览器缓存有效期。</li>
</ul>
<p><code>Last-modified</code>和<code>if-Modified-since</code></p>
<blockquote>
<p>Last-Modified 表示本地文件最后修改日期, <code>if-Modified-Since</code>会将<code>Last-Modified</code>的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回304状态码</p>
</blockquote>
<p>但是<code>Last-Modified</code>存在一些弊端：</p>
<ul>
<li>如果本地打开缓存文件，即使没有对文件进行修改，带还是会造成<code>Last-Modified</code>被修改，服务端不能命中缓存导致发送相同的资源。</li>
<li>因为<code>Last-Modified</code>只是以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源因为以上这些弊端，所以在HTTP/1.1出现了<code>ETag</code></li>
</ul>
<p>ETag 和if-None-Match</p>
<ul>
<li>ETag类似于文件指纹,<code>If-None-Match</code>会将当前<code>ETag</code> 发送给服务器，询问该资源<code>ETag</code>是否变动，有变动的话就将新的资源发送回来。并且<code>ETag</code>优先级比<code>Last-Modified</code>高</li>
</ul>
<blockquote>
<p>对于频繁变动的资源，首先需要使用<code>Catche-Control:no-cache</code>使浏览器每次都请求服务器，然后配合<code>ETag</code>或者<code>Last-Modified</code>来验证资源是否有效。</p>
</blockquote>
<h2 id="20-浏览器渲染原理"><a href="#20-浏览器渲染原理" class="headerlink" title="20. 浏览器渲染原理"></a>20. 浏览器渲染原理</h2><ol>
<li>浏览器接收到HTML文件并转换为<code>DOM</code>树</li>
</ol>
<p>在网络传输的内容其实都是0和1这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。当数据转换为字符串以后，浏览器会将这些字符串通过词法分析转换为标记。这些标记会紧接着转换为Node，最后这些Node会根据不同<code>Node</code>之间的联系构成为一棵<code>DOM</code>树</p>
<ol start="2">
<li>将CSS文件转换为CSSOM树</li>
</ol>
<blockquote>
<p>其实转换<code>CSS</code>到<code>CSSOM</code>树的过程和上一小节的过程是极其类似的</p>
</blockquote>
<ul>
<li>在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归<code>CSSOM</code>树，然后确定具体的元素到底是什么样式</li>
</ul>
<ol start="3">
<li>生成渲染树</li>
</ol>
<blockquote>
<p>当我们生成<code>DOM</code>树和<code>CSSOM</code>树以后，就需要将这两棵树组合为渲染树</p>
</blockquote>
<ul>
<li>在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是<code>display:none</code>的，那么就不会在渲染树中显示</li>
<li>当浏览器生成渲染树以后，就会根据渲染树来进行布局，然后调用<code>GPU</code>绘制，合成图层，显示在屏幕上。</li>
</ul>
<p>为什么操作DOM慢?</p>
<ul>
<li>因为<code>DOM</code>是属于渲染引擎中的东西，而<code>JS</code>又是<code>JS</code>引擎中的东西。当我们通过<code>JS</code>操作<code>DOM</code>的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作<code>DOM</code>次数一多，也就等同于一直在进行线程之间的通信，并且操作<code>DOM</code>可能会带来重绘回流的问题，所以也就导致了性能上的问题。</li>
</ul>
<p>重绘和回流</p>
<ul>
<li>重绘是当节点需要更改外观而不会影响布局的，比如改变<code>color</code>就叫成为重绘</li>
<li>回流是布局或者几何属性需要改变就成为回流</li>
<li>回流必定发生重绘，重绘不一定会引发回流。回流所需要的成本比重绘高的多，改变父节点的子节点很可能会导致父节点的一系列回流。</li>
</ul>
<p>以下几个动作可能会导致性能问题</p>
<ul>
<li>改变<code>window</code>大小</li>
<li>改变字体</li>
<li>添加或删除样式</li>
<li>文字改变</li>
<li>定位或者浮动</li>
<li>盒模型</li>
</ul>
<p>减少重绘和回流</p>
<ol>
<li>使用<code>visibility</code>替换<code>display:none</code>，因为前者只会引起重绘，后者会引发回流(改变了布局)</li>
<li>不要把节点的属性值放在一个循环里当成循环里的变量</li>
<li>不要使用<code>table</code>布局，可能很小的一个小改动会造成整个<code>table</code>的重新布局</li>
<li><code>css</code>选择符从右往左匹配查找，避免节点层级过多</li>
<li>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。</li>
</ol>
<h2 id="21-安全防范"><a href="#21-安全防范" class="headerlink" title="21. 安全防范"></a>21. 安全防范</h2><ol>
<li>xss</li>
</ol>
<ul>
<li>xss，就是攻击者想尽一切办法将可以执行的代码注入到网页中。</li>
<li>xss，可以分为多种类型，但是总体上可以分为两类：持久型和非持久型</li>
<li>持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都收到攻击</li>
</ul>
<blockquote>
<p>举个例子，对于评论功能来说，就得防范持久型xss攻击，因为我可以在评论中输入以下内容</p>
</blockquote>
<ul>
<li>这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到</li>
<li>非持久型相比前者危害就小的多，一般通过修改URL参数的方式加入攻击代码，诱导用户访问链接从而进行攻击</li>
</ul>
<blockquote>
<p>举个例子，如果页面需要从URL中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于XSS攻击来说，通常由两种方式可以用来防御</p>
</blockquote>
<ol>
<li>转义字符</li>
</ol>
<blockquote>
<p>首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号，尖括号，斜杠进行转义</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123; </span><br><span class="line">  str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>) </span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>) </span><br><span class="line">  str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>) </span><br><span class="line">  str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quto;'</span>) </span><br><span class="line">  str = str.replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>) </span><br><span class="line">  str = str.replace(<span class="regexp">/`/g</span>, <span class="string">'&amp;#96;'</span>) </span><br><span class="line">  str = str.replace(<span class="regexp">/\//g</span>, <span class="string">'&amp;#x2F;'</span>) </span><br><span class="line">  <span class="keyword">return</span> str </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过转义可以将攻击代码 <script>alert(1)</script>  变成</p>
<p>// -&gt; &lt;script&gt;alert(1)&lt;&#x2F;script&gt;<br>escape(‘<script>alert(1)</script>‘)</p>
</blockquote>
<ol start="2">
<li>CSP</li>
</ol>
<blockquote>
<p>CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少XSS攻击</p>
</blockquote>
<p>通常可以通过两种方式来开启CSP:</p>
<ul>
<li>设置<code>HTTP Header</code>中的<code>Content-Security-Policy</code></li>
<li>设置<code>meta</code>标签的方式<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li>
</ul>
<p>只允许加载本站资源</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src ‘self’</span><br></pre></td></tr></table></figure>

<p>只允许加载 HTTPS 协议图⽚</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: img-src https:<span class="comment">//*</span></span><br></pre></td></tr></table></figure>

<p>允许加载任何来源框架</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: child-src <span class="string">'none'</span></span><br></pre></td></tr></table></figure>

<p>CSRF</p>
<blockquote>
<p>CSRF 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑</p>
</blockquote>
<p>举个例子，假设网站中有一个通过<code>GET</code>请求提交评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.domain.com/xxx?comment='attack'"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如何防御</p>
<ul>
<li>GET请求不对数据进行修改</li>
<li>不让第三方网站访问到用户<code>Cookie</code></li>
<li>阻止第三方网站请求接口</li>
<li>请求时附带验证信息，比如验证码或者Token</li>
</ul>
<p>SameSite</p>
<blockquote>
<p>可以对<code>Cookie</code>设置<code>SameSite</code>属性。该属性表示<code>Cookie</code>不随着跨域请求发送，可以很大程度减少<code>CSRF</code>的攻击，但是该属性目前并不是所有浏览器都兼容</p>
</blockquote>
<p>Token</p>
<blockquote>
<p>服务器下发一个随机<code>Token</code>，每次发起请求时将<code>Token</code>携带上，服务器验证<code>Token</code>是否有效</p>
</blockquote>
<h2 id="22-性能优化"><a href="#22-性能优化" class="headerlink" title="22. 性能优化"></a>22. 性能优化</h2><ol>
<li>图片优化</li>
</ol>
<p>计算图片大小</p>
<ul>
<li>在实际项目中，一张图片可能不需要使用很多颜色去显示，可以通过减少每个像素的调色板来相应缩小图片的大小</li>
</ul>
<ol start="2">
<li>图片加载优化</li>
</ol>
<ul>
<li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用CSS去代替</li>
<li>一般图片都用CDN加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片</li>
<li>小图使用<code>base64</code>格式</li>
<li>将多个图标文件整合到一张图片中</li>
<li>选择正确的图片格式<ul>
<li>小图使用PNG，其实对于大部分图片这类图片，完全可以使用<code>SVG</code>代替</li>
<li>照片使用<code>JPEG</code></li>
</ul>
</li>
</ul>
<ol start="3">
<li>DNS预解析</li>
</ol>
<blockquote>
<p>DNS解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的IP</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"dns-prefetch"</span> href=<span class="string">"//blog.poetries.top"</span>&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>节流</li>
</ol>
<blockquote>
<p>考虑一个场景，滚动事件中发起网络请求，但是我们并不希望用户在滚动过程中中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//func 是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">//wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">func,wait=<span class="number">50</span></span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//上一次执行该函数的时间</span></span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//当前时间</span></span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="comment">//将当前时间和上一次执行函数时间对比</span></span><br><span class="line">        <span class="comment">//如果差值大于设置的等待时间就执行函数</span></span><br><span class="line">        <span class="keyword">if</span>(now -lastTime &gt;wait)&#123;</span><br><span class="line">            lastTime =now</span><br><span class="line">            func.apply(<span class="keyword">this</span>,args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(</span><br><span class="line">  throttle(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;,<span class="number">500</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>防抖</li>
</ol>
<blockquote>
<p>考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望没每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们可以使用防抖</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//func 是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">//wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">func,wait=<span class="number">50</span></span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//缓存一个定时器id</span></span><br><span class="line">    <span class="keyword">let</span>  timer=<span class="number">0</span> </span><br><span class="line">    <span class="comment">//这里返回的函数是每次用户实际调用的防抖函数</span></span><br><span class="line">    <span class="comment">//如果已经设定过定时器了就清空上一次的定时器</span></span><br><span class="line">    <span class="comment">//开始一个新的定时器，延迟执行用户传入的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">..args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer) clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            func.apply(<span class="keyword">this</span>,args)</span><br><span class="line">        &#125;,wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>预加载</li>
</ol>
<ul>
<li>在开发中，可能遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候可以使用预加载</li>
<li>预加载其实是声明的<code>fetch</code>，强制浏览器请求资源，并不会阻塞<code>onload</code>事件，可以使用以下代码开启预加载</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preload"</span> href=<span class="string">"http://blog.poetries.top"</span>&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好</p>
</blockquote>
<ol start="7">
<li>懒加载</li>
</ol>
<ul>
<li>懒加载就是将不关键的资源延后加载</li>
<li>懒加载的原理就是只加载自定义区域(通常是可视区域，但也可以是即将进入可视区域)内需要加载的东西。对于图片来说，先设置图片标签的<code>src</code>属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为<code>src</code>属性，这样图片就会去下载资源，实现了图片懒加载</li>
<li>懒加载不仅可以用于图片，也可以使用在别的资源。比如进入可视区域开始播放视频等等</li>
</ul>
<ol start="8">
<li>CDN</li>
</ol>
<blockquote>
<p>CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源</p>
<p>我们可以将静态资源尽量使用<code>CDN</code>加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个<code>CDN</code>域名。并且对于<code>CDN</code>加载静态资源需要注意<code>CDN</code>域名要与主站不同，否则每次请求都会带上主站的<code>Cookie</code></p>
</blockquote>
<h2 id="23-MVVM-虚拟DOM-前端路由"><a href="#23-MVVM-虚拟DOM-前端路由" class="headerlink" title="23. MVVM/虚拟DOM/前端路由"></a>23. MVVM/虚拟DOM/前端路由</h2><p>什么是MVVM？与之MVC有什么区别？</p>
<ul>
<li><code>view</code>很简单，就是用户看到的视图</li>
<li><code>Model</code>同样很简单，一般就是本地数据和数据库中的数据</li>
</ul>
<blockquote>
<p>传统的MVC框架通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新</p>
</blockquote>
<ul>
<li>但是<code>MVC</code>有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况</li>
<li>在<code>MVVM</code>架构中，引入了<code>ViewModel</code>的概念。<code>ViewModel</code>只关心数据和业务的处理，不关心<code>view</code>如何处理数据，在这种情况下，<code>view</code>和<code>model</code>都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个<code>ViewModel</code>中，让多个<code>View</code>复用这个<code>ViewModel</code></li>
<li>对于<code>MVVM</code>来说，其实最重要的并不是通过双向绑定或者其他的方式将<code>View</code>与<code>viewModel</code>绑定起来，而是通过<code>ViewModel</code>将视图中的状态和用户的行为分离出一个抽象，这才是<code>MVVM</code>的精髓</li>
</ul>
<p>Virtual DOM</p>
<blockquote>
<p>设计面试题： 什么是<code>Virtual DOM</code>？为什么<code>Virtual DOM</code>比原生DOM快？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ul =&#123;</span><br><span class="line">    tag: <span class="string">'ul'</span>,</span><br><span class="line">    props:&#123;</span><br><span class="line">        class:'list'</span><br><span class="line">    &#125;,</span><br><span class="line">    children:&#123;</span><br><span class="line">        tag:<span class="string">'li'</span>,</span><br><span class="line">        children:<span class="string">'1'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码对应的<code>DOM</code>就是</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>那么既然<code>DOM</code>可以通过<code>JS</code>对象来模拟，反之也可以通过<code>JS</code>对象来渲染出对应的<code>DOM</code>。当然了，通过<code>JS</code>来模拟<code>DOM</code>并渲染对应的<code>DOM</code>只是第一步，难点在于如何判断新旧两个<code>JS</code>对象的最小差异并且实现局部更新<code>DOM</code></li>
</ul>
<blockquote>
<p>首先<code>DOM</code>是一个多叉树的结构，如果需要完整的对比两棵树的差异，那么需要的时间复杂度会使<code>O(n^3)</code>那么复杂度肯定是不能接受的。于是优化了算法，实现了<code>O(n)</code>的复杂度来对比差异。</p>
</blockquote>
<ul>
<li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异</li>
<li>一旦节点有子元素，就去判断子元素是否有不同</li>
</ul>
<blockquote>
<p>在第一步算法中我们需要判断新旧节点的<code>tagName</code>是否相同，如果不相同的话就代表节点被替换。如果没有更改<code>tageName</code>的话，就需要判断是否有子元素，有的话就进行第二步算法。</p>
</blockquote>
<blockquote>
<p>在第二步算法中，我们需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动</p>
</blockquote>
<p>举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//假设这里模拟一个ul，其中包含了5个li</span><br><span class="line">[1,2,3,4,5]</span><br><span class="line">//这里替换上面的li</span><br><span class="line">[1,2,5,4]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上述例子中，我们可以一眼看出先前的<code>ul</code>中的第三个<code>li</code>被移除了四五替换了位置</p>
</blockquote>
<ul>
<li><p>当然在判断以上差异的过程汇总，我们还需要判断节点的属性是否有变化等等</p>
</li>
<li><p>当我们判断出以上的差异后，就可以把这些差异记录下来。当对比完两棵树以后，就可以通过去局部更新<code>DOM</code>，实现性能的最优化</p>
</li>
<li><p>将<code>Virtual DOM</code>作为一个兼容层，让我们还能对接非<code>Web</code>端的系统，实现跨端开发</p>
</li>
<li><p>实现组件的高度抽象化</p>
</li>
</ul>
<p>前端路由</p>
<ul>
<li>Hash模式</li>
<li>History模式</li>
</ul>
<ol>
<li>Hash模式</li>
</ol>
<blockquote>
<p>·<code>www.test.com/#/</code>就是<code>Hash URL</code>，当<code>#</code>后面的哈希值发生变化时，可以通过<code>hashchange</code>事件来监听到<code>URL</code>的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的<code>URL</code>请求永远是<code>www.test.com</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>，()=&gt;&#123;</span><br><span class="line">    <span class="comment">//...具体逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Hash模式相对来说更简单，并且兼容性也更好</p>
</blockquote>
<ol start="2">
<li>History模式</li>
</ol>
<blockquote>
<p>History 模式是HTML5新推出的功能，主要使用<code>history.pushState</code>和<code>history.replaceState</code>改变<code>URL</code></p>
</blockquote>
<ul>
<li>通过<code>History</code>模式改变<code>URL</code>同样不会引起页面的刷新，只会更新浏览器的历史记录</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增历史记录</span></span><br><span class="line">history.pushState(stateObject,title,URL)</span><br><span class="line"><span class="comment">//替换当前历史记录</span></span><br><span class="line">history,replaceState(stateObject,title,URL)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当用户做出浏览器动作时，比如点击后托按钮时触发<code>popState</code>事件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popState'</span>,e=&gt;&#123;</span><br><span class="line">    <span class="comment">//e.state 就是`pushState(stateObject)中的stateObject`</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.state)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>两种模式对比</p>
<ul>
<li>hash模式只可以更改<code>#</code>后面的内容，<code>History</code>模式可以通过<code>API</code>设置任意的同源<code>URL</code></li>
<li><code>History</code>模式可以通过<code>API</code>添加任意类型的数据到历史记录中,<code>Hash</code>模式只能更改哈希值，也就是字符串</li>
<li><code>Hash</code>模式无需后端配置，并且兼容性好。<code>History</code>模式在用户手动输入地址或者刷新页面的时候发起<code>URL</code>请求，后端需要配置<code>index.html</code>页面用于匹配不到静态资源的时候</li>
</ul>
<h2 id="24-Vue常考知识点"><a href="#24-Vue常考知识点" class="headerlink" title="24. Vue常考知识点"></a>24. Vue常考知识点</h2><p>生命周期钩子函数</p>
<ul>
<li>在<code>beforeCreate</code>钩子函数调用的时候，是获取不到<code>props</code>或者<code>data</code>中的数据的，因为这些数据的初始化都在<code>initState</code>中</li>
<li>然后会执行<code>created</code>钩子函数，在这一步的时候已经可以访问到之前不能访问的数据，但是这时候组件还没被挂载，所以是看不到的</li>
<li>接下来会先执行<code>beforeMounted</code>钩子函数，开始创建<code>VDOM</code>，最后执行<code>mounted</code>钩子，并将<code>VDOM</code>渲染为真实<code>DOM</code>并且渲染数据。组件中如果有子组件的话，会递归挂载组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子</li>
<li>接下来是数据更新时会调用的钩子函数<code>beforeUpdate</code>和<code>updated</code>，这两个钩子函数没有什么好说的，就是分别在数据更新前和更新后调用</li>
<li>另外还有<code>keep-alive</code>独有的生命周期,分别为<code>activated</code>和<code>decativated</code>。用<code>keep-alive</code>包裹的组件在切换时不会进行销毁，而是魂村到内存中并执行<code>deactivated</code>钩子函数，命中缓存渲染后执行<code>actived</code>钩子函数</li>
<li>最后就是销毁组件的钩子函数<code>beforeDestory</code>和<code>destoryed</code>。前者适合移除事件，定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的<code>destoryed</code>钩子函数</li>
</ul>
<p>组件通信</p>
<ul>
<li>父子组件通信</li>
<li>兄弟组件通信</li>
<li>跨多层级组件通信</li>
</ul>
<ol>
<li>父子通信</li>
</ol>
<ul>
<li>父组件通过<code>prop</code>传递数据给子组件，子组件通过<code>emit</code>发送事件传递给父组件，这两种方式是最常用的父子通信实现方法</li>
<li>这种父子通信方式也就是典型的单向数据流，父组件通过<code>props</code>传递数据，子组件不能直接修改<code>props</code>而是必须通过发送事件的方式告知父组件修改数据</li>
<li>当然我们还可以通过访问<code>$parent</code>或者<code>$children</code>对象来访问组件实例中的方法和数据</li>
<li>另外如果你使用<code>Vue2.3</code>及以上版本的话还可以使用<code>$listeners</code>和<code>.sync</code>这两个属性</li>
<li><code>$listeners</code>属性会将父组件中的<code>v-on</code>事件监听器传递给子组件，子组件可以通过访问<code>$listeners</code>来自定义监听器</li>
<li><code>.sync</code>属性是个语法糖，可以很简单的实现子组件与父组件通信</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 父组件中</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value.sync</span>=<span class="string">"value"</span>&gt;</span></span><br><span class="line">//以上写法等同于</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">"value"</span> @<span class="attr">update:value</span>=<span class="string">"v=&gt;value =v"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//子组件中</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.$emit(<span class="string">'update:value'</span>,<span class="number">1</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>兄弟组件通信</li>
</ol>
<blockquote>
<p>对于这种情况可以通过查找父组件中的子组件实现，也就是<code>this.$parent.$children</code>，在<code>$children</code>中可以通过组件<code>name</code>查询到需要的组件实例，然后进行通信</p>
</blockquote>
<ol start="3">
<li>跨多层次组件通信</li>
</ol>
<blockquote>
<p>d对于这种情况可以使用新增的<code>API provide/ inject</code>，虽然文档中不推荐直接使用在业务中，但是如果用的好的话还是很有用的</p>
</blockquote>
<p>假设有父组件A，然后有一个跨多层级的子组件B</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    provide:&#123;</span><br><span class="line">        data:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子组件B</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    inject:[<span class="string">'data'</span>],</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        <span class="comment">//无论跨基层都能获得父组件的data属性</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终极办法解决一切通信问题</p>
<blockquote>
<p>可以使用<code>Vuex</code>或者<code>Event Bus</code></p>
</blockquote>
<p><code>extend</code>能做什么</p>
<blockquote>
<p>这个<code>API</code>很少用到，作用是扩展组件生成一个构造器，通常会与<code>$mount</code>一起使用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建组件构建器</span></span><br><span class="line"><span class="keyword">let</span> Component = Vue.extend(&#123;</span><br><span class="line">    template: <span class="string">'&lt;div&gt;test&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//挂载到#app上</span></span><br><span class="line"><span class="keyword">new</span> Component().$mount(<span class="string">'#app'</span>)</span><br><span class="line"><span class="comment">//除了上面的方式，还可以用来扩展已有的组件</span></span><br><span class="line"><span class="keyword">let</span> SuperComponent = Vue.extend(Component)</span><br><span class="line"><span class="keyword">new</span> SuperComponent(&#123;</span><br><span class="line">    created()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> SuperComponent().$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p><code>mixin</code>和<code>mixins</code>区别</p>
<blockquote>
<p><code>mixin</code>用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    beforeCreate()&#123;</span><br><span class="line">      <span class="comment">//...逻辑</span></span><br><span class="line">        <span class="comment">//这种方式会影响到每个组件的`beforeCreate`钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>虽然文档不建议我们在应用中直接使用<code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的<code>ajax</code>或者一些工具函数等等</li>
<li><code>mixins</code>应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过<code>mixins</code>混入代码，比如上拉下拉加载数据这种逻辑等等</li>
<li>另外需要注意的是<code>mixins</code>混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并</li>
</ul>
<ol start="5">
<li><code>computed</code>和<code>watch</code>区别</li>
</ol>
<ul>
<li><code>computed</code>是计算属性，依赖其他属性计算值，并且<code>computed</code>的值由缓存，只有当计算值变化才会返回内容</li>
<li><code>watch</code>监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作</li>
<li>所以一般来说需要依赖别的属性来动态获得值的时候可以使用<code>computed</code>，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用<code>watch</code></li>
<li>另外<code>computed</code>和<code>watch</code>还都支持对象的写法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(<span class="string">'obj'</span>,&#123;</span><br><span class="line">    <span class="comment">//深度遍历</span></span><br><span class="line">    deep:<span class="literal">true</span></span><br><span class="line">    <span class="comment">//立即触发</span></span><br><span class="line">    immediate： <span class="literal">true</span>，</span><br><span class="line">    <span class="comment">//执行的函数</span></span><br><span class="line">    handler: <span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data:&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        aPlus:&#123;</span><br><span class="line">            <span class="comment">//this.aPlus 时触发</span></span><br><span class="line">            <span class="keyword">get</span>: function()&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.a +<span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//this.aPlus =1 时触发</span></span><br><span class="line">            <span class="keyword">set</span>: function(v)&#123;</span><br><span class="line">                <span class="keyword">this</span>.a =v <span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>keep-alive</code> 组件有什么作用</p>
<ul>
<li>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用<code>keep-alice</code>组件包裹需要保存的组件</li>
<li>对于<code>keep-alive</code>组件来说，它拥有两个独有的生命周期函数，分别为<code>activated</code>和<code>deactivated</code>。用<code>keep-alive</code>包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行<code>deactivated</code>钩子函数，命中缓存渲染后执行<code>actived</code>钩子函数</li>
</ul>
<p><code>v-show</code> 与<code>v-if</code>区别</p>
<ul>
<li><code>v-show</code>只是在<code>display:none</code>和<code>display:block</code>之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换<code>CSS</code>，<code>DOM</code>还是一致保留着的。所以总的来说<code>v-show</code>在初始选时有更高的开销，但是切换开销很小，更适合于频繁切换的场景</li>
<li><code>v-if</code>的话就得说到<code>Vue</code>底层的编译了。当属性初始为<code>false</code>时，组件就不会被渲染，直到条件为<code>true</code>，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景</li>
<li>并且基于<code>v-if</code>的这种惰性机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销</li>
</ul>
<p>组件中<code>data</code>什么时候可以使用对象</p>
<ul>
<li>组件复用时所有组件实例都会共享<code>data</code>，如果<code>data</code>是对象的话，就会造成一个组件修改<code>data</code>以后会影响到其他所有组件，所以需要将<code>data</code>写成函数，每次用到就调用一次函数获得新的数据</li>
<li>当我们使用<code>new Vue()</code>的方式的时候，无论我们将<code>data</code>设置为对象还是函数都是可以的，因为<code>new Vue()</code>的方式是生成一个根组件，该组件不会复用，也就不存在共享<code>data</code>的情况</li>
</ul>
<p>响应式原理</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2018/4/24/162f71d7977c8a3f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<blockquote>
<p>Vue 内部使用了<code>Object.defineProperty()</code>来实现数据响应式，通过这个函数可以监听到<code>set</code>和<code>get</code>的事件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">name</span>: <span class="string">'poetries'</span>&#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">let</span> name = data.name <span class="comment">//-&gt; get value</span></span><br><span class="line">data.name =<span class="string">'yyy'</span> <span class="comment">//-&gt;change value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//判断类型</span></span><br><span class="line">   <span class="keyword">if</span>(!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">       defineReactive(obj,key,obj[key])</span><br><span class="line">   &#125;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,val</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//递归子属性</span></span><br><span class="line">    observe(val)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        <span class="comment">//可枚举</span></span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">//可配置</span></span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">//自定义函数</span></span><br><span class="line">        <span class="keyword">get</span>: function reactiveGetter()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function reactiveaSetter(newVal)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">            val = newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上代码简单的实现了如何监听数据的<code>set</code>和<code>get</code>的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，从而在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接下来我们先来实现一个<code>Dep</code>类，用于解耦属性的依赖收集和派发更新操作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Dep解耦属性的依赖和更新操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.subs =[]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加依赖</span></span><br><span class="line">    addSub(sub)&#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新</span></span><br><span class="line">    notify()&#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span>=&gt;</span>&#123;</span><br><span class="line">            sub.update()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全局属性，通过该属性配置Watcher</span></span><br><span class="line">Dep.target =<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上的代码实现很简单，当需要依赖收集的时候调用<code>addSub</code>，当需要派发更新的时候调用<code>notify</code></p>
</blockquote>
<blockquote>
<p>接下来我们先简单的了解下<code>Vue</code>组件挂载时添加响应式的过程。在组件挂载时，会先对所有需要的属性调用<code>Object.defineProperty()</code>，然后实例化<code>watcher</code>，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(obj,key,cb)&#123;</span><br><span class="line">       <span class="comment">//将`Dep.target`指向自己</span></span><br><span class="line">        <span class="comment">//然后触发属性的`getter`添加监听</span></span><br><span class="line">        <span class="comment">//最后将`Dep.target置空`</span></span><br><span class="line">        Dep.target =<span class="keyword">this</span></span><br><span class="line">        <span class="keyword">this</span>.cb =cb</span><br><span class="line">        <span class="keyword">this</span>.key =key</span><br><span class="line">        <span class="keyword">this</span>.obj =obj</span><br><span class="line">        <span class="keyword">this</span>.value = obj[key]</span><br><span class="line">        Dep.target =<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    upDate()&#123;</span><br><span class="line">        <span class="comment">//获得新值</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key]</span><br><span class="line">        <span class="comment">//调用update方法更新Dom</span></span><br><span class="line">        <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上就是<code>Watcher</code>的简单实现，在执行构造函数的时候将<code>Dep.target</code>指向自身，从而使得收集到了对应的<code>Watcher</code>，在派发更新的时候取出对应的<code>Watcher</code>然后执行<code>update</code>函数</p>
</blockquote>
<p>接下来，需要对<code>defineReactive</code>函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,val</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//递归子属性</span></span><br><span class="line">    observe(val)</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj.key,&#123;</span><br><span class="line">        enumerable:<span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function reactiveGetter()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">            <span class="comment">//将`Watcher`添加到订阅</span></span><br><span class="line">            <span class="keyword">if</span>(Dep.target)&#123;</span><br><span class="line">                dp.addSub(Dep.target)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function reactiveSetter(newVal)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">            val = newVal</span><br><span class="line">            <span class="comment">//执行 watcher 的 update 方法</span></span><br><span class="line">            dp.notify()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上代码实现了一个简单的数据响应式，核心思路就是手动触发一次属性的<code>getter</code>来实现依赖收集</p>
</blockquote>
<p><code>Object.defineProperty</code>的缺陷</p>
<ul>
<li>如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为<code>Object.defineProperty</code>不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是<code>Vue</code>内部通过重写函数的方式解决了这个问题。</li>
</ul>
<p><code>NextTick</code>原理分析</p>
<blockquote>
<p><code>nextTick</code>可以让我们在下次<code>DOM</code>更新循环结束之后执行延迟回调，用于获得更新后的<code>DOM</code></p>
</blockquote>
<h2 id="25-TCP-UDP"><a href="#25-TCP-UDP" class="headerlink" title="25. TCP/UDP"></a>25. TCP/UDP</h2><blockquote>
<p>UDP 与TCP的区别</p>
</blockquote>
<p>首先，<code>UDP</code>协议是面向无连接的，也就是不需要在正式传递数据之前先连接器双方。然后<code>UDP</code>协议知识数据报文的搬运工，不保证有序且不丢失的传递到对端，并且<code>UDP</code>协议也没有任何控制流量的算法，总的来说<code>UDP</code>相较于<code>TCP</code>更加轻巧</p>
<ol>
<li>面对无连接</li>
</ol>
<ul>
<li>首先<code>UDP</code>是不需要和<code>TCP</code>一样在发送数据前进行三次握手建立连接的，想法数据就可以发送了</li>
<li>并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作</li>
</ul>
<ol start="2">
<li>不可靠性</li>
</ol>
<ul>
<li>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定是不可靠</li>
<li>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了</li>
<li>再者网络环境时好时坏，但是<code>UDP</code>因为没有拥塞控制，一直会以恒定的速度发送数据</li>
</ul>
<ol start="3">
<li>高效</li>
</ol>
<ul>
<li>虽然<code>UDP</code>协议不是那么的靠谱，但是正因为它不是那么可靠，所以也没有<code>TCP</code>那么复杂了，需要保证数据不丢失且有序到达。</li>
<li>因此<code>UDP</code>的头部开销小，只有八字节</li>
</ul>
<ol start="4">
<li>传输方式</li>
</ol>
<blockquote>
<p><code>UDP</code>不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是<code>UDP</code>提供了单播，多播，广播的功能</p>
</blockquote>
<ol start="5">
<li><p>适合使用场景</p>
<p>直播</p>
</li>
</ol>
<p>王者荣耀(游戏，网络游戏)</p>
<p>TCP</p>
<blockquote>
<p>TCP基本是和<code>UDP</code>反着来，建立连接断开连接连接都需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比<code>UDP</code>来说并不那么高效</p>
</blockquote>
<ol>
<li>头部</li>
</ol>
<blockquote>
<p>对于TCP头部来说，以下几个字段是很重要的</p>
</blockquote>
<ul>
<li><code>Sequence number</code>，这个序号保证了TCP传输的报文都是有序的，对端可以通过需要顺序的拼接报文</li>
<li><code>Acknowledgement Number</code>，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到</li>
</ul>
<p>后续在写</p>
<h2 id="26-设计模式"><a href="#26-设计模式" class="headerlink" title="26. 设计模式"></a>26. 设计模式</h2><blockquote>
<p>设计模式总的来说是一个抽象的概念，前人通过无数次的实践总结出的一套写代码的方式，通过这个方式写的代码可以让别人更加容易阅读，维护以及复用</p>
</blockquote>
<ol>
<li>工厂模式</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name =name</span><br><span class="line">    &#125;</span><br><span class="line">    alertName()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> create(name)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Man(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Factory.create(<span class="string">'yck'</span>).alertName()</span><br></pre></td></tr></table></figure>

<ul>
<li>当然工厂模式并不仅仅是用来<code>new</code> 出实例</li>
<li>可以想想一个场景、假设有一份很复杂的代码需要用户去调用，但是用户并不关心这些复杂的代码，只需要你提供给我一个接口去调用，用户只负责传递需要的参数，至于这些参数怎么使用，内部又什么逻辑是不关心的，只需要你最后返回我一个实例。这个构造函数就是工厂</li>
<li>工厂起到的作用就是隐藏了创建实例的复杂度，只需要提供一个接口，简单清晰</li>
<li>在<code>Vue</code>源码中，你也可以看到工厂模式的使用，比如创建异步组件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">  Ctor: Class&lt;Component&gt; | Function | Object | void, </span></span></span><br><span class="line"><span class="function"><span class="params">  data: ?VNodeData, </span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component, </span></span></span><br><span class="line"><span class="function"><span class="params">  children: ?Array&lt;VNode&gt;, </span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string </span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; | <span class="title">void</span> </span>&#123; </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 逻辑处理... </span></span><br><span class="line">   </span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode( </span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">''</span>&#125;</span>`</span>, </span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context, </span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;, </span><br><span class="line">    asyncFactory </span><br><span class="line">  ) </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> vnode </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上述代码中，我们可以看到我们只需要调用<code>createComponent</code>传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能</p>
</blockquote>
<ol start="2">
<li>单例模式</li>
</ol>
<ul>
<li>单例模式很常用，比如全局缓存，全局状态管理等等这些只需要一个对象，就可以使用单例模式</li>
<li>单例模式的核心就是保证全局只有一个对象可以访问。因为<code>JS</code>是门无类的语言，所以别的语言实现单例的方式并不能套入<code>JS</code>中，我们只需要用一个变量实例只创建一次就行，以下是如何实现单例模式的例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Singleton.getInstance =(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = Singleton.getInstance()</span><br><span class="line"><span class="keyword">let</span> s2 = Singleton.getInstance()</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>Vuex</code>源码中，你也可以看到单例模式的使用，虽然它的实现方式不大一样，通过一个外部变量来控制只安装一次<code>Vuex</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue <span class="comment">//bind on install</span></span><br><span class="line"><span class="keyword">export</span>  <span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">_Vue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Vue &amp;&amp; _Vue === Vue)&#123;</span><br><span class="line">        <span class="comment">//如果发现Vue有值，就不重新创建实例了</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    Vue = _Vue</span><br><span class="line">    applyMixin(Vue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>适配器模式</li>
</ol>
<ul>
<li>适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。</li>
<li>以下是如何实现适配器模式的例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plug</span></span>&#123;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'港版插头'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.plug =<span class="keyword">new</span> plug()</span><br><span class="line">    &#125;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>,plug.getName()+ <span class="string">'适配器转二脚插头'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span>  target = <span class="keyword">new</span> Target()</span><br><span class="line">target.getName() <span class="comment">//港版插头 适配器转二脚插头</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>Vue</code>中，我们其实使用到适配器模式。比如父组件传递给子组件一个时间戳属性，组件内部需要将时间戳转为正常的日期显示，一般会使用<code>computed</code>来做转换这件事，这个过程就使用了适配器模式</p>
</blockquote>
<ol start="4">
<li>装饰模式</li>
</ol>
<ul>
<li><p>装饰器模式不需要改变已有的接口，作用是给对象添加功能。就像我们经常需要给手机戴个保护套一样，不改变手机自身，给手机添加添加了保护套提供了防摔功能</p>
</li>
<li><p>以下是如何实现装饰器模式的例子，使用了<code>ES7</code>中的装饰器语法</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target,key,descriptor</span>)</span>&#123;</span><br><span class="line">    descriptor.writable =<span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    @readonly</span><br><span class="line">    name =<span class="string">'yck'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> Test()</span><br><span class="line"></span><br><span class="line">t.yck = <span class="string">'111'</span> <span class="comment">//不可修改</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>代理模式</li>
</ol>
<ul>
<li>代理是为了控制对象的访问，不让外部直接访问到对象。在现实生活中，也有很多代理场景。比如你需要买一件国外的产品，这时候你可以通过代购来购买产品</li>
<li>在实际代码中其实代理的场景很多，比如事件代理就用到了代理模式</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>)</span></span><br><span class="line"><span class="actionscript">   ul.addEventListener(<span class="string">'click'</span>,(event)=&gt;&#123;</span></span><br><span class="line"><span class="javascript">       <span class="built_in">console</span>.log(event.target)</span></span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为存在太多的<code>li</code>，不可能每个都去绑定事件。这时候可以通过父节点绑定一个事件，让父节点作为代理去拿到真实点击的节点</p>
</blockquote>
<ol start="6">
<li>发布-订阅模式</li>
</ol>
<ul>
<li>发布-订阅模式也叫做观察者模式。通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。在现实生活中，也有很多类似场景，比如我需要在购物网站上购买一个产品，但是发现该产品目前处于缺货状态，这时候我们可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我</li>
<li>在实际代码中其实发布-订阅模式也很常见，比如我们点击一个按钮触发了点击事件就是使用了该模式</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ul =<span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>)</span></span><br><span class="line"><span class="actionscript">    ul.addEventListener(<span class="string">'click'</span>,(event)=&gt;&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.target)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>Vue</code>中，如何实现响应式也是使用了该模式。对于需要实现响应式的对象来说，在<code>get</code>的时候会进行依赖收集，当改变了对象的属性时，就会触发派发更新</p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">刘如刚</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.liurugang.cn/posts/63672/">http://blog.liurugang.cn/posts/63672/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.liurugang.cn" target="_blank">无聊才读书-博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%80%BB%E7%BB%93/">总结</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/61960/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">uni-app入坑</div></div></a></div><div class="next-post pull-right"><a href="/posts/25536/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前端面试题-续</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/520520/" title="CSS面试"><img class="relatedPosts_cover" data-src="https://cdn.jsdelivr.net/gh/HCLonely/hclonely.github.io/img/Butterfly/006.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-31</div><div class="relatedPosts_title">CSS面试</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 刘如刚</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><meta name="generator" content="Hexo 4.2.1"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":120,"height":260},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>