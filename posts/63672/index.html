<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>高频考点 | 无聊才读书-博客</title><meta name="description" content="高频考点1. typeof类型判断 typeof 是否能正确判断类型？ instanceof能正确判断对象的原理是什么   type 对于原始类型，除了 null都可以只显示正确的类型  12345typeof 1 &#x2F;&#x2F;&#39;number&#39;typeof &#39;1&#39; &#x2F;&#x2F;&#39;string&#39;typeof undefined &#x2F;&#x2F;&#39;undefined&#39;typeof true &#x2F;&#x2F;&#39;boolean&#39;typeof S"><meta name="keywords" content="hello，总结"><meta name="author" content="刘如刚"><meta name="copyright" content="刘如刚"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.liurugang.cn/posts/63672/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="高频考点"><meta property="og:url" content="http://blog.liurugang.cn/posts/63672/"><meta property="og:site_name" content="无聊才读书-博客"><meta property="og:description" content="高频考点1. typeof类型判断 typeof 是否能正确判断类型？ instanceof能正确判断对象的原理是什么   type 对于原始类型，除了 null都可以只显示正确的类型  12345typeof 1 &#x2F;&#x2F;&#39;number&#39;typeof &#39;1&#39; &#x2F;&#x2F;&#39;string&#39;typeof undefined &#x2F;&#x2F;&#39;undefined&#39;typeof true &#x2F;&#x2F;&#39;boolean&#39;typeof S"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2021-06-02T15:30:53.636Z"><meta property="article:modified_time" content="2021-06-02T18:22:02.503Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="next" title="前端面试题-续" href="http://blog.liurugang.cn/posts/25536/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-06-03 02:22:02'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/Chocolate1999/cdn/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">19</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/home/"><i class="fa-fw fab fa-phoenix-framework"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#高频考点"><span class="toc-number">1.</span> <span class="toc-text">高频考点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-typeof类型判断"><span class="toc-number">1.1.</span> <span class="toc-text">1. typeof类型判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-类型转换"><span class="toc-number">1.2.</span> <span class="toc-text">2.类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-This"><span class="toc-number">1.3.</span> <span class="toc-text">3. This</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-和-有什么区别"><span class="toc-number">1.4.</span> <span class="toc-text">4. &#x3D;&#x3D; 和&#x3D;&#x3D;&#x3D;有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-闭包"><span class="toc-number">1.5.</span> <span class="toc-text">5. 闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-深浅拷贝"><span class="toc-number">1.6.</span> <span class="toc-text">6. 深浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-原型"><span class="toc-number">1.7.</span> <span class="toc-text">7. 原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-var-let-及const区别"><span class="toc-number">1.8.</span> <span class="toc-text">8. var let 及const区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-原型继承和class继承"><span class="toc-number">1.9.</span> <span class="toc-text">9. 原型继承和class继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-实现一个简洁版的promise"><span class="toc-number">1.10.</span> <span class="toc-text">10. 实现一个简洁版的promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Event-Loop"><span class="toc-number">1.11.</span> <span class="toc-text">11. Event Loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-手写-call-apply-及bind函数"><span class="toc-number">1.12.</span> <span class="toc-text">12. 手写 call apply 及bind函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-new"><span class="toc-number">1.13.</span> <span class="toc-text">13. new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-instanceof-的原理"><span class="toc-number">1.14.</span> <span class="toc-text">14. instanceof 的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-事件机制"><span class="toc-number">1.15.</span> <span class="toc-text">15. 事件机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-注册事件"><span class="toc-number">1.16.</span> <span class="toc-text">16. 注册事件</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">无聊才读书-博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/home/"><i class="fa-fw fab fa-phoenix-framework"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">高频考点</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-06-02 23:30:53"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-06-02</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-06-03 02:22:02"><i class="fas fa-history fa-fw"></i> 更新于 2021-06-03</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="高频考点"><a href="#高频考点" class="headerlink" title="高频考点"></a>高频考点</h1><h2 id="1-typeof类型判断"><a href="#1-typeof类型判断" class="headerlink" title="1. typeof类型判断"></a>1. typeof类型判断</h2><blockquote>
<p>typeof 是否能正确判断类型？ instanceof能正确判断对象的原理是什么</p>
</blockquote>
<ul>
<li>type 对于原始类型，除了 <code>null</code>都可以只显示正确的类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">//'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span> <span class="comment">//'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">//'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">//'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">//'symbol'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>typeof 对于对象来说，除了函数都会显示<code>object</code>,所以说<code>typeof</code>并不能准确判断变量到底是什么类型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">//'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">//'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">//'function'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们想判断一个对象的正确类型，这时候可以考虑使用<code>instanceof</code>,因为内部机制是通过原型链来判断的</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1 <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello world'</span></span><br><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1= <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello world'</span>)</span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于原始类型来说，逆向直接通过<code>instanceof</code> 来判断类型是不行的</p>
</blockquote>
<h2 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2.类型转换"></a>2.类型转换</h2><blockquote>
<p>在JS中类型转换只有三种情况，分别是</p>
<ul>
<li>转换为布尔值</li>
<li>转换为数字</li>
<li>转换为字符串</li>
</ul>
</blockquote>
<p>转为Boolean</p>
<blockquote>
<p>在条件判断时，除了 undefined , null ,false ,NaN,’ ‘,0,-0,其他所有值都转为true，包括所有对象</p>
</blockquote>
<p>对象转为原始类型</p>
<blockquote>
<p>对象在转换类型的时候，会调用内置的<code>[[ToPrimitive]]</code>函数，对于该函数来说，算法逻辑一般来说如下</p>
</blockquote>
<ul>
<li>如果已经是原型类型了，那就不需要转换了</li>
<li>调用<code>x.valueOf()</code>如果转换为基础类型，就返回转换的值</li>
<li>调用<code>x.toString()</code>，如果转换为基础类型，就返回转换的值</li>
<li>如果没有返回原型类型，就会报错</li>
</ul>
<blockquote>
<p>当然你也可以重写Symbol.toPrimitive，刚方法在转原始类型时调用优先级最高</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    valueOf()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>+ a <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>四则运算</p>
<blockquote>
<p>它有以下几个特点：</p>
<ul>
<li>运算中其中一方为字符串，那么久会把另一方也转换为字符串</li>
<li>如果一方不是字符串或数字，那么会将它转换为数字或者字符串</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+ <span class="string">'1'</span>  <span class="comment">//'11'</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span> <span class="comment">//2</span></span><br><span class="line"><span class="number">4</span>+ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//"41,2,3"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于第一行代码来说，触发特点一，所以将数字1转换为字符串，得到结果’11‘</li>
<li>对于第二行代码来说，触发特点二，所以将true转为数字1</li>
<li>对于第三行代码来说，触发特点二，所以将数组通过toString转为字符串1,2,3，得到结果41，2,3</li>
</ul>
<p>比较运算符</p>
<ul>
<li>如果是对象，就通过<code>toPrimitive</code>转换为对象</li>
<li>如果是字符串，就通过<code>unicode</code>字符索引来比较</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =&#123;</span><br><span class="line">    valueOf()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a&gt;<span class="number">-1</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在以上代码中，因为a是对象，所以会通过<code>valueOf</code>转换为原始类型再比较值</p>
</blockquote>
<h2 id="3-This"><a href="#3-This" class="headerlink" title="3. This"></a>3. This</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a =<span class="number">1</span></span><br><span class="line">foo()</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Foo()</span><br></pre></td></tr></table></figure>

<ul>
<li>对于直接调用foo 来说，不管foo函数放在什么地方，this一定是window</li>
<li>对于<code>obj.foo()</code>来说，我们只需要记住，谁调用了函数，谁就是<code>this</code>,所以在这个场景下<code>foo</code>函数中的<code>this</code>就是<code>obj</code>对象</li>
<li>对于<code>new</code>的方式来说，<code>this</code>被永远绑定在了<code>c</code>上面 不会被任何方式改变<code>this</code></li>
</ul>
<blockquote>
<p>说完了以上几种情况，其实很多代码中的<code>this</code>应该就没什么问题了，下面让我们看看箭头函数中的<code>this</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)<span class="comment">//window</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()())<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>首先箭头函数其实是没有<code>this</code>的，箭头函数中的<code>this</code>只取决包裹箭头函数的第一个普通函数的<code>this</code>。在这个例子中，因为包裹箭头函数的第一个普通函数是<code>a</code>,所以此时的<code>this</code>是<code>window</code>。另外对箭头函数使用<code>bind</code>这类函数是无效的</li>
<li>最后种情况也就是<code>bind</code>这些改变上下文的<code>API</code>了，对于这些函数来说，<code>this</code>取决于第一个参数，如果第一个参数为空，那么就是<code>window</code></li>
<li>无论我们给函数<code>bind</code>几次，<code>fn</code>中的<code>this</code>永远由第一次<code>bind</code>决定，所以结果永远是<code>window</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;</span><br><span class="line">fn.bind.bind(a)() <span class="comment">//window</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上就是<code>this</code>的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高来决定<code>this</code>最终指向哪里</p>
<p>首先，<code>new</code>的方式优先级最高，接下来是<code>bind</code>这些函数，然后是<code>obj.foo()</code>这种调用方式，最后是<code>foo</code>这种调用方式，同时，箭头函数的<code>this</code>一旦被绑定，就不会再被任何方式所改变</p>
</blockquote>
<h2 id="4-和-有什么区别"><a href="#4-和-有什么区别" class="headerlink" title="4. == 和===有什么区别"></a>4. == 和===有什么区别</h2><blockquote>
<p>对于<code>==</code>来说，如果对比双方的类型不一样的话，就会进行类型转换</p>
</blockquote>
<p>假如我们需要对比x和y是否相同，就会进行如下判断流程</p>
<ol>
<li><p>首先会判断两者类型是否相同，相同的话就是比大小了</p>
</li>
<li><p>类型不相同的话，那么就会进行类型转换</p>
</li>
<li><p>会先判断是否在对比<code>null</code>和<code>undefined</code>,是的话就会返回<code>true</code></p>
</li>
<li><p>判断两者类型是否为<code>string</code>和<code>number</code>，是的话就会将字符串转换为<code>number</code></p>
</li>
<li><p>判断其中一方是否为<code>boolean</code>.是的话就把<code>boolean</code>转为<code>number</code>再进行判断</p>
</li>
<li><p>判断其中一方是否为<code>Object</code>且另一方为<code>string</code>,<code>number</code>或者<code>symbol</code>，是的话就会把<code>object</code>转为原始类型再进行判断</p>
</li>
</ol>
<blockquote>
<p>对于<code>===</code>来说就简单多了，就是判断两者类型和值是否相同</p>
</blockquote>
<h2 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5. 闭包"></a>5. 闭包</h2><blockquote>
<p>闭包的定义其实很简单：函数A内部有一个函数B，函数B可以访问到函数A中的变量，那么函数B就是闭包</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a =<span class="number">1</span></span><br><span class="line">    <span class="built_in">window</span>.B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B() <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>闭包存在的意义就是让我们可以间接访问函数内部的变量</p>
<blockquote>
<p>经典面试题，循环中说那个闭包解决<code>var</code>定义函数的问题</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先因为<code>setTimeout</code>是个异步函数，所以会先把循环占全部执行完毕，这时候i就是6了，所以会输出一堆6</p>
</blockquote>
<p>解决办法有三种</p>
<ol>
<li><p>第一种是使用闭包的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    ;(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j)</span><br><span class="line">        &#125;,j*<span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上述代码汇总，我们首先使用了立即执行函数将<code>i</code>传入函数内部，这时候值就被固定在了参数j上面不会改变，当下次执行<code>timer</code>这个闭包的时候，就可以使用外部函数的变量j,从而达到目的</p>
</blockquote>
</li>
<li><p>第二种就是使用<code>setTimeout</code>的第三个参数，这个参数会被当做<code>timer</code>函数的参数传入</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>第三种就是使用<code>let</code>定义<code>i</code>了来解决问题，这个也是最为推荐的方式</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-深浅拷贝"><a href="#6-深浅拷贝" class="headerlink" title="6. 深浅拷贝"></a>6. 深浅拷贝</h2><p>浅拷贝</p>
<blockquote>
<p>首先可以通过<code>Object.assign</code>来解决这个问题，很多人认为这个函数是用来深拷贝的，其实并不是，<code>Object.assign</code>只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =&#123;</span><br><span class="line">    age:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;,a)</span><br><span class="line">a.age = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外我们还可以通过展开运算符<code>...</code>来实现浅拷贝</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =&#123;</span><br><span class="line">    age:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b =&#123;...a&#125;</span><br><span class="line">a.age =<span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用深拷贝</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =&#123;</span><br><span class="line">    age:<span class="number">1</span>,</span><br><span class="line">    jobs:&#123;</span><br><span class="line">        first: <span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b =&#123;...a&#125;</span><br><span class="line">a.jobs.first =<span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">//native</span></span><br></pre></td></tr></table></figure>

<p>深拷贝</p>
<blockquote>
<p>这个问题通常可以使用<code>JSON.parse(JSON.stringify(object))</code>来解决</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span>,</span><br><span class="line">    jobs:&#123;</span><br><span class="line">        first:<span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">a.jobs.first =<span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">//FE</span></span><br></pre></td></tr></table></figure>

<p>但是这个犯法也是有局限性的</p>
<ul>
<li>会忽略<code>undefined</code></li>
<li>会忽略<code>symbol</code></li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>
<h2 id="7-原型"><a href="#7-原型" class="headerlink" title="7. 原型"></a>7. 原型</h2><blockquote>
<p>原型链就是多个对象通过<code>__proto__</code>的方式连接了起来。为什么<code>obj</code>可以访问到<code>valueof</code>函数，就是因为<code>obj</code>通过原型链找到了<code>valueof</code>函数</p>
</blockquote>
<ul>
<li><p><code>Object</code>是所有对象的爸爸，所有对象都可以通过<code>__proto__</code>找到它</p>
</li>
<li><p><code>Function</code>是所有函数的爸爸，所有函数都可以通过<code>__proto__</code>找到它</p>
</li>
<li><p>函数的<code>prototype</code>是一个对象</p>
</li>
<li><p>对象的<code>__proto__</code>属性指向原型，<code>__proto__</code>将对象和原型连接起来组成了原型链</p>
</li>
</ul>
<h2 id="8-var-let-及const区别"><a href="#8-var-let-及const区别" class="headerlink" title="8. var let 及const区别"></a>8. var let 及const区别</h2><ul>
<li><p>函数提升优先变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</p>
</li>
<li><p><code>var</code>存在提升，我们能在声明之前使用。<code>let</code>，<code>const</code>因为暂时性死区的原因，不能在声明前使用</p>
</li>
<li><p><code>var</code>在全局作用域下声明变量会导致变量挂载在<code>window</code>上，其他两者不会</p>
</li>
<li><p><code>let</code>和<code>const</code>作用基本一致，但是后者声明的变量不能再次赋值</p>
</li>
</ul>
<h2 id="9-原型继承和class继承"><a href="#9-原型继承和class继承" class="headerlink" title="9. 原型继承和class继承"></a>9. 原型继承和class继承</h2><p>首先先来讲下class，其实在JS中并不存在类，class只是语法糖，本质还是函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line">Person <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>组合继承</p>
<blockquote>
<p>组合继承是最常用的继承方式</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val  =value</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype =<span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue()<span class="comment">//1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>以上继承的方式核心是在子类的构造函数中通过<code>Parent.call(this)</code>继承父类的属性，然后改变子类的原型为<code>new Parent()</code>来继承父类的函数</li>
<li>这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费</li>
</ul>
<p>寄生组合继承</p>
<blockquote>
<p>这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.val = value   </span><br><span class="line">&#125; </span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>,value)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype,&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:&#123;</span><br><span class="line">        value:Child,</span><br><span class="line">        enumerable:<span class="literal">false</span>,</span><br><span class="line">        writable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue() <span class="comment">//1</span></span><br><span class="line">child.instanceof Parent <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上继承实现的核心就是将父类的原型赋值给了子类，并将构造函数设置为子类，这样即解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p>
</blockquote>
<p>class继承</p>
<blockquote>
<p>以上两种继承方式都是通过原型去解决的，在ES6中，我们可以使用class去实现继承，并且实现起来很简单</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = value</span><br><span class="line">    &#125;</span><br><span class="line">    getValue()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    constrcutor(value)&#123;</span><br><span class="line">        <span class="keyword">super</span>(value)</span><br><span class="line">        <span class="keyword">this</span>.val = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue()<span class="comment">//1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>class 实现继承的核心在于使用<code>extends</code>表明继承自那个父类，并且在子类构造函数中必须嗲偶偶那个<code>super</code>，因为这段代码可以看成<code>Parent.call(this,value)</code></p>
</blockquote>
<h2 id="10-实现一个简洁版的promise"><a href="#10-实现一个简洁版的promise" class="headerlink" title="10. 实现一个简洁版的promise"></a>10. 实现一个简洁版的promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个常量用于表示状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING =<span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that =<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.state = PENDING</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//value 变量用于保存resolve或者reject中传入的值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于保存then中的回调，因为当执行完Promise时状态可能还是等待中，这时候应该把状态存储下来</span></span><br><span class="line">    that.resolvedCallbacks =[]</span><br><span class="line">    that.rejectedCallbacks =[]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//首先两个函数都得判断当前状态是否为等待中</span></span><br><span class="line">        <span class="keyword">if</span>(that.state ===PENDING)&#123;</span><br><span class="line">            that.state =RESOLVED</span><br><span class="line">            that.value = value</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//遍历回调数组并执行</span></span><br><span class="line">            that.resolvedCallbacks.map(<span class="function"><span class="params">cb</span>=&gt;</span>cb(that.value))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(that.state ===PENDING)&#123;</span><br><span class="line">            that.state = REJECTED</span><br><span class="line">            that.value = value</span><br><span class="line">            that.rejectedCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span>cb(that.value))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成以上两个函数以后，我们就该实现如何执行Promise中传入的函数了</span></span><br><span class="line">    <span class="keyword">try</span>()&#123;</span><br><span class="line">        fn(resolve,reject)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后我们来实现较为复杂的then函数</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFullfilled,onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that =<span class="keyword">this</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//判断两个参数是否为函数类型，因为这两个参数是可选参数</span></span><br><span class="line">    onFullfilled = <span class="keyword">typeof</span> onFullfilled === <span class="string">'function'</span> ? onFullfilled: <span class="function"><span class="params">v</span>=&gt;</span>v</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected: <span class="keyword">throw</span> e </span><br><span class="line">   <span class="comment">//当状态不是等待时，就去执行响应的函数。如果状态是等待态的话，就往回调函数中push</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.state === PENDING)&#123;</span><br><span class="line">        <span class="keyword">this</span>.resolvedCallbacks.push(onFullfilled)</span><br><span class="line">        <span class="keyword">this</span>.rejectedCallbacks.push(onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.state === RESOLVED)&#123;</span><br><span class="line">         onFullfilled(that.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.state === REJECTED)&#123;</span><br><span class="line">        onRejected(that.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-Event-Loop"><a href="#11-Event-Loop" class="headerlink" title="11. Event Loop"></a>11. Event Loop</h2><p>进程与线程</p>
<ul>
<li>JS是单线程执行的</li>
<li>进程描述了CPU在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小的单位，描述了执行一段指令所需要的时间</li>
</ul>
<blockquote>
<p>把这些概念拿到浏览器中国来说，当你打开一个Tab页时，其实就是创建了一个进程，一个进程中可以有很多个线程，比如渲染线程，JS引擎线程，HTTP请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁</p>
</blockquote>
<ul>
<li>上文说到了JS引擎线程和渲染线程，大家应该都知道，在JS运行的时候可能会阻止UI渲染，这说明了两个线程是互斥的，这其中的原因是因为JS可以修改DOM，如果在JS执行的时候UI线程还在工作，就可能导致不能安全的渲染UI。这其实也是单线程的好处，得益于JS是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处</li>
</ul>
<p>执行栈</p>
<p>可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</p>
<blockquote>
<p>当开始执行JS代码时，首先会执行一个<code>main</code>函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，foo函数后执行，当执行完毕后就从栈中弹出了</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>

<p>浏览器中的Event loop</p>
<blockquote>
<p>JS是门非阻塞单线程语言，因为在最初JS就是为了和浏览器交互诞生的。如果JS是门多线程语言话，我们在多个线程中处理DOM就可能发生问题</p>
</blockquote>
<ul>
<li>JS在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，就被挂起并加入到<code>Task</code>队列中。一旦执行栈为空，<code>Event Loop</code>就会从Task队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说JS中的异步还是同步行为</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>) <span class="comment">//先后顺序为 script start  script end setTimeout</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不同的任务源会被分配到不同的Task队列中，任务源可以分为微任务和宏任务。</p>
<p>微任务 </p>
<ul>
<li>process.nextTick</li>
<li>promise</li>
<li>Object.observe</li>
</ul>
<p>宏任务</p>
<ul>
<li>script</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>I/O</li>
<li>UI rendering</li>
<li>setTimeout</li>
</ul>
</blockquote>
<p>所以正确的一次Event Loop 顺序是这样的</p>
<ul>
<li>执行同步代码，这属于宏任务</li>
<li>执行栈为空，查询是否有微任务需要执行</li>
<li>执行所有的微任务</li>
<li>必要的话渲染UI</li>
<li>然后开始下一轮 Event loop ，执行宏任务中的异步代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;，<span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="12-手写-call-apply-及bind函数"><a href="#12-手写-call-apply-及bind函数" class="headerlink" title="12. 手写 call apply 及bind函数"></a>12. 手写 call apply 及bind函数</h2><ul>
<li>不传入第一个参数，那么上下文默认为<code>window</code></li>
<li>改变了this指向，让新的对象可以执行该函数，并能接收参数</li>
</ul>
<p>实现call</p>
<ul>
<li><p>首先<code>context</code>为可选参数，如果不传的话，默认上下文为<code>window</code></p>
</li>
<li><p>接下来给<code>context</code>创建一个<code>fn</code>属性，并将值设置为需要调用的函数</p>
</li>
<li><p>因为<code>call</code>可以传入多个参数作为调用的参数，所有需要将参数剥离出来</p>
</li>
<li><p>然后调用函数并将对象上的函数删除</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        thorw <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    context = context || <span class="built_in">window</span></span><br><span class="line">    context.fn = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> result = context.fn(...args)</span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>apply的实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  context = context || <span class="built_in">window</span> </span><br><span class="line">  context.fn = <span class="keyword">this</span> </span><br><span class="line">  <span class="keyword">let</span> result </span><br><span class="line">  <span class="comment">// 处理参数和 call 有区别 </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123; </span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]) </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    result = context.fn() </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">delete</span> context.fn </span><br><span class="line">  <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind的实现</p>
<ul>
<li>bind  返回了⼀个函数，对于函数来说有两种⽅式调⽤，⼀种是直接调⽤，⼀种是通过new  的⽅式，我们先来说直接调⽤的⽅式</li>
<li>对于直接调⽤来说，这⾥选择了 apply  的⽅式实现，但是对于参数需要注意以下情况：<br>因为 bind  可以实现类似这样的代码 f.bind(obj, 1)(2) ，所以我们需要将两边的参<br>数拼接起来，于是就有了这样的实现 args.concat(…arguments)</li>
<li>最后来说通过 new  的⽅式，在之前的章节中我们学习过如何判断 this ，对于 new  的情况来说，不会被任何⽅式改变 this ，所以对于这种情况我们需要忽略传⼊的 this</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> _this =<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//因为返回了一个函数，我们可以new F()，所以需要判断</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> F)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(..args, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context,args.concat(...arguments))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-new"><a href="#13-new" class="headerlink" title="13. new"></a>13. new</h2><p>在调用new的过程中发生四件事情</p>
<ul>
<li>新生成了一个对象</li>
<li>连接到原型</li>
<li>绑定 <code>this</code></li>
<li>返回新对象</li>
</ul>
<h2 id="14-instanceof-的原理"><a href="#14-instanceof-的原理" class="headerlink" title="14. instanceof 的原理"></a>14. instanceof 的原理</h2><p><code>instanceof</code>可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的<code>prototype</code></p>
<p>实现以下<code>instanceof</code></p>
<ul>
<li>首先获取类型的原型</li>
<li>然后获得对象的原型</li>
<li>然后一直循环判断对象的原型是否等于类型的原型，知道对象原型为<code>null</code>，因为原型链最终为<code>null</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">    left = left.__proto__</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left === <span class="literal">null</span> || left === <span class="literal">undefined</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prototype === left)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            left = left.__proto__</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-事件机制"><a href="#15-事件机制" class="headerlink" title="15. 事件机制"></a>15. 事件机制</h2><p>事件触发有三个阶段</p>
<ul>
<li><p><code>window</code>往事件触发处传播，遇到注册的捕获事件会触发</p>
</li>
<li><p>传播到事件触发处触发注册的事件</p>
</li>
<li><p>从事件触发处往<code>window</code>传播，遇到注册的冒泡事件会触发</p>
</li>
</ul>
<h2 id="16-注册事件"><a href="#16-注册事件" class="headerlink" title="16. 注册事件"></a>16. 注册事件</h2><blockquote>
<p>通常我们使用<code>addEventListener</code>注册事件，该函数的三个参数可以是布尔值，也可以是对象。对于布尔值<code>useCapture</code>参数来说，该参数默认值为false，<code>userCapture</code>决定了注册的事件是捕获事件还是冒泡事件。 该参数默认值为false</p>
<ul>
<li>capture： 布尔值，和<code>useCapture</code>作用一样</li>
<li>once: 布尔值，值为<code>true</code>表示该回调只会回调一次，调用后会移除监听</li>
<li>passive： 布尔值，表示永远不会调用<code>preventDefault</code></li>
</ul>
</blockquote>
<blockquote>
<p>一般来说，如果我们只希望事件只触发在目标上，这时候可以使用</p>
<p>stopPropagation来阻止事件的进一步传播，筒仓我们任务<code>stopPropagation</code>是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。</p>
</blockquote>
<p>事件代理</p>
<blockquote>
<p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelected(<span class="string">'#ul'</span>)</span></span><br><span class="line"><span class="actionscript">    ul.addEventListener(<span class="string">'click'</span>,(event)=&gt;&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.target)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>事件代理的方式相较于直接给目标注册事件来说，有以下优点</p>
<ul>
<li>节省内存</li>
<li>不需要给子节点注销事件</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">刘如刚</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.liurugang.cn/posts/63672/">http://blog.liurugang.cn/posts/63672/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.liurugang.cn" target="_blank">无聊才读书-博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%80%BB%E7%BB%93/">总结</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/25536/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前端面试题-续</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/520520/" title="CSS面试"><img class="relatedPosts_cover" data-src="https://cdn.jsdelivr.net/gh/HCLonely/hclonely.github.io/img/Butterfly/006.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-31</div><div class="relatedPosts_title">CSS面试</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 刘如刚</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><meta name="generator" content="Hexo 4.2.1"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":120,"height":260},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>