<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Vue面试题 | 无聊才读书-博客</title><meta name="description" content="Vue面试题1. 说说你对SPA单页面的理解，它的优缺点分别是什么？SPA仅在Web页面初始化时加载相应的HTML，JavaScript和CSS。一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现HTML内容的变化，UI与用户的交互，避免页面的重新加载 优点：  用户体验好，快，内容的改变不需要重新加载整个页面，避免可不必要的跳转和重复渲染 SPA对"><meta name="keywords" content="Vue,面试,ES6,webpack,node,前端"><meta name="author" content="刘如刚"><meta name="copyright" content="刘如刚"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.liurugang.cn/posts/719/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="Vue面试题"><meta property="og:url" content="http://blog.liurugang.cn/posts/719/"><meta property="og:site_name" content="无聊才读书-博客"><meta property="og:description" content="Vue面试题1. 说说你对SPA单页面的理解，它的优缺点分别是什么？SPA仅在Web页面初始化时加载相应的HTML，JavaScript和CSS。一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现HTML内容的变化，UI与用户的交互，避免页面的重新加载 优点：  用户体验好，快，内容的改变不需要重新加载整个页面，避免可不必要的跳转和重复渲染 SPA对"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2021-01-29T15:57:13.708Z"><meta property="article:modified_time" content="2021-01-29T16:32:01.055Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="Nuxt.js介绍" href="http://blog.liurugang.cn/posts/60077/"><link rel="next" title="git" href="http://blog.liurugang.cn/posts/43167/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-01-30 00:32:01'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/Chocolate1999/cdn/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">25</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/home/"><i class="fa-fw fab fa-phoenix-framework"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue面试题"><span class="toc-number">1.</span> <span class="toc-text">Vue面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-说说你对SPA单页面的理解，它的优缺点分别是什么？"><span class="toc-number">1.1.</span> <span class="toc-text">1. 说说你对SPA单页面的理解，它的优缺点分别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-v-show-和v-if有什么区别"><span class="toc-number">1.2.</span> <span class="toc-text">2. v-show 和v-if有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-class与style如何动态绑定"><span class="toc-number">1.3.</span> <span class="toc-text">3.class与style如何动态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-怎样理解Vue的单向数据流"><span class="toc-number">1.4.</span> <span class="toc-text">4. 怎样理解Vue的单向数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-computed和watch的区别和运用场景"><span class="toc-number">1.5.</span> <span class="toc-text">5. computed和watch的区别和运用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-直接给一个数组项赋值，Vue能检测到变化吗？"><span class="toc-number">1.6.</span> <span class="toc-text">6. 直接给一个数组项赋值，Vue能检测到变化吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-谈谈你对Vue生命周期的理解"><span class="toc-number">1.7.</span> <span class="toc-text">7. 谈谈你对Vue生命周期的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Vue的父组件和子组件生命周期钩子函数执行顺序"><span class="toc-number">1.8.</span> <span class="toc-text">8. Vue的父组件和子组件生命周期钩子函数执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-在哪个生命周期内调用异步请求？"><span class="toc-number">1.9.</span> <span class="toc-text">9. 在哪个生命周期内调用异步请求？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-在什么阶段才能访问操作DOM"><span class="toc-number">1.10.</span> <span class="toc-text">10. 在什么阶段才能访问操作DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-父组件可以监听到子组件的生命周期吗？"><span class="toc-number">1.11.</span> <span class="toc-text">11. 父组件可以监听到子组件的生命周期吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-谈谈你对keep-alive的了解？"><span class="toc-number">1.12.</span> <span class="toc-text">12. 谈谈你对keep-alive的了解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-组件中data为什么是一个函数"><span class="toc-number">1.13.</span> <span class="toc-text">13.组件中data为什么是一个函数?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-v-model原理"><span class="toc-number">1.14.</span> <span class="toc-text">14. v-model原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Vue组件间通信有哪几种方式"><span class="toc-number">1.15.</span> <span class="toc-text">15. Vue组件间通信有哪几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-使用过Vue-SSR吗？-说说SSR？"><span class="toc-number">1.16.</span> <span class="toc-text">17. 使用过Vue SSR吗？ 说说SSR？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-能说一下vue-router中常用的hash和history路由模式实现原理吗？"><span class="toc-number">1.17.</span> <span class="toc-text">18. 能说一下vue-router中常用的hash和history路由模式实现原理吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-什么是MVVM"><span class="toc-number">1.18.</span> <span class="toc-text">19. 什么是MVVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Vue是如何实现数据双向绑定的？"><span class="toc-number">1.19.</span> <span class="toc-text">20. Vue是如何实现数据双向绑定的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Vue框架怎么实现对象和数据的监听？"><span class="toc-number">1.20.</span> <span class="toc-text">21. Vue框架怎么实现对象和数据的监听？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-proxy与Object-defineProperty优劣对比"><span class="toc-number">1.21.</span> <span class="toc-text">22. proxy与Object.defineProperty优劣对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Vue怎么用vm-set-解决对象新增属性不能响应的问题？"><span class="toc-number">1.22.</span> <span class="toc-text">23.Vue怎么用vm.$set()解决对象新增属性不能响应的问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-虚拟DOM的优缺点"><span class="toc-number">1.23.</span> <span class="toc-text">24. 虚拟DOM的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-虚拟DOM实现原理"><span class="toc-number">1.24.</span> <span class="toc-text">25. 虚拟DOM实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Vue中的key有什么用"><span class="toc-number">1.25.</span> <span class="toc-text">26. Vue中的key有什么用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-对Vue项目进行哪些优化？"><span class="toc-number">1.26.</span> <span class="toc-text">27. 对Vue项目进行哪些优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-对于vue3-0特性你有什么了解"><span class="toc-number">1.27.</span> <span class="toc-text">28. 对于vue3.0特性你有什么了解</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">无聊才读书-博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/home/"><i class="fa-fw fab fa-phoenix-framework"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Vue面试题</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-01-29 23:57:13"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-01-29</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-01-30 00:32:01"><i class="fas fa-history fa-fw"></i> 更新于 2021-01-30</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Vue面试题"><a href="#Vue面试题" class="headerlink" title="Vue面试题"></a>Vue面试题</h1><h2 id="1-说说你对SPA单页面的理解，它的优缺点分别是什么？"><a href="#1-说说你对SPA单页面的理解，它的优缺点分别是什么？" class="headerlink" title="1. 说说你对SPA单页面的理解，它的优缺点分别是什么？"></a>1. 说说你对SPA单页面的理解，它的优缺点分别是什么？</h2><p>SPA仅在Web页面初始化时加载相应的HTML，JavaScript和CSS。一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现HTML内容的变化，UI与用户的交互，避免页面的重新加载</p>
<p>优点：</p>
<ul>
<li>用户体验好，快，内容的改变不需要重新加载整个页面，避免可不必要的跳转和重复渲染</li>
<li>SPA对服务器压力小</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理</li>
</ul>
<p>缺点：</p>
<ul>
<li>初次加载耗时多；为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript，css统一加载，部分页面按需加载</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理</li>
<li>SEO难度大；由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势</li>
</ul>
<h2 id="2-v-show-和v-if有什么区别"><a href="#2-v-show-和v-if有什么区别" class="headerlink" title="2. v-show 和v-if有什么区别"></a>2. v-show 和v-if有什么区别</h2><p><code>v-if</code>是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；如果在初始化渲染时条件为假，则什么都不做——-知道条件第一次变为真时，才会开始渲染条件块。</p>
<p><code>v-show</code>就简单得多—–不管初始化条件是什么，元素总是会被渲染，并且只是简单地基于CSS的“display”属性进行切换</p>
<p>所以，<code>v-if</code>适用于运行时很少改变条件，不需要频繁切换条件的场景；v-show则适用于需要非常频繁切换条件的场景</p>
<h2 id="3-class与style如何动态绑定"><a href="#3-class与style如何动态绑定" class="headerlink" title="3.class与style如何动态绑定"></a>3.class与style如何动态绑定</h2><p>class可以通过对象语法和数组语法进行动态绑定：</p>
<ul>
<li>对象语法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind：class&#x3D;”&#123;active:isActive,&#39;text-danger&#39;:hasError&#125;“&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">data:&#123;</span><br><span class="line">   isActive:true,</span><br><span class="line">   hasError:false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数组语法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class&#x3D;&quot;[isActive?activeClass:&#39;&#39;,errorClass]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">data:&#123;</span><br><span class="line">    activeClass:&#39;active&#39;,</span><br><span class="line">    errorClass:&#39;text-danger&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>style也可以通过语法和数组语法进行动态绑定</p>
<ul>
<li>对象语法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style&#x3D;&quot;&#123;color:activeColor,fontSize:fontSize+&#39;px&#39;&#125;&quot;&gt;</span><br><span class="line">    </span><br><span class="line">data:&#123;</span><br><span class="line">  activeColor:&#39;red&#39;,</span><br><span class="line">    fontSize:30</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数组语法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind&#x3D;&quot;[styleColor,styleSize]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">data:&#123;</span><br><span class="line">   styleColor:&#123;</span><br><span class="line">     color:&#39;red&#39;</span><br><span class="line">   &#125;,</span><br><span class="line">   styleSize:&#123;</span><br><span class="line">    fontSize:&#39;23px&#39; </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-怎样理解Vue的单向数据流"><a href="#4-怎样理解Vue的单向数据流" class="headerlink" title="4. 怎样理解Vue的单向数据流"></a>4. 怎样理解Vue的单向数据流</h2><p>所有的prop都使得其父子prop之间形成了一个单向下行绑定：父级prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>每次父级组件发生更新时，子组件中所有的prop都会刷新为最新的值，这意味着你不应该在一个子组件内部改变prop。如果你这样做了，Vue会在浏览器的控制台中发生警告。子组件想修改时，只能通过$emit派发一个自定义事件，父组件接收到后，有父组件修改。</p>
<p>有两种常见的视图改变一个prop的情景</p>
<ul>
<li>这个prop用来传递一个初始值；这个子组件接下来希望将作为一个本地饿的prop数据来使用。在这种情况下，最好定义一个本地的data属性，并将这个prop用作其初始化值：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">props:[<span class="string">'initialCounter'</span>],</span><br><span class="line">data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     counter: <span class="keyword">this</span>.initialCounter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个prop以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个prop的值来定义一个计算属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prop:[<span class="string">'size'</span>],</span><br><span class="line">computed:&#123;</span><br><span class="line">    normalizedSize:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-computed和watch的区别和运用场景"><a href="#5-computed和watch的区别和运用场景" class="headerlink" title="5. computed和watch的区别和运用场景"></a>5. computed和watch的区别和运用场景</h2><p><code>computed</code>：是计算属性，依赖其他属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值</p>
<p><code>watch</code>:更多的是观察的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作：</p>
<p>运用场景：</p>
<ul>
<li>当我们需要进行数值计算，并且依赖于其他数据时，应该使用computed，因为可以利用computed的缓存特性，避免每次获取值时，都要重新计算；</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，这些都是计算属性无法做到的</li>
</ul>
<h2 id="6-直接给一个数组项赋值，Vue能检测到变化吗？"><a href="#6-直接给一个数组项赋值，Vue能检测到变化吗？" class="headerlink" title="6. 直接给一个数组项赋值，Vue能检测到变化吗？"></a>6. 直接给一个数组项赋值，Vue能检测到变化吗？</h2><p>由于JavaScript的限制，Vue不能检测到一下数组的变动：</p>
<ul>
<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem]=newValue</code></li>
<li>当你修改数组的长度时，例如:<code>vm.items.length=newLength</code></li>
</ul>
<p>为了解决第一个问题，Vue提供了以下操作方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.items,indexOfItem,newValue)</span><br><span class="line"></span><br><span class="line">Vue.$<span class="keyword">set</span>(vm.items,indexOfItem,newValue)</span><br><span class="line"></span><br><span class="line">vm.items.splice(indexOfItem,newValue)</span><br></pre></td></tr></table></figure>

<p>为了解决第二个问题，Vue提供了以下操作方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>

<h2 id="7-谈谈你对Vue生命周期的理解"><a href="#7-谈谈你对Vue生命周期的理解" class="headerlink" title="7. 谈谈你对Vue生命周期的理解"></a>7. 谈谈你对Vue生命周期的理解</h2><ol>
<li>生命周期</li>
</ol>
<p>Vue实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模板，挂载DOM，渲染，更新 —&gt;渲染，卸载等一系列过程，我们称这是Vue的生命周期。</p>
<ol start="2">
<li>各个生命周期的作用</li>
</ol>
<p>beforeCreate     组件实例被创建之初，组件的属性生效之前</p>
<p>created        组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用</p>
<p>beforeMount         在挂载开始之前被调用；相关的render函数首次被调用</p>
<p>mounted         el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子</p>
<p>beforeUpdate 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前   </p>
<p>update 组件数据更新之后   activited keep-alive 专属，组件被激活时调用   </p>
<p>deactivated keep-alive 专属，组件被销毁时调用   </p>
<p>beforeDestory 组件销毁前调用  </p>
<p> destoryed 组件销毁后调用</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2019/8/19/16ca74f183827f46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="1.png"></p>
<h2 id="8-Vue的父组件和子组件生命周期钩子函数执行顺序"><a href="#8-Vue的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="8. Vue的父组件和子组件生命周期钩子函数执行顺序"></a>8. Vue的父组件和子组件生命周期钩子函数执行顺序</h2><p>Vue的父组件和子组件生命周期钩子函数执行顺序可以归为4个部分</p>
<ul>
<li><p>加载渲染过程</p>
<p>父beforeCreate –&gt;父created –&gt;父beforeMount -&gt;子beforeCreate –&gt;子 created —&gt;子beforeMount –&gt;子mounted –&gt;父 mounted</p>
</li>
<li><p>子组件更新过程</p>
</li>
</ul>
<p>​        父beforeUpdate  –&gt; 子beforeUpdate –&gt;子updated —&gt;父updated</p>
<ul>
<li>销毁过程</li>
</ul>
<p>​      父beforeDestory —&gt;子beforeDestory —&gt;子destoryed –&gt;父destoryed</p>
<h2 id="9-在哪个生命周期内调用异步请求？"><a href="#9-在哪个生命周期内调用异步请求？" class="headerlink" title="9. 在哪个生命周期内调用异步请求？"></a>9. 在哪个生命周期内调用异步请求？</h2><p>可以在钩子函数created，beforeMounted，mounted中进行调用，因为这三个钩子中data已经被创建，可以将服务端返回的数据进行赋值，但是本人推荐在created钩子中调用异步请求，因为在created钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面loading时间</li>
<li>ssr不支持beforeMount，mounted钩子函数，所以放在created有助于一致性</li>
</ul>
<h2 id="10-在什么阶段才能访问操作DOM"><a href="#10-在什么阶段才能访问操作DOM" class="headerlink" title="10. 在什么阶段才能访问操作DOM"></a>10. 在什么阶段才能访问操作DOM</h2><p>在钩子函数mounted被调用前，Vue已经将编译好的模板挂载到页面上，所以在mounted中可以访问操作DOM。Vue具体的生命周期可以参考下图</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2019/8/19/16ca74f183827f46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="1.png"></p>
<h2 id="11-父组件可以监听到子组件的生命周期吗？"><a href="#11-父组件可以监听到子组件的生命周期吗？" class="headerlink" title="11. 父组件可以监听到子组件的生命周期吗？"></a>11. 父组件可以监听到子组件的生命周期吗？</h2><p>比如有父组件Parent和子组件Child，如过父组件监听到子组件挂载<code>mounted</code>就做一些逻辑处理，可以通过以下写法实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parent.vue</span></span><br><span class="line">&lt;child @mounted=<span class="string">"dosomething"</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//child vue</span></span><br><span class="line">mounted()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">"mounted"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上需要手动通过<code>$emit</code>触发父组件的事件，更简单的方式可以在父组件引用子组件时通过<code>@hook</code>来监听即可，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;parent.vue</span><br><span class="line">&lt;Child @hook:mounted&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line"></span><br><span class="line">doSomething()&#123;</span><br><span class="line">    console.log(&#39;父组件监听mounted钩子函数...&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;child.vue</span><br><span class="line">mounted()&#123;</span><br><span class="line">   console.log(&#96;子组件触发mounted钩子函数...&#96;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然<code>@hook</code>方法不仅仅可以监听的是mounted，其他的生命周期事件，例如：created,updated等都可以监听</p>
<h2 id="12-谈谈你对keep-alive的了解？"><a href="#12-谈谈你对keep-alive的了解？" class="headerlink" title="12. 谈谈你对keep-alive的了解？"></a>12. 谈谈你对keep-alive的了解？</h2><p>keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，避免重新渲染，器有以下特性：</p>
<ul>
<li>一般结合路由和动态组件一起使用，用于缓存组件；</li>
<li>提供<code>include</code>和<code>exclude</code>属性，两者都支持字符串或正则表达式，include表示只有名称匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会被缓存，其中exclude的优先级比include高</li>
<li>对应两个钩子函数actived和deactived，当组件被激活时，触发钩子函数activated，当组件被移除时，触发钩子函数和deactived</li>
</ul>
<h2 id="13-组件中data为什么是一个函数"><a href="#13-组件中data为什么是一个函数" class="headerlink" title="13.组件中data为什么是一个函数?"></a>13.组件中data为什么是一个函数?</h2><blockquote>
<p>为什么组件中的data必须是一个函数，然而return一个对象，而new Vue实例里，data可以直接是一个对象？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//data</span></span><br><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        message:<span class="string">'子组件'</span>,</span><br><span class="line">        childName:<span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//new Vue</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    router,</span><br><span class="line">    tempate:<span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">    components:&#123;App&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因为组件是用来复用的，而JS里对象是引用关系，如果组件中data是一个对象，那么这样作用域没有隔离，子组件中的data属性值会相互影响，如果组件中data选项时一个函数，那么每个实例可以维护一个被返回对象的独立拷贝，组件实例之间的data属性不会相互影响；而new Vue的实例，是不会被复用的，因此不存在引用对象的问题</p>
<h2 id="14-v-model原理"><a href="#14-v-model原理" class="headerlink" title="14. v-model原理"></a>14. v-model原理</h2><p>我们在vue项目中主要使用<code>v-model</code>指令在表单input，textarea，select等元素上，创建双向数据绑定，我们知道 <code>v-model</code>本质上不过是语法糖，<code>v-model</code>在内部为不同的输入元素使用不同的属性并跑出不同的事件：</p>
<ul>
<li>text和textarea元素使用value属性和input事件</li>
<li>checkbox和radio使用checked和change事件</li>
<li>select字段将value作为prop将change作为事件</li>
</ul>
<p>以input表单元素为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model&#x3D;&quot;something&quot;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;相当于</span><br><span class="line">&lt;input v-bind&#x3D;&quot;something&quot; v-on:input&#x3D;&quot;something&#x3D;$event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>如果在自定义事件中。v-model 默认会利用名为value的prop和名为input的事件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">父组件</span><br><span class="line">&lt;ModelChild v-model&#x3D;&quot;message&quot;&gt;&lt;&#x2F;ModelChild&gt;</span><br><span class="line"></span><br><span class="line">子组件</span><br><span class="line">&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">props:&#123;</span><br><span class="line">   value:String</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">  test1()&#123;</span><br><span class="line">   this.$emit(&#39;input&#39;,&#39;小红&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-Vue组件间通信有哪几种方式"><a href="#15-Vue组件间通信有哪几种方式" class="headerlink" title="15. Vue组件间通信有哪几种方式"></a>15. Vue组件间通信有哪几种方式</h2><p>Vue组件间的通信是面试常考的知识点之一，Vue组件间通信主要是以下3类通信；父子组件通信，隔代组件通信，兄弟组件通信</p>
<p>(1) <code>props/$emit</code>使用父子组件通信</p>
<p>这种方法是Vue组件的基础</p>
<p>（2）<code>ref</code>与<code>$parent/$children</code>适用于父子组件通信</p>
<ul>
<li><code>ref</code>:如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果在子组件上，引用就是指向组件实例</li>
<li><code>$parent/$children</code>：访问父/子实例</li>
</ul>
<p>（3） <code>EventBus($emit、$on)</code>适用于父子，隔代，兄弟组件通信</p>
<p>这种方法通过一个空的Vue实例作为中央事件总线(事件中心)，用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子，隔代，兄弟组件</p>
<p>(4) <code>$attrs/$listeners</code>使用隔代组件通信</p>
<ul>
<li><code>$attrs</code>：包含了父租用与中不被prop所识别的特性绑定。当一个组件没有声明任何prop时，这里会包含所有副作用的绑定，并且可以通过<code>v-bind:$attrs</code>传入内部组件，通常配合inheritAttrs渲染一起使用</li>
<li><code>$listeners</code>:包含了父作用域中的<code>v-on</code>事件监听器，它可以通过<code>v-on=&quot;$listeners&quot;</code>传入内部组件</li>
</ul>
<p>(5) Vuex使用于父子，隔代，兄弟组件通信</p>
<p>Vuex是一个专为Vue.js应用程序开发的状态管理模式。每个Vuex应用的核心就是store（仓库）。“store”基本上就是一个容器，它包含着你的应用大部分的状态(state)</p>
<ul>
<li>Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应的高效更新</li>
<li>改变store中的状态的唯一途径就是显式地提交<code>mutation</code>这样使得我们可以方便地跟踪每一个状态的变化</li>
</ul>
<h2 id="17-使用过Vue-SSR吗？-说说SSR？"><a href="#17-使用过Vue-SSR吗？-说说SSR？" class="headerlink" title="17. 使用过Vue SSR吗？ 说说SSR？"></a>17. 使用过Vue SSR吗？ 说说SSR？</h2><blockquote>
<p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p>
<p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>
</blockquote>
<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>
<p><strong>（1）服务端渲染的优点：</strong></p>
<ul>
<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>
<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li>
</ul>
<p><strong>（2) 服务端渲染的缺点：</strong></p>
<ul>
<li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>
<h2 id="18-能说一下vue-router中常用的hash和history路由模式实现原理吗？"><a href="#18-能说一下vue-router中常用的hash和history路由模式实现原理吗？" class="headerlink" title="18. 能说一下vue-router中常用的hash和history路由模式实现原理吗？"></a>18. 能说一下vue-router中常用的hash和history路由模式实现原理吗？</h2><p>(1) hash模式的实现原理</p>
<p>早期的前端路由的实现就是基于<code>location.hash</code>来实现的。其实现原理很简单，<code>location.hash</code>的值就是URL中#后面的内容。比如下面这个网站，它的<code>lcoation.hash</code>的值为<code>#search</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.word.com#search</span></span><br></pre></td></tr></table></figure>

<p>hash路由模式的实现主要基于下面几个特性：</p>
<ul>
<li>URL中hash值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash部分不会被发送</li>
<li>hash值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退，前景按钮控制hash的切换</li>
<li>可以通过a标签，并设置href属性，当用户点击这个标签后。URL的hash值会发生改变；或者使用JavaScript来对<code>location.hash</code>惊醒赋值，改变URL的hash值；</li>
<li>我们可以使用hashchange事件来监听hash值的变化，从而对页面进行跳转</li>
</ul>
<p>（2）history模式的实现原理</p>
<p>HTML5提供了historyAPI来实现URL的变化，其中做最主要的API有以下两个：<code>history.pushState()</code>和<code>history.replaceState()</code>这两个API在不进行刷新的情况下，浏览器的历史记录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>,<span class="literal">null</span>,path)</span><br><span class="line"><span class="built_in">window</span>.history.replaceState(<span class="literal">null</span>,<span class="literal">null</span>,path)</span><br></pre></td></tr></table></figure>

<p>history路由模式的实现主要基于存在下面几个特性：</p>
<ul>
<li>pushState和replaceState两个API来操作实现URL的变化</li>
<li>我们可以使用popState事件来监听url的变化，从而对页面进行跳转</li>
<li>history.pushState()和history,replaceState()不会触发popState事件，这是我们需要手动触发页面跳转</li>
</ul>
<h2 id="19-什么是MVVM"><a href="#19-什么是MVVM" class="headerlink" title="19. 什么是MVVM"></a>19. 什么是MVVM</h2><p>MVVM源自经典的Model-View-Controller（MVC）模式，MVVM的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM的核心是VIewModel层，它就像是一个中转站，负责Model中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与Model层接口进行数据交互，起承上启下作用如下图所示：</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2019/8/19/16ca75871ec53fba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="1.png"></p>
<p>(1)View层</p>
<p>View是视图层，也就是用户界面。前端主要由HTML和CSS来构建</p>
<p>(2)Model层</p>
<p>Model是指数据模型，泛指后端进行的业务逻辑处理和数据控制，对于前端来说就是祸端提供的APi接口</p>
<p>（3）ViewModel层</p>
<p>ViewModel是由前端开发人员组织生成和维护的视图数据层，在这一层，前端开发者对从后端获取的Model数据进行转换处理，做二次封装，以生成符合View层使用预期的视图数据模型。</p>
<p>通过一个Vue实例来说明MVVM的具体实现</p>
<p>(1) VIew层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;showMessage()&quot;&gt;</span><br><span class="line">        click me</span><br><span class="line">    &lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>(2) ViewModel层</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app =<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">      message:<span class="string">'Hello Vue'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">     showMessage()&#123;</span><br><span class="line">        <span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line">        alert(vm.message)   </span><br><span class="line">     &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">       <span class="keyword">let</span> vm =<span class="keyword">this</span>;</span><br><span class="line">      ajax(&#123;</span><br><span class="line">          url:<span class="string">'/your/server/data/api'</span>,</span><br><span class="line">          success(res)&#123;</span><br><span class="line">              vm.message= res;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)  </span><br><span class="line">   &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>（3） Model层</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"url"</span>:<span class="string">'/your/server/data/api'</span>,</span><br><span class="line">     <span class="string">"res"</span>:&#123;</span><br><span class="line">         <span class="string">"success"</span>：<span class="literal">true</span>,</span><br><span class="line">          “name”:<span class="string">"IoveC"</span>,</span><br><span class="line">          <span class="string">"domain"</span>:<span class="string">"www.cnblogs.com"</span>  </span><br><span class="line">     &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-Vue是如何实现数据双向绑定的？"><a href="#20-Vue是如何实现数据双向绑定的？" class="headerlink" title="20. Vue是如何实现数据双向绑定的？"></a>20. Vue是如何实现数据双向绑定的？</h2><p>Vue数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2019/8/19/16ca75871f2e5f80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="1.png"></p>
<p>即：</p>
<ul>
<li>输入框内容变化时，Data中数据同步变化。即View=&gt;Data的变化</li>
<li>Data中数据变化时，文本节点的内容同步变化。即Data=&gt;View的变化</li>
</ul>
<p>其中，View变化更新Data，可以通过事件绑定的方式来实现，所以Vue的数据双向绑定的工作主要是如何根据Data变化更新View</p>
<p>Vue主要通过以下4个不走来实现数据双向绑定的：</p>
<p>实现一个监听器Observer：对数据进行遍历，包括子属性对象的属性，利用Object.defineProperty()对属性加上setter和getter这样的话，给这个对象的某个值赋值就会触发setter，那么就能监听到了数据变化。</p>
<p>实现一个解析器Complie:解析Vue模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变化；收到通知，调用更新函数进行数据更新</p>
<p>实现一个订阅者Watcher：Watcher订阅者是Observer和Complie之间通信的桥梁，主要的任务是订阅Observer中属性值的变化的消息，当收到属性变化的消息时，触发解析器Complie中对应的更新函数。</p>
<p>实现一个订阅器Dep：订阅器采用发布-订阅设计模式，用来收集订阅者Watcher，对监听器Observer和订阅者Watcher进行统一管理</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2019/8/19/16ca75871f729d89?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="1.png"> </p>
<h2 id="21-Vue框架怎么实现对象和数据的监听？"><a href="#21-Vue框架怎么实现对象和数据的监听？" class="headerlink" title="21. Vue框架怎么实现对象和数据的监听？"></a>21. Vue框架怎么实现对象和数据的监听？</h2><p>如果被问到Vue怎么实现数据双向绑定的，大家肯定会回答通过<code>Object.defineProperty()</code>对数据进行劫持，但是<code>Object.defineProperty()</code>只能对属性进行数据劫持，不能对整个对象进行劫持，同理也无法对数组进行劫持，Vue是怎么检测到对象和数组的变化，查看相关代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">observeArray(items:Array&lt;any&gt;)&#123;</span><br><span class="line">   for(let i&#x3D;0,i&#x3D;items.length;i&lt;1;i++)&#123;</span><br><span class="line">       observe(items[i])  &#x2F;&#x2F;observe 功能为检测数据的变化</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let childOb &#x3D; !shallow &amp;&amp; observe(val) &#x2F;&#x2F; observe 功能检测数据的变化</span><br></pre></td></tr></table></figure>

<p>通过Vue源码查看，Vue框架是通过遍历数组和递归遍历对象，从而达到利用<code>Object.defineProperty()</code>也能对对象和数组进行监听。</p>
<h2 id="22-proxy与Object-defineProperty优劣对比"><a href="#22-proxy与Object-defineProperty优劣对比" class="headerlink" title="22. proxy与Object.defineProperty优劣对比"></a>22. proxy与Object.defineProperty优劣对比</h2><p>Proxy的优势如下：</p>
<ul>
<li>proxy可以直接监听对象而非属性</li>
<li>Proxy可以直接监听数组的变化</li>
<li>Proxy有多达13中拦截方法，不限于apply，ownKeys,deleteProperty等等<code>Object.defineProperty</code>不具备的</li>
<li>Proxy返回的是一个新的对象，我们可以只操作新的对象达到目的，而<code>Objecct.defineProperty</code>只能遍历对象属性直接修改</li>
</ul>
<p><code>Object.defineProperty</code>的优势如下：</p>
<ul>
<li>兼容性好，支持IE9，而Proxy的存在浏览器兼容器问题，而且无法用polyfill磨平</li>
</ul>
<h2 id="23-Vue怎么用vm-set-解决对象新增属性不能响应的问题？"><a href="#23-Vue怎么用vm-set-解决对象新增属性不能响应的问题？" class="headerlink" title="23.Vue怎么用vm.$set()解决对象新增属性不能响应的问题？"></a>23.Vue怎么用vm.$set()解决对象新增属性不能响应的问题？</h2><p>受现代JavaScript的限制，Vue无法检测到对象属性的添加或删除。由于Vue会在初始化实例时对属性执行getter/setter转化，所以属性必须在data对象上存在才能让Vue将它转换为响应式的。但是Vue提供了<code>Vue.set(object,propertyName,value)/Vue.$set(object,propertyName,value)</code>来实现对选哪个添加响应式属性，那么框架本身是如何实现的呢？</p>
<p>查看对应的Vue源码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// target 为数组  </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    <span class="comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span></span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    <span class="comment">// 利用数组的splice变异方法触发响应式  </span></span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// key 已经存在，直接修改属性值  </span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="comment">// target 本身就不是响应式数据, 直接赋值</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对属性进行响应式处理</span></span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vm.$set的实现原理是：</p>
<ul>
<li>如果目标是数组，直接使用数组的splice方法触发响应式</li>
<li>如果目标是对象，会先判断属性是否存在，对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用<code>defineReactive</code>方法进行响应式处理(defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法)</li>
</ul>
<h2 id="24-虚拟DOM的优缺点"><a href="#24-虚拟DOM的优缺点" class="headerlink" title="24. 虚拟DOM的优缺点"></a>24. 虚拟DOM的优缺点</h2><p>优点：</p>
<ul>
<li>保证性能下限：框架的虚拟DOM需要适配任何上层API可能产生的操作，它的一些DOM操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的DOM操作性能要好很多，因此框架的虚拟DOM至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限。</li>
<li>无需手动操作DOM：我们不需要手动去操作DOM，只需要写好view-Modek的代码逻辑，框架会根据虚拟DOM和数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率</li>
<li>跨平台：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，相比之下虚拟DOM可以更方便地跨平台操作，例如服务器渲染，weex开发等等</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法进行极致优化：虽然虚拟DOM+合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化</li>
</ul>
<h2 id="25-虚拟DOM实现原理"><a href="#25-虚拟DOM实现原理" class="headerlink" title="25. 虚拟DOM实现原理"></a>25. 虚拟DOM实现原理</h2><p>虚拟DOM的实现原理主要包括以下3部分</p>
<ul>
<li>用JavaScript对象模拟真实DOM树，对真实DOM树进行抽象</li>
<li>diff算法 —比较两棵虚拟DOM树的差异</li>
<li>pach算法—-将两个虚拟DOM对象的差异应用到真正的DOM树</li>
</ul>
<h2 id="26-Vue中的key有什么用"><a href="#26-Vue中的key有什么用" class="headerlink" title="26. Vue中的key有什么用"></a>26. Vue中的key有什么用</h2><p>key是Vue中vnode的唯一标识，通过这个key，我们的diff操作可以更准确，更快速。Vue的diff过程可以概括为:oldCh和newCh各有两个头尾的变量oldStartIndex，oldEndIndex和newStartIndex，newEndIndex他们会新节点和旧节点进行两两对比，即一共有4中比较方式：newStartIndex和oldStartIndex， newEndIndex和oldEndIndex，newStartIndex和oldEndIndex，newEndIndex和newStartIndex，如果以上4中比较都没有匹配，如果设置了key，就会用key再进行比较。</p>
<p>所以Vue中key的作用是：key是作为Vue中Vnode的唯一标识，通过这个key我们的diff操作可以更准确，更快速</p>
<p>更准确：因为带key就不是就地复用了，在sameNode函数<code>a.key===b.key</code>对比中可以避免就地复用的情况，所以会更加准确</p>
<p>更快速：利用key的唯一性生成map对象来获取对应节点，比遍历方式更快，源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKeyToOldIdx</span>(<span class="params">children,beginIdx,endIdx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i,key</span><br><span class="line">    <span class="keyword">const</span> map =&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=beginIdx;i&lt;=endIdx;++i)&#123;</span><br><span class="line">        key=children[i].key;</span><br><span class="line">        <span class="keyword">if</span> (isDef(key))map[key]=i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-对Vue项目进行哪些优化？"><a href="#27-对Vue项目进行哪些优化？" class="headerlink" title="27. 对Vue项目进行哪些优化？"></a>27. 对Vue项目进行哪些优化？</h2><p>（1）代码层面的优化</p>
<ul>
<li>v-if和v-show区别使用场景</li>
<li>computed和watch区分使用场景</li>
<li>v-for遍历必须为item添加key，且避免同时使用v-if</li>
<li>长列表性能优化</li>
<li>事件的销毁</li>
<li>图片资源懒加载</li>
<li>路由懒加载</li>
<li>第三方插件按需引用</li>
<li>服务端渲染SSR or预渲染</li>
</ul>
<p>（2）webpack层面的优化</p>
<ul>
<li>webpack对图片进行压缩</li>
<li>减少ES6转为ES5的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的CSS</li>
<li>VUe项目编译优化</li>
</ul>
<p>（3）基础的web技术的优化</p>
<ul>
<li>开启gzip压缩</li>
<li>浏览器缓存</li>
<li>CDN的使用</li>
</ul>
<h2 id="28-对于vue3-0特性你有什么了解"><a href="#28-对于vue3-0特性你有什么了解" class="headerlink" title="28. 对于vue3.0特性你有什么了解"></a>28. 对于vue3.0特性你有什么了解</h2><p>（1）检测机制的改变</p>
<p>3.0将带来基于Proxy的observer实现，提供全语言覆盖的反应性跟踪。消除了Vue2当基于Object.defineProperty的实现存在的很多限制</p>
<ul>
<li>只能检测属性，不能检测对象</li>
<li>检测属性的添加和删除</li>
<li>检测数组索引和长度的变更</li>
<li>支持Map，set，weakMap和WeakSet</li>
</ul>
<p>（2）模板</p>
<p>模板方面，改了作用域插槽，把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</p>
<p>（3）对象式的组件声明方式</p>
<p>3.0修改了组件的声明方式，改成了类式的写法，这样使得和TypeScript的结合更加容易</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">刘如刚</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.liurugang.cn/posts/719/">http://blog.liurugang.cn/posts/719/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.liurugang.cn" target="_blank">无聊才读书-博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/60077/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Nuxt.js介绍</div></div></a></div><div class="next-post pull-right"><a href="/posts/43167/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">git</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 刘如刚</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><meta name="generator" content="Hexo 4.2.1"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":120,"height":260},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>