{"meta":{"title":"无聊才读书-博客","subtitle":"无聊才读书","description":"不轻言放弃的小小人儿","author":"刘如刚","url":"http://blog.liurugang.cn","root":"/"},"pages":[{"title":"","date":"2021-01-21T11:18:45.406Z","updated":"2021-01-18T16:10:00.000Z","comments":true,"path":"gitcalendar/css/gitcalendar.css","permalink":"http://blog.liurugang.cn/gitcalendar/css/gitcalendar.css","excerpt":"","text":".gitcalendar { font-family: SourceHanSans-Medium; border: 1px solid #DDDDDD; border-radius: 3px; min-height: 120px; text-align: center; margin: 0 auto; border-width:0px; width:100%; display: flex; display: -webkit-flex; justify-content: center; align-items:center; flex-wrap:wrap; } .gitcalendar-graph text.wday, .gitcalendar-graph text.month { font-size: 10px; fill: #aaa; } .contrib-legend { text-align: right; padding: 0 14px 10px 0; display: inline-block; float: right; } .contrib-legend .legend { display: inline-block; list-style: none; margin: 0 5px; position: relative; bottom: -1px; padding: 0; } .contrib-legend .legend li { display: inline-block; width: 10px; height: 10px; } .text-small { font-size: 12px; color: #767676; } .gitcalendar-graph { padding: 15px 0 0; text-align: center; } .contrib-column { text-align: center; border-left: 1px solid #ddd; border-top: 1px solid #ddd; font-size: 11px; } .contrib-column-first { border-left: 0; } .table-column { padding:10px; display: table-cell; width:33%; vertical-align: top; } .contrib-number { font-weight: 300; line-height: 1.3em; font-size: 24px; display: block; } .gitcalendar img.spinner { width: 70px; margin-top: 50px; min-height: 70px; } .monospace { text-align: center; color: #000; font-family: monospace; } .monospace a { color: #1D75AB; text-decoration: none; } .contrib-footer { font-size: 11px; padding: 0 10px 12px; text-align: left; width: 100%; box-sizing: border-box; height: 26px; } .left.text-muted { float: left; margin-left: 9px; color: #767676; } .left.text-muted a { color: #4078c0; text-decoration: none; } .left.text-muted a:hover, .monospace a:hover { text-decoration: underline; } h2.f4.text-normal.mb-3 { display: none; } .float-left.text-gray { float: left; } #user-activity-overview{ display:none; } .day-tooltip { white-space: nowrap; position: absolute; z-index: 99999; padding: 10px; font-size: 12px; color: #959da5; text-align: center; background: rgba(0,0,0,.85); border-radius: 3px; display: none; pointer-events: none; } .day-tooltip strong { color: #dfe2e5; } .day-tooltip.is-visible { display: block; } .day-tooltip:after { position: absolute; bottom: -10px; left: 50%; width: 5px; height: 5px; box-sizing: border-box; margin: 0 0 0 -5px; content: \" \"; border: 5px solid transparent; border-top-color: rgba(0,0,0,.85) } .position-relative {width:100%;padding-left:20px;padding-right:20px;} @media screen and (max-width: 650px){.contrib-column{display:none}} .angle-wrapper { z-index:9999; display:inline; display:none; width: 200px; height: 40px; position: relative; padding: 5px 0; background: rgba(0, 0, 0, 0.8); border-radius: 8px; text-align: center; color: white; } .angle-box { position:fixed; padding:10px } .angle-wrapper span{ padding-bottom:1em; } .angle-wrapper:before { content: ''; width: 0; height: 0; border: 10px solid transparent; border-top-color: rgba(0, 0, 0, 0.8); position: absolute; left: 47.5%; top: 100%; }"},{"title":"","date":"2021-01-21T11:26:03.760Z","updated":"2021-01-21T11:26:03.760Z","comments":true,"path":"gitcalendar/js/gitcalendar.js","permalink":"http://blog.liurugang.cn/gitcalendar/js/gitcalendar.js","excerpt":"","text":"const gitcalendar = new Vue({ el: '#gitcalendar', data: { simplemode: true, //打开时使用canvas绘制gitgitcalendar，关闭时使用svg绘制gitgitcalendar //canvas：dom数少，但图像会发生模糊，自适应一般 svg：dom数多，图像清晰，自适应更佳 user: 'liuboringbook', //这里填写你的github用户名 fixed: 'fixed', px: 'px', x: '', y: '', span1: '', span2: '', month: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'], monthchange: [], oneyearbeforeday: '', thisday: '', amonthago: '', aweekago: '', weekdatacore: 0, datacore: 0, total: 0, datadate: '', data: [], positionplusdata: [], firstweek: [], lastweek: [], beforeweek: [], thisweekdatacore: 0, mounthbeforeday: 0, mounthfirstindex: 0, crispedges: 'crispedges', thisdayindex: 0, amonthagoindex: 0, amonthagoweek: [], firstdate: [], first2date: [], montharrbefore: [], monthindex: 0, purple: ['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f',], green: ['#ebedf0', '#f0fff4', '#dcffe4', '#bef5cb', '#85e89d', '#34d058', '#28a745', '#22863a', '#176f2c', '#165c26', '#144620'], blue: ['#ebedf0', '#f1f8ff', '#dbedff', '#c8e1ff', '#79b8ff', '#2188ff', '#0366d6', '#005cc5', '#044289', '#032f62', '#05264c',], color: ['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f',] }, methods: { selectStyle(data, event) { document.querySelector('.angle-wrapper').style.display = 'block' this.span1 = data.date; this.span2 = data.count; this.x = event.clientX - 100; this.y = event.clientY - 60 }, outStyle() { document.querySelector('.angle-wrapper').style.display = 'none' }, thiscolor(x) { if (x === 0) { let i = parseInt(x / 2); return this.color[0] } else if (x < 2) { return this.color[1] } else if (x < 20) { let i = parseInt(x / 2); return this.color[i] } else { return this.color[9] } }, } }); let githubapiurl = \"https://python-github-calendar-api.vercel.app/api?\" + gitcalendar.user; //let githubapiurl = \"https://githubapi.ryanchristian.dev/user/\" + gitcalendar.user; //旧的api策略 //canvas绘图 function responsiveChart() {if(gitcalendar.simplemode){ let c = document.getElementById(\"gitcanvas\"); let cmessage = document.getElementById(\"gitmessage\"); let ctx = c.getContext(\"2d\"); c.width = document.getElementById(\"gitcalendarcanvasbox\").offsetWidth; let linemaxwitdh = 0.96 * c.width / gitcalendar.data.length; c.height = 9 * linemaxwitdh; let lineminwitdh = 0.8 * linemaxwitdh; let setposition = { x: 0.02 * c.width, y: 0.025 * c.width }; for (let week in gitcalendar.data) { weekdata = gitcalendar.data[week]; for (let day in weekdata) { let dataitem = {date: \"\", count: \"\", x: 0, y: 0}; gitcalendar.positionplusdata.push(dataitem); ctx.fillStyle = gitcalendar.thiscolor(weekdata[day].count); setposition.y = Math.round(setposition.y * 100) / 100; dataitem.date = weekdata[day].date; dataitem.count = weekdata[day].count; dataitem.x = setposition.x; dataitem.y = setposition.y; ctx.fillRect(setposition.x, setposition.y, lineminwitdh, lineminwitdh); setposition.y = setposition.y + linemaxwitdh } ; setposition.y = 0.025 * c.width; setposition.x = setposition.x + linemaxwitdh } ; ctx.font = \"600 Arial\"; ctx.fillStyle = '#aaa'; ctx.fillText(\"日\", 0, 1.9 * linemaxwitdh); ctx.fillText(\"二\", 0, 3.9 * linemaxwitdh); ctx.fillText(\"四\", 0, 5.9 * linemaxwitdh); ctx.fillText(\"六\", 0, 7.9 * linemaxwitdh); let monthindexlist = c.width / 24; for (let index in gitcalendar.monthchange) { ctx.fillText(gitcalendar.monthchange[index], monthindexlist, 0.7 * linemaxwitdh); monthindexlist = monthindexlist + c.width / 12 } ; cmessage.onmousemove = function (event) { document.querySelector('.angle-wrapper').style.display = 'none' }; c.onmousemove = function (event) { document.querySelector('.angle-wrapper').style.display = 'none' getMousePos(c, event); }; function getMousePos(canvas, event) { var rect = canvas.getBoundingClientRect(); var x = event.clientX - rect.left * (canvas.width / rect.width); var y = event.clientY - rect.top * (canvas.height / rect.height); //console.log(\"x:\"+x+\",y:\"+y); for (let item of gitcalendar.positionplusdata) { let lenthx = x - item.x; let lenthy = y - item.y; //console.log(lenthx,lenthy); if (0 < lenthx && lenthx < lineminwitdh) { if (0 < lenthy && lenthy < lineminwitdh) { //console.log(item.date,item.count) document.querySelector('.angle-wrapper').style.display = 'block' gitcalendar.span1 = item.date; gitcalendar.span2 = item.count; gitcalendar.x = event.clientX - 100; gitcalendar.y = event.clientY - 60 } } //if(0< x - item.x"}],"posts":[{"title":"高频考点","slug":"高频考点","date":"2021-06-02T15:30:53.636Z","updated":"2021-06-02T15:30:53.874Z","comments":true,"path":"posts/63672/","link":"","permalink":"http://blog.liurugang.cn/posts/63672/","excerpt":"","text":"高频考点1. typeof类型判断 typeof 是否能正确判断类型？ instanceof能正确判断对象的原理是什么 type 对于原始类型，除了 null都可以只显示正确的类型 12345typeof 1 //'number'typeof '1' //'string'typeof undefined //'undefined'typeof true //'boolean'typeof Symbol() //'symbol' typeof 对于对象来说，除了函数都会显示object,所以说typeof并不能准确判断变量到底是什么类型 123typeof [] //'object'typeof &#123;&#125; //'object'typeof console.log //'function' 如果我们想判断一个对象的正确类型，这时候可以考虑使用instanceof,因为内部机制是通过原型链来判断的 123456789const Person = function()&#123;&#125;const p1 = new Person()p1 instanceof Person // truevar str = 'hello world'str instanceof String //falsevar str1= new String('hello world')str1 instanceof String //true 对于原始类型来说，逆向直接通过instanceof 来判断类型是不行的 2.类型转换 在JS中类型转换只有三种情况，分别是 转换为布尔值 转换为数字 转换为字符串 转为Boolean 在条件判断时，除了 undefined , null ,false ,NaN,’ ‘,0,-0,其他所有值都转为true，包括所有对象 对象转为原始类型 对象在转换类型的时候，会调用内置的[[ToPrimitive]]函数，对于该函数来说，算法逻辑一般来说如下 如果已经是原型类型了，那就不需要转换了 调用x.valueOf()如果转换为基础类型，就返回转换的值 调用x.toString()，如果转换为基础类型，就返回转换的值 如果没有返回原型类型，就会报错 当然你也可以重写Symbol.toPrimitive，刚方法在转原始类型时调用优先级最高 123456789101112let a = &#123; valueOf()&#123; return 0 &#125;, toString()&#123; return '1' &#125;, [Symbol.toPrimitive]()&#123; return 2 &#125;&#125;1+ a //3 四则运算 它有以下几个特点： 运算中其中一方为字符串，那么久会把另一方也转换为字符串 如果一方不是字符串或数字，那么会将它转换为数字或者字符串 1231+ '1' //'11'true + true //24+ [1,2,3] //\"41,2,3\" 对于第一行代码来说，触发特点一，所以将数字1转换为字符串，得到结果’11‘ 对于第二行代码来说，触发特点二，所以将true转为数字1 对于第三行代码来说，触发特点二，所以将数组通过toString转为字符串1,2,3，得到结果41，2,3 比较运算符 如果是对象，就通过toPrimitive转换为对象 如果是字符串，就通过unicode字符索引来比较 123456789let a =&#123; valueOf()&#123; return 0 &#125;, toString()&#123; return '1' &#125;&#125;a&gt;-1 //true 在以上代码中，因为a是对象，所以会通过valueOf转换为原始类型再比较值 3. This123456789101112function foo()&#123; console.log(this.a)&#125;var a =1foo()const obj = &#123; a:2, foo:foo&#125;obj.foo()const c = new Foo() 对于直接调用foo 来说，不管foo函数放在什么地方，this一定是window 对于obj.foo()来说，我们只需要记住，谁调用了函数，谁就是this,所以在这个场景下foo函数中的this就是obj对象 对于new的方式来说，this被永远绑定在了c上面 不会被任何方式改变this 说完了以上几种情况，其实很多代码中的this应该就没什么问题了，下面让我们看看箭头函数中的this 12345678function a()&#123; return ()=&gt;&#123; return ()=&gt;&#123; console.log(this)//window &#125; &#125;&#125;console.log(a()()())//undefined 首先箭头函数其实是没有this的，箭头函数中的this只取决包裹箭头函数的第一个普通函数的this。在这个例子中，因为包裹箭头函数的第一个普通函数是a,所以此时的this是window。另外对箭头函数使用bind这类函数是无效的 最后种情况也就是bind这些改变上下文的API了，对于这些函数来说，this取决于第一个参数，如果第一个参数为空，那么就是window 无论我们给函数bind几次，fn中的this永远由第一次bind决定，所以结果永远是window 123let a = &#123;&#125;let fn = function()&#123;console.log(this)&#125;fn.bind.bind(a)() //window 以上就是this的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高来决定this最终指向哪里 首先，new的方式优先级最高，接下来是bind这些函数，然后是obj.foo()这种调用方式，最后是foo这种调用方式，同时，箭头函数的this一旦被绑定，就不会再被任何方式所改变 4. == 和===有什么区别 对于==来说，如果对比双方的类型不一样的话，就会进行类型转换 假如我们需要对比x和y是否相同，就会进行如下判断流程 首先会判断两者类型是否相同，相同的话就是比大小了 类型不相同的话，那么就会进行类型转换 会先判断是否在对比null和undefined,是的话就会返回true 判断两者类型是否为string和number，是的话就会将字符串转换为number 判断其中一方是否为boolean.是的话就把boolean转为number再进行判断 判断其中一方是否为Object且另一方为string,number或者symbol，是的话就会把object转为原始类型再进行判断 对于===来说就简单多了，就是判断两者类型和值是否相同 5. 闭包 闭包的定义其实很简单：函数A内部有一个函数B，函数B可以访问到函数A中的变量，那么函数B就是闭包 12345678function A()&#123; let a =1 window.B = function()&#123; console.log(a) &#125;&#125;A()B() //1 闭包存在的意义就是让我们可以间接访问函数内部的变量 经典面试题，循环中说那个闭包解决var定义函数的问题 12345for(var i=1;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i) &#125;,i*1000)&#125; 首先因为setTimeout是个异步函数，所以会先把循环占全部执行完毕，这时候i就是6了，所以会输出一堆6 解决办法有三种 第一种是使用闭包的方式 1234567for(var i=1;i&lt;=5;i++)&#123; ;(function(j)&#123; setTimeout(function timer()&#123; console.log(j) &#125;,j*1000) &#125;)(i)&#125; 在上述代码汇总，我们首先使用了立即执行函数将i传入函数内部，这时候值就被固定在了参数j上面不会改变，当下次执行timer这个闭包的时候，就可以使用外部函数的变量j,从而达到目的 第二种就是使用setTimeout的第三个参数，这个参数会被当做timer函数的参数传入 12345for(var i=1;i&lt;=5;i++)&#123; setTimeout(function timer(j)&#123; console.log(j) &#125;,i*1000,i)&#125; 第三种就是使用let定义i了来解决问题，这个也是最为推荐的方式 12345for(let i=1;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i) &#125;,i*1000)&#125; 6. 深浅拷贝浅拷贝 首先可以通过Object.assign来解决这个问题，很多人认为这个函数是用来深拷贝的，其实并不是，Object.assign只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝 123456let a =&#123; age:1&#125;let b = Object.assign(&#123;&#125;,a)a.age = 2;console.log(b.age) //1 另外我们还可以通过展开运算符...来实现浅拷贝 123456let a =&#123; age:1&#125;let b =&#123;...a&#125;a.age =2console.log(b.age) //1 通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用深拷贝 123456789let a =&#123; age:1, jobs:&#123; first: 'FE' &#125;&#125;let b =&#123;...a&#125;a.jobs.first ='native'console.log(b.jobs.first) //native 深拷贝 这个问题通常可以使用JSON.parse(JSON.stringify(object))来解决 123456789let a = &#123; age:1, jobs:&#123; first:'FE' &#125;&#125;let b = JSON.parse(JSON.stringify(a))a.jobs.first ='native'console.log(b.jobs.first) //FE 但是这个犯法也是有局限性的 会忽略undefined 会忽略symbol 不能序列化函数 不能解决循环引用的对象 7. 原型 原型链就是多个对象通过__proto__的方式连接了起来。为什么obj可以访问到valueof函数，就是因为obj通过原型链找到了valueof函数 Object是所有对象的爸爸，所有对象都可以通过__proto__找到它 Function是所有函数的爸爸，所有函数都可以通过__proto__找到它 函数的prototype是一个对象 对象的__proto__属性指向原型，__proto__将对象和原型连接起来组成了原型链 8. var let 及const区别 函数提升优先变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部 var存在提升，我们能在声明之前使用。let，const因为暂时性死区的原因，不能在声明前使用 var在全局作用域下声明变量会导致变量挂载在window上，其他两者不会 let和const作用基本一致，但是后者声明的变量不能再次赋值 9. 原型继承和class继承首先先来讲下class，其实在JS中并不存在类，class只是语法糖，本质还是函数 12class Person&#123;&#125;Person instanceof Function //true 组合继承 组合继承是最常用的继承方式 1234567891011121314function Parent(value)&#123; this.val =value&#125;Person.prototype.getValue = function()&#123; console.log(this.val)&#125;function Child(value)&#123; Parent.call(this.value)&#125;Child.prototype =new Parent()const child = new Child(1)child.getValue()//1child instanceof Parent //true 以上继承的方式核心是在子类的构造函数中通过Parent.call(this)继承父类的属性，然后改变子类的原型为new Parent()来继承父类的函数 这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费 寄生组合继承 这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行 1234567891011121314151617181920function Parent(value)&#123; this.val = value &#125; Parent.prototype.getValue = function()&#123; console.log(this.val)&#125;function Child(value)&#123; Parent.call(this,value)&#125;Child.prototype = Object.create(Parent.prototype,&#123; constructor:&#123; value:Child, enumerable:false, writable:true, configurable:true &#125;&#125;)const child = new Child(1)child.getValue() //1child.instanceof Parent //true 以上继承实现的核心就是将父类的原型赋值给了子类，并将构造函数设置为子类，这样即解决了无用的父类属性问题，还能正确的找到子类的构造函数。 class继承 以上两种继承方式都是通过原型去解决的，在ES6中，我们可以使用class去实现继承，并且实现起来很简单 1234567891011121314151617class Parent&#123; constructor(value)&#123; this.val = value &#125; getValue()&#123; console.log(this.val) &#125;&#125;class Child extends Parent&#123; constrcutor(value)&#123; super(value) this.val = value &#125;&#125;let child = new Child(1)child.getValue()//1child instanceof Parent //true class 实现继承的核心在于使用extends表明继承自那个父类，并且在子类构造函数中必须嗲偶偶那个super，因为这段代码可以看成Parent.call(this,value) 10. 实现一个简洁版的promise1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//三个常量用于表示状态const PENDING ='pending'const RESOLVED = 'resolved'const REJECTED = 'rejected'function MyPromise(fn)&#123; const that =this; this.state = PENDING //value 变量用于保存resolve或者reject中传入的值 this.value = null //用于保存then中的回调，因为当执行完Promise时状态可能还是等待中，这时候应该把状态存储下来 that.resolvedCallbacks =[] that.rejectedCallbacks =[] function resolve(value)&#123; //首先两个函数都得判断当前状态是否为等待中 if(that.state ===PENDING)&#123; that.state =RESOLVED that.value = value //遍历回调数组并执行 that.resolvedCallbacks.map(cb=&gt;cb(that.value)) &#125; &#125; function reject(value)&#123; if(that.state ===PENDING)&#123; that.state = REJECTED that.value = value that.rejectedCallbacks.map(cb =&gt;cb(that.value)) &#125; &#125; //完成以上两个函数以后，我们就该实现如何执行Promise中传入的函数了 try()&#123; fn(resolve,reject) &#125;catch(e)&#123; reject(e) &#125;&#125;//最后我们来实现较为复杂的then函数MyPromise.prototype.then = function(onFullfilled,onRejected)&#123; const that =this //判断两个参数是否为函数类型，因为这两个参数是可选参数 onFullfilled = typeof onFullfilled === 'function' ? onFullfilled: v=&gt;v onRejected = typeof onRejected === 'function' ? onRejected: throw e //当状态不是等待时，就去执行响应的函数。如果状态是等待态的话，就往回调函数中push if(this.state === PENDING)&#123; this.resolvedCallbacks.push(onFullfilled) this.rejectedCallbacks.push(onRejected) &#125; if(this.state === RESOLVED)&#123; onFullfilled(that.value) &#125; if(this.state === REJECTED)&#123; onRejected(that.value) &#125;&#125; 11. Event Loop进程与线程 JS是单线程执行的 进程描述了CPU在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小的单位，描述了执行一段指令所需要的时间 把这些概念拿到浏览器中国来说，当你打开一个Tab页时，其实就是创建了一个进程，一个进程中可以有很多个线程，比如渲染线程，JS引擎线程，HTTP请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁 上文说到了JS引擎线程和渲染线程，大家应该都知道，在JS运行的时候可能会阻止UI渲染，这说明了两个线程是互斥的，这其中的原因是因为JS可以修改DOM，如果在JS执行的时候UI线程还在工作，就可能导致不能安全的渲染UI。这其实也是单线程的好处，得益于JS是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处 执行栈 可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则 当开始执行JS代码时，首先会执行一个main函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，foo函数后执行，当执行完毕后就从栈中弹出了 1234567function foo()&#123; throw new Error('error')&#125;function bar()&#123; foo()&#125;bar() 浏览器中的Event loop JS是门非阻塞单线程语言，因为在最初JS就是为了和浏览器交互诞生的。如果JS是门多线程语言话，我们在多个线程中处理DOM就可能发生问题 JS在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，就被挂起并加入到Task队列中。一旦执行栈为空，Event Loop就会从Task队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说JS中的异步还是同步行为 1234567console.log('script start')setTimeout(function()&#123; console.log('setTimeout')&#125;,0)console.log('script end') //先后顺序为 script start script end setTimeout 不同的任务源会被分配到不同的Task队列中，任务源可以分为微任务和宏任务。 微任务 process.nextTick promise Object.observe 宏任务 script setTimeout setInterval setImmediate I/O UI rendering setTimeout 所以正确的一次Event Loop 顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有的微任务 必要的话渲染UI 然后开始下一轮 Event loop ，执行宏任务中的异步代码 1234567891011121314console.log('script start')setTimeout(function()&#123; console.log('setTimeout')&#125;，0)new Promise((resolve)=&gt;&#123; console.log('Promise') resolve()&#125;).then(function()&#123; console.log('promise1')&#125;).then(function()&#123; console.log('promise2')&#125;)console.log('script end') 12. 手写 call apply 及bind函数 不传入第一个参数，那么上下文默认为window 改变了this指向，让新的对象可以执行该函数，并能接收参数 实现call 首先context为可选参数，如果不传的话，默认上下文为window 接下来给context创建一个fn属性，并将值设置为需要调用的函数 因为call可以传入多个参数作为调用的参数，所有需要将参数剥离出来 然后调用函数并将对象上的函数删除 1234567891011Function.prototype.myCall = function(context)&#123; if(typeof this !== 'function')&#123; thorw new TypeError('Error') &#125; context = context || window context.fn = this const args = [...arguments].slice(1) const result = context.fn(...args) delete context.fn return result&#125; apply的实现 12345678910111213141516Function.prototype.myApply = function(context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Error') &#125; context = context || window context.fn = this let result // 处理参数和 call 有区别 if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; delete context.fn return result &#125; bind的实现 bind 返回了⼀个函数，对于函数来说有两种⽅式调⽤，⼀种是直接调⽤，⼀种是通过new 的⽅式，我们先来说直接调⽤的⽅式 对于直接调⽤来说，这⾥选择了 apply 的⽅式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2) ，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(…arguments) 最后来说通过 new 的⽅式，在之前的章节中我们学习过如何判断 this ，对于 new 的情况来说，不会被任何⽅式改变 this ，所以对于这种情况我们需要忽略传⼊的 this 123456789101112131415Function.prototype.myBind = function(context)&#123; if(typeof this !== 'function')&#123; throw new TypeError('Error') &#125; const _this =this; const args = [...arguments].slice(1) //返回一个函数 return function F()&#123; //因为返回了一个函数，我们可以new F()，所以需要判断 if(this instanceof F)&#123; return new _this(..args, ...arguments) &#125; return _this.apply(context,args.concat(...arguments)) &#125;&#125; 13. new在调用new的过程中发生四件事情 新生成了一个对象 连接到原型 绑定 this 返回新对象 14. instanceof 的原理instanceof可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的prototype 实现以下instanceof 首先获取类型的原型 然后获得对象的原型 然后一直循环判断对象的原型是否等于类型的原型，知道对象原型为null，因为原型链最终为null 12345678910111213function myInstanceof(left,right)&#123; let prototype = right.prototype left = left.__proto__ while(true)&#123; if(left === null || left === undefined)&#123; return false &#125; if(prototype === left)&#123; return true left = left.__proto__ &#125; &#125;&#125; 15. 事件机制事件触发有三个阶段 window往事件触发处传播，遇到注册的捕获事件会触发 传播到事件触发处触发注册的事件 从事件触发处往window传播，遇到注册的冒泡事件会触发 16. 注册事件 通常我们使用addEventListener注册事件，该函数的三个参数可以是布尔值，也可以是对象。对于布尔值useCapture参数来说，该参数默认值为false，userCapture决定了注册的事件是捕获事件还是冒泡事件。 该参数默认值为false capture： 布尔值，和useCapture作用一样 once: 布尔值，值为true表示该回调只会回调一次，调用后会移除监听 passive： 布尔值，表示永远不会调用preventDefault 一般来说，如果我们只希望事件只触发在目标上，这时候可以使用 stopPropagation来阻止事件的进一步传播，筒仓我们任务stopPropagation是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。 事件代理 如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上 12345678910111213&lt;ul id=\"ul\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; let ul = document.querySelected('#ul') ul.addEventListener('click',(event)=&gt;&#123; console.log(event.target) &#125;)&lt;/script&gt; 事件代理的方式相较于直接给目标注册事件来说，有以下优点 节省内存 不需要给子节点注销事件","categories":[],"tags":[]},{"title":"前端面试题-续","slug":"前端面试题-续","date":"2021-05-27T08:46:02.642Z","updated":"2021-05-27T09:32:12.526Z","comments":true,"path":"posts/25536/","link":"","permalink":"http://blog.liurugang.cn/posts/25536/","excerpt":"","text":"前端面试题基础题HTML，HTTP，web综合问题18.请描述一个cookie，sessionStorage和localStorage的区别？ cookie是网站为了标示用户身份而储存用户本地终端上的数据 cookie数据始终在同源的http请求中携带，记会在浏览器和服务器间来回传递 sessionStorage和 localStorage不会自动把数据发送服务器，仅在本地保存 存储大小： cookie数据大小不能超过4K sessionStorage和localStorage虽然也有存储大小的限制，但是比cookie大得多，可以到达5M或更大 有效时间： localStroage： 储存持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage： 数据在当前浏览器窗口关闭后自动删除 cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 19. Canvas 和SVG有什么区别 svg 绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。Canvas输出的是整个画布 svg输出的图形是矢量图形，后期可以修改参数自由放大缩小，不会失真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿 20. viewport1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0 maximum-scale=1.0 user-scalable\"&gt; width 设置viewport宽度，为一个正整数，或字符串‘device-width’ ‘device-width ’设备宽度 height 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置 initial-scale 默认缩放比例 ，为一个数字，可以带小数 minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数 maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数 user-scalable 是否允许手动缩放 21. 渲染优化 禁止使用iframe 禁止使用gif图片实现loading效果(降低CPU消耗，提高渲染性能) 使用CSS3代码替代JS动画（尽可能避免重绘重排以及回流） 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较消耗CPU 页面中不要出现空的href和src 会阻塞页面其他资源对的加载 用innerHTML代替DOM操作，减少DOM操作次数，优化JavaScript性能 当需要设置的样式很多时设置className，而不是直接操作style 图片预加载，将样式表放在顶部，将脚本放在底部加上时间戳 少用全局变量，缓存DOM节点查找的结果。减少IO读取操作 22.简述一下src与href的区别 src用于替换当前元素，href用于当前文档和引用资源之间确认联系。 src 指向外部资源的位置，指向的内容将会嵌套入文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如JS脚本，img图片等元素 &lt;script src=&quot;js.js&quot;&gt;&lt;/script&gt;当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到该资源加载，编译，执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部 href 是指向网络资源所在位置，建立和当前元素或当前文档之间的链接，如果我们在文档中添加 &lt;link href=&quot;common.css &quot;/&gt;那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方法加载css，而不是使用@import方式 23. 一个页面上有大量的图片(大型电商网站)，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。 图片懒加载，在页面上未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶部的距离与页面的距离，如果前者小于后者，优先加载。 如果为幻灯片，相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先加载。 如果图片为css图片，可以使用CSSsprite，SVGsprite， Iconfont， Base64 等技术 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩特别厉害的缩略图，以提高用户体验。 如果图片展示区域小于图片的真实大小，则因在服务器daunt根据业务需要先行进图片压缩，图片压缩后大小与展示一致","categories":[],"tags":[]},{"title":"基本面分析选股的十大思路","slug":"基本面分析选股的十大思路","date":"2021-02-09T15:01:04.063Z","updated":"2021-05-27T09:32:12.529Z","comments":true,"path":"posts/39011/","link":"","permalink":"http://blog.liurugang.cn/posts/39011/","excerpt":"","text":"基本面分析选股的十大思路一， 10年以上的内在价值增长率这是最重要的经营指标，虽然简单却经常被人忽略 不同的企业有不同的内在价值评估标准，例如银行股最看重的是净资产的增长；以轻资产为代表的格力电器等，看重的则是净利润的增长；而那些尚未盈利的电商，则以营业收入的增长作为参考指标等。 投资者在看财报三大表时，如果非新股的，上市有一段时间的，以应该通过choice金融终端，通过可视化图标，查询过去历年的内在价值增长率情况。时间越久，数据经受得起考验。 有些上市公司，动不动当期财报百分之几百的增长，请您去看看它的背后的原因是什么？能持久吗？或许就离真相不远了。 二，长期的ROE水平这里也涉及到具体情况分析，每个行业甚至每家企业都有着不同的评估体系。 重资产行业一般回报率15%是较为优秀的，而轻资产行业净资产回报率达到30%以上才算优秀。 投资者买股票，就等于成为公司股东，一家上市公司不管有多少理由，最终是否优秀，依然是在不违法的范围内，能给投资人带来多少真正的回报。 ROE净资产收益率，就是反映这一情况的经典指标。 三，行业属性该行业是否需要不断的，巨大的资本开支才能维持？ 这是“一本万利”的优秀模式？ 技术更新，商业模式变更是否缓慢？ 是否存在商业生态系统之外的竞争性力量介入？ 四, 市场容量是否拥有永续的需求存在？瓶颈以及天花板的大致位置在哪里？ 有些行业，其成长空间是注定有限的，这种行业的企业，注定了，是不会有真正意义上的股价大涨的，所谓的上涨，其本质只是跟随大盘上下起舞的波动 而有些行业，即使做到行业前三，甚至老大，都没能怎么盈利，那就不是企业的问题了，而是该行业本身市场容量的问题，比如共享单车。 如果一家共享单车企业已经是行业老大了，依然没能让投资人盈利，这或许从做生意的角度，就不是一笔好生意。 五, 财务报表背后不仅听其言，更要观其行。不要去看这家上市公司在说什么，而是看他做了什么。 本质上，财务报表就是一家企业经营行为的真实描述，三张表的解读，就可以看出管理层是否诚实，经营哲学是否保守还是激进。 六，商业模式长期看是否具有”护城河模型“的特点 曾经美国有一家初创企业A，凭借一个独特的idea，让公司业务蒸蒸日上，结果B企业把它的idea依样画葫芦全部抄走。A起诉B,B一边应诉一边扩大市场份额，A一心一意和法院打着交道。 结果几年之后。A拿着少的可怜的胜诉费，破产了。B发展到了今天 七，股权结构是否有管理层持股？管理层的立场，和股东的立场是否一致？如果一家公司，管理层依靠薪水为生的，那他的最高利益一定不是努力扩大美股收益，而是铺开摊子让自己薪水更高。 股东结果是否有利于管理？如果没有唯一大股东，而是俩个各持15%的股东，小心扯皮。 八，公司治理结构要求是体制精良，已成系统且运行流畅。 公司盈利，要么开源，要么节流。节流，关系到期间费用，也就是利润表中的财务费用，管理费用和销售费用，以及研发费用等，这个费用的多少，以及同等费用能够获得多大效益，都取决于公司治理结构。 九，管理水准最重要的参考指标便是公开言论以及长期财务数据背后透露出的经营哲学，长期是否言行一致，是否符合商业常识，比如研发支出资本化还是费用化，便显示出一家公司会计处理是否保守还是激进等等。 十，最好有5-10年以上的持续经营记录可供考察也就是经历过至少一轮完整对的经济周期波动，只有全面的了解其在波峰波谷的经营表现才能深知此企业的经营哲学，例如是在波峰还是波谷积极扩张之后所面临的经营结果具有天壤之差别。 从以上的这些变量中找到驱动内在价值成长或毁坏股东权益的因素来，并且判断这些因素在未来是否可持续。这样选择优质股就会相对比较轻松。","categories":[],"tags":[]},{"title":"CSS面试","slug":"CSS面试部分","date":"2021-01-31T12:43:44.732Z","updated":"2021-01-31T14:51:27.224Z","comments":true,"path":"posts/520520/","link":"","permalink":"http://blog.liurugang.cn/posts/520520/","excerpt":"","text":"CSS面试部分1. css sprite是什么，有什么优缺点 概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示要显示的背景图案 优点： 减少HTTP请求数，极大地提高页面加载速度 增加图片信息重复度，提高压缩比，减少图片大小 更换风格方便，只需要在一张或几张图片上修改颜色或样式即可实现 缺点 图片合并麻烦 维护麻烦，修改一个图片可能需要从新布局整个图片，样式 2. display:none;与visibility:hidden;的区别 联系：他们都能让元素不可见 区别 display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibi;ity:hidden;不会让元素从渲染树消失，渲染时元素继续占据空间，只是内容不可见 修改常规流中元素的display通常会造成文档重排。修改visiblity属性只会造成元素的重绘 3. link和@import的区别 link是HTML方式，@import是CSS方式 link最大限度支持并行下载，@import过多嵌套导致串行下载 @import必须在样式规则之前，可以在css文件中引用其他文件 总体上来说：link由于@import 4. 如何创建块级格式化上下文，BFC有什么用 创建规则： 根元素 浮动元素(float不取值为none) 绝对定位元素(position取值为absolute或fixed) display取值为inline-block,flex之一的元素 overflow不取值为visibale的元素 作用 可以包含浮动元素 不被浮动元素覆盖 阻止父子元素的margin折叠 5. 清浮动的几种方式，各自的优缺点 父级div定义height 结尾处加空div标签clear:both 父级div定义伪类:after和zoom 父级div定义overflow:hidden 6. css3有哪些新特性 新增各种css选择器 圆角border-radius 多列布局 阴影和反射 文字特性text-shadow 线性渐变 旋转transform css3新增伪类有哪些？ p:first-of-type选择属于其父元素的首个&lt;p&gt;元素的每个&lt;p&gt;元素 p:last-of-type选择属于其父元素的最后&lt;p&gt;元素的每个&lt;p&gt;元素 p:nth-child(2)选择属于其父元素的第二个子元素的每个&lt;p&gt;元素 :before在元素之前添加内容 :after在元素之后添加内容，也可以用来做清浮动 :enabled已启用的表单元素 :disable已经禁用的表单元素 :checked单选框或复选框被选中 7 .介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同？ 有两种：IE盒模型，W3c盒子模型 盒模型：内容（content）,填充(padding),边界(margin)，边框（border） 区别： IE的content部分把border和padding计算了进去 8. 几种常见的CSS布局流体布局 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;流体布局&lt;/title&gt; &lt;style&gt; .left&#123; float:left; width:100px; height: 200px; background: red; &#125; .right&#123; float:right; width: 200px; height: 200px; background: blue; &#125; .main&#123; margin-left: 120px; margin-right: 220px; height: 200px; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 圣杯布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;圣杯布局&lt;/title&gt; &lt;style&gt; .container&#123; margin-left: 120px; margin-right: 220px; &#125; .main&#123; float: left; width: 100%; height: 300px; background: green; &#125; .left&#123; position: relative; left: -120px; float: left; height: 300px; width: 100px; margin-left: -100%; background: red; &#125; .right&#123; position: relative; right: -220px; float: right; height: 300px; width: 200px; margin-left: -220px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;双飞翼布局&lt;/title&gt; &lt;style&gt; .content&#123; float:left; width: 100%; &#125; .main&#123; height: 200px; margin-left: 110px; margin-right: 220px; background: green; &#125; .main:after&#123; content:''; display:block; font-size: 0; height: 0; zoom: 1; clear:both &#125; .left&#123; float: left; height: 200px; width: 100px; margin-left: -100%; background: red; &#125; .right&#123; float: right; height: 200px; width: 200px; margin-left: -200px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"content\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 9.什么是外布局重叠？重叠的结果是什么？ 在css当中,相邻的两个盒子(可能是兄弟关系也可能是祖先关系)的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠。(前提是上下边框，而非左右边框) 折叠结果遵循一下计算规则 两个相邻的外边框都是正数时，折叠结果是他们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值 两个外边框一正一负时，折叠结果是两者的相加的和 10. 水平居中的方法 元素为行内元素，设置父元素text-align:center 元素为宽度固定，设置左右margin为auto 如果元素为绝对定位，设置父元素position为relative，元素设置为left：0;right:0;margin:auto 使用flex-box布局，指定justify-content属性为center display设置为table-ceil 11.垂直居中的方法 使用flex布局设置为align-item:center 绝对定位中设置bottom:0,top:0，并设置margin:auto 绝对定位中固定高度时设置top:50%;margin-top为为高度一半的负值 文本垂直居中设置line-height为height值 12. 重绘和回流是什么，如何避免 DOM变化影响到了元素的几何属性，浏览器重新计算元素的几何属性，其他元素的几何属性和位置也会受到影响，浏览器需要重新构造渲染树，这个过程称为重排。 浏览器将受到影响的部分重新绘制到屏幕上的过程称为重绘 引起重排的原因有： 添加或者删除可见的DOM元素 元素位置，尺寸，内容改变 浏览器页面初始化 浏览器页面初始化 浏览器窗口尺寸改变 触发重绘的操作 visibilty，背景色等属性导致样式的变化 重排一定重绘，重绘不一定重排 提升性能，减少重排重绘方法 将多次改变样式属性的操作合并成一次操作，尽量都是操作class 将多次重排的元素设为absolute或者fixed。这样元素就脱离了文档流，它的变化不会影响到其他元素，比如有动画效果的元素 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排 13. 说一说css3的animation css3的animation是css3新增的动画属性，这个css3动画的每一帧是通过@keyframes来声明的，keyframes声明了动画的名称，通过from，to或者百分比定义 每一帧动画元素的状态，通过animation-name来引用这个动画，同时css3动画也可以定义动画运行的时长，动画开始事件，动画播放方向，动画循环次数，动画播放的方式 常用的属性有：animation-name定义动画名，animation-duration定义动画播放的时长，animation-delay东一动画延迟播放的时间，animation-duration定义动画播放的时长 14. 如何实现小于12px的字体效果 transfrom:scale()这个属性只可以缩放定义宽高的元素，而行内元素是没有宽高的，我么可以加上display:inline-block 15. 解决移动端下1px像素问题 border-image 12border:1px solid transparentborder-image:url('./../../image/96.jpg'2 repeat) 图片的颜色就是此后border的颜色 总结：优点：没有副作用 缺点：border颜色变了就得重新绘制图片;圆角会比较模糊 使用box-shadow实现 1234box-shadow:0 -1px 1px -1px 1px 0 1px -1px 0 1px 1px -1px -1px 0 1px -1px 前面两个值x，y主要控制显示那条边，后面两值控制的是阴影半径，扩展半径。 总结 优点：使用简单，圆角也可以实现 缺点：模拟的实现方法，仔细看就知道这事阴影不是边框 使用伪类(推荐) 1条border 1234567891011121314.setOnePx&#123; position：relative &amp;::after&#123; position:absolute; content:''; background-color:#e5e5e5; display:block; width:100%; height:1px; transform:scale(1,0.5) top:0; left:0; &#125;&#125; 将伪元素设置相对定位，并且和父元素的左上角对齐，将width设置100%，height设置为1px 然后进行再Y方向缩小0..5倍 4条border 12345678910111213141516.setBorderAll&#123; position:relative; &amp;::after&#123; content::\"\"; position:absolute; top:0; left:0; width:200%; height:200%; transform:scale(0.5); transform-origin:left top; border-sizing:border-box; border:1px solid #e5e5e5; border-radius:4px &#125;&#125; 同样为伪类设置相对定位，并且和父元素左上角对齐，将伪元素的长和宽先放大2倍，然后再设置一个边框，以左上角为中心，缩放到原来的0.5倍 总结：全机型兼容，实现了真正的1px而且可以圆角 缺点：暂用了after伪类，可能影响到清浮动 5.设置viewport 的scale值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;html&gt; &lt;head&gt; &lt;title&gt;1px question&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;meta name=\"viewport\" id=\"WebViewport\" content=\"initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"&gt; &lt;style&gt; html &#123; font-size: 1px; &#125; * &#123; padding: 0; margin: 0; &#125; .top_b &#123; border-bottom: 1px solid #E5E5E5; &#125; .a,.b &#123; box-sizing: border-box; margin-top: 1rem; padding: 1rem; font-size: 1.4rem; &#125; .a &#123; width: 100%; &#125; .b &#123; background: #f5f5f5; width: 100%; &#125; &lt;/style&gt; &lt;script&gt; var viewport = document.querySelector(\"meta[name=viewport]\"); //下面是根据设备像素设置viewport if (window.devicePixelRatio == 1) &#123; viewport.setAttribute('content', 'width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no'); &#125; if (window.devicePixelRatio == 2) &#123; viewport.setAttribute('content', 'width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no'); &#125; if (window.devicePixelRatio == 3) &#123; viewport.setAttribute('content', 'width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no'); &#125; var docEl = document.documentElement; var fontsize = 32* (docEl.clientWidth / 750) + 'px'; docEl.style.fontSize = fontsize; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"top_b a\"&gt;下面的底边宽度是虚拟1像素的&lt;/div&gt; &lt;div class=\"b\"&gt;上面的边框宽度是虚拟1像素的&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 总结 优点：全机型兼容，直接写1px不能喝再方便 缺点：使用新的项目，老项目可能改动大 16. 介绍一下flex布局采用flex布局的元素，成为flex容器，简称“容器”，它的所有子元素自动成为容器成员 当使用flex布局时，会存在两根线即主轴(默认水平)，交叉轴(默认垂直)，默认是主轴排列 容器的属性 flex-direction（决定主轴方向） flex-wrap (决定换行形式） justify-content(定义在周周的对齐方式) align-litems(定义在交叉轴的对齐方式) aligin-content(定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用)","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://blog.liurugang.cn/tags/%E6%80%BB%E7%BB%93/"},{"name":"面试","slug":"面试","permalink":"http://blog.liurugang.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"彻底弄懂JavaScript执行机制","slug":"彻底弄懂JavaScript执行机制","date":"2021-01-31T07:50:42.660Z","updated":"2021-01-31T07:51:37.343Z","comments":true,"path":"posts/46815/","link":"","permalink":"http://blog.liurugang.cn/posts/46815/","excerpt":"","text":"彻底弄懂JavaScript执行机制JavaScript事件循环既然JS是单线程，那就像只有一个窗口的银行，客户需要排队一个个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假设我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面股价和页面元素的渲染。而向加载图片音乐之类占用资源大耗时长的任务，就是异步任务。用导图来说明 导图要表达的内容用文字来表述的话： 同步和异步任务分别进入不同的执行“场所”，同步的进入主线程，异步的进入Event Table 并注册函数 当指定的事情完成时，Event Table会将这个任务移除Event Queue 主任务内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主流程执行 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 说了这么多文字，不如直接一段代码更直白： 123456789let data =[];$.ajax(&#123; url:www.javascript.com, data:data, success:()=&gt;&#123; console.log('发送成功!') &#125;&#125;)console.log('代码执行结束') 上面是一段简单的ajax请求代码: ajax进入Event Table,注册回调函数success 执行console.log(&#39;代码执行结束&#39;) ajax事件完成，回调函数success进入Event Queue 主线程从Event Queue去读回调函数success并执行 setTimeoutsetTimeout大家对他的第一印象就是异步可以执行演示执行，我们经常这么实时延迟3秒执行： 123setTimeout(()=&gt;&#123; console.log('延时3秒')&#125;，3000) 渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3毛，实际却5,6秒才执行函数 先看一下例子： 1234setTimeout(()=&gt;&#123; tesk()&#125;,3000)conosole.log('执行console') 根据前面的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是: 12//执行console//task() 去验证一下，结果正确！然后我们修改一下前面的代码： 123456setTimeout(()=&gt;&#123; setTimeout(()=&gt;&#123; tesk() &#125;,3000)&#125;)sleep(100000) 乍一看其实差不多，但是我们把这段代码在chrome执行一下，却发现控制台执行tesk()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这个长时间呢？ 这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： tesk()进入Event Table并注册计时开始 执行sleep函数，很慢，即使仍在继续 3秒到了，计时事件timeout完成，tesk()进入Event Queue，但是sleep很慢，还没有执行完，只好等着 sleep终于执行完了，tesk()终于从Event Queue 进入了主线程执行 我们还经常遇到setTimeout(fn,0)这样的代码，0秒执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程是最早可得的空闲时间执行，意思是不用等多少秒，只要主线程执行栈内同步任务全部执行完成，栈为空马上执行。举例说明： 12345//代码1console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,0); 12345//代码2console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,3000); 代码1的输出结果是： 12//先执行这里//执行啦 代码2的输出结果是： 123//先执行这里//...3s later//执行啦 setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。 唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。 Promise与process.nextTick(callback)传统的定时器我们已经研究过了，接着我们探究Promise与Process.nextTick(callback)的表现。 除了广义的同步任务和异步任务，我们对任务更精细的定义： macro-task(宏任务)：包括整体代码script，setInterval，setTimemout，setImmediate micro-tesk(微任务): Promise, process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval进入相同的Event Queue 事件循环的顺序，决定JS代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕后，再次执行所有的微任务。我们用文章最开始的一段代码说明: 12345678910setTimeout(function()&#123; console.log('setTimeout')&#125;)new Promise(function(reslove)&#123; console.log('promise')&#125;).then(function()&#123; console.log('then')&#125;)console.log('console') 这段代码作为宏任务，进入主线程 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue. 接下来来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue 遇到console.log()立即执行。 好啦。整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 Ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue 开始。我们发现饿了宏任务 Event Queue中setTimeout对应的回调函数，立即执行 结束 事件循环，宏任务，微任务的关系如图所示 我们来分析一段较为复杂的代码，看看你是否真的掌握了JS的执行机制： 12345678910111213141516171819202122232425262728293031323334353637console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;)//1 7 6 8 2 4 3 5 9 11 10 12 第一轮事件循环流程分析如下: 整体script作为第一个宏任务进入主流程，遇到console.log，输出1 遇到setTimeout，器回调函数被分发到宏任务Event Queue 中。我们暂且记为setTimeout1 遇到Process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为Process1 遇到Promise，new Promise直接执行，输出7，then被分发到微任务Event Queue中。我们记为then1 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2 宏任务 微任务 setTimout1 process1 setTimeout2 then1 上表示第一轮事件宏任务结束时各Event Queue的情况，此时已经输出了1,7 我们发现了process1和then1两个微任务 执行process1，输出6 执行then,输出8 好了，第一轮事件循环正式结束，这一轮的结果是输出1,7,6,8。那么第二轮时间循环从setTimeout1宏任务开始 首先输出2，接下来遇到了process.nextTick()同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2. 宏任务 微任务 setTimeout2 process2 then2 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3 输出5 第二轮事件循环结束，第二轮输出2,4,3,5 第三轮事件循环开始，此时只剩setTimeout2了，执行 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 宏任务 微任务 process3 then3 第三轮事件循环宏任务执行结束，执行两个宏任务process3和then3 输出10 输出12 第三轮事件循环结束，第三轮输出9,11,10,12 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12 总结（1）js的异步 我们从最开头就说JavaScript是一门单线程语言，不管是什么新框架新语法糖实现饿的所谓异步，其实都是用同步的方法去模拟的，牢牢把握单线程这点非常重要。 （2）事件循环 Event Loop 事件循环是JS实现异步的一种方式，也是js的执行机制 （3）JavaScript的执行和运行 执行和运行有很大的区别，JavaScript在不同的环境下，比如node，浏览器等执行的方式是不同的。而运行大多指JavaScript解析引擎，是统一的。 （4）最后的最后 javascript是一门单线程语言 Event Loop是JavaScript的执行机制","categories":[],"tags":[]},{"title":"前端安全问题","slug":"前端安全问题","date":"2021-01-31T02:05:56.049Z","updated":"2021-01-31T02:07:14.338Z","comments":true,"path":"posts/5950/","link":"","permalink":"http://blog.liurugang.cn/posts/5950/","excerpt":"","text":"前端安全问题XSS(跨站脚本攻击)XSS 即跨站脚本攻击，是通过攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或获取用户隐私数据的一种攻击方式。 攻击者对客户端网页注入的恶意脚本一般包括JavaScript，有时也会包含HTML和Flash。有多种方式，但他们的共同点为：将一些隐私数据像cookie，session发送给攻击者，将受害者重定向到一个攻击者控制的网站，在受害者的机器上进行一些恶意操作。 XSS攻击可以分为3类：反射型(非持久型)，存储型(持久性)，基于DOM 反射型反射性xss只是简单地把用户输入的数据“反射”给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意连接(攻击者可以将恶意连接发送给受信任用户，比如将恶意连接插入广告的链接中)，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。最简单的示例是访问一个链接，服务端返回一个可执行的脚本 1234567891011const http = require('http');function handleReequest(req, res) &#123; res.setHeader('Access-Control-Allow-Origin', '*'); res.writeHead(200, &#123;'Content-Type': 'text/html; charset=UTF-8'&#125;); res.write('&lt;script&gt;alert(\"反射型 XSS 攻击\")&lt;/script&gt;'); res.end();&#125;const server = new http.Server();server.listen(8001, '127.0.0.1');server.on('request', handleReequest); 存储型存储型XSS会把用户输入的数据“存储”在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种XSS具有很强的稳定性。比较常见的一个场景是攻击者在社区或论坛上写一篇包含恶意JavaScript代码的文章或者评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码 123// 例如在评论中输入以下留言// 如果请求这段留言的时候服务端不做转义处理，请求之后页面会执行这段恶意代码&lt;script&gt;alert('xss 攻击')&lt;/script&gt; 基于DOM基于DOM的XSS攻击是指通过恶意脚本修改页面的DOM结构，是纯粹发生在客户端的攻击 12345678910111213141516171819&lt;h2&gt;XSS: &lt;/h2&gt;&lt;input type=\"text\" id=\"input\"&gt;&lt;button id=\"btn\"&gt;Submit&lt;/button&gt;&lt;div id=\"div\"&gt;&lt;/div&gt;&lt;script&gt; const input = document.getElementById('input'); const btn = document.getElementById('btn'); const div = document.getElementById('div'); let val; input.addEventListener('change', (e) =&gt; &#123; val = e.target.value; &#125;, false); btn.addEventListener('click', () =&gt; &#123; div.innerHTML = `&lt;a href=$&#123;val&#125;&gt;testLink&lt;/a&gt;` &#125;, false);&lt;/script&gt; 点击Submit按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入构造了如下内容： 1onclick=alert(/xss/) 用户提交之后，页面代码就变成了 1&lt;a href onclick=\"alert(/xss/)\"&gt;testLink&lt;/a&gt; XSS攻击防范HTTPOnly防止劫取Cookie：HTTPOnly浏览器将禁止页面的JavaScript访问带有HTTPOnly属性的Cookie。攻击者可以通过注入恶意脚本获取用户的Cookie信息。通常Cookie中都包含了用户的登录凭证信息，攻击者在获取到Cookie之后，则可以发起Cookie劫持攻击。HTTPOnly并非阻止XSS攻击，而是能阻止XSS攻击后的Cookie劫持攻击。 输入检查：不要相信用户的任何输入。对于用户的任何输入要进行检查，过滤和转义。建立可信任的字符和HTML标签白名单。对于特殊字符进行过滤或转码 输出检查：服务端的输入也会存在问题，一般来说，出富文本的输出外，在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。 CSRF(跨站请求伪造)CSRF即跨站请求伪造，是一种劫持受信任的用户向服务器发送非舆情请求的攻击方式。通常情况下，CSRF攻击是攻击者借助受害者的Cookie骗取服务器的信任，可以在受害者毫不知情的情况下以受害者的名义伪造请求发送给攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。 CSRF攻击使登录用户访问攻击者的网站，发起一个请求，由于Cookie中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起CSRF攻击。 在这个攻击过程中，攻击者借助受害者的Cookie骗取服务端的信任，单兵不能拿到Cookie，也不能看到Cookie的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。 但是攻击者无法从返回的结果中得到任何东西，它所能做到的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。例如删除数据，修改数据等 CSRF攻击防范验证码： 验证码被认为是对抗CSRF攻击最简洁有效的防御方法，CSRF攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能很好的遏制CSRF攻击 添加Token验证：要抵御CSRF，关键在于请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。可以在HTTP请求中以参数的形式添加一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或token内容不正确，则认为可能是CSRF攻击而拒绝请求。","categories":[],"tags":[]},{"title":"Nuxt.js爬坑","slug":"Nuxt.js爬坑","date":"2021-01-30T14:47:22.799Z","updated":"2021-01-30T14:48:01.054Z","comments":true,"path":"posts/25/","link":"","permalink":"http://blog.liurugang.cn/posts/25/","excerpt":"","text":"Nuxt.js爬坑1. NuxtServerError connect ECONNREFUSED 127.0.0.1:80原因：asyncData方法异步请求数据时，以为/api/${params.id}这个接口的网站是127.0.0.1:80，所以请求发送给了127.0.0.1:80，而我的接口服务器并没有跑在80端口上，所以报错 解决方案： 将node服务器端口改为127.0.0.1:80 将接口服务器端口改成 127.0.0.1:80 将asyncData方法请求的url加上域名+端口，如下所示 1234567export default&#123; asyncData(&#123;params&#125;&#123; returm axios.get(`https://127.0.0.1:3000/api/$&#123;params.id&#125;`) .then((res)=&gt;&#123; return &#123;title:res.data.title&#125; &#125;) &#125;)&#125; 2.nuxt使用less，sass等预处理器 背景：在组件中&lt;template&gt;，&lt;script&gt;或&lt;style&gt;上使用各种预处理器，加上处理器后，控制台报错 1npm install --save-dev node-sass sass-loader 但是解决过程并不是很顺利，在阅读中文文档时，忽略版本号，按照上面的提示进行操作，发现不能成功，后来各种debug，最后发现了该解决方案，后知后觉的发现了中文文档，如果需要查看文档，一定要看最新版本的英文文档 3. 如何使用px2rem 背景：在css中，写入px，通过px2rem loader将px转成rem 在以前的项目中，是通过px2rem loader实现的，但是在Nuxt.js项目下，添加css loader还是很费力的，因为涉及到vue-loader 想到了一个其他方案，可以使用postcss处理。可以在nuxt.config.js文件中添加配置，也可以在postcss.conf.js文件中添加。 1234567build:&#123; postcss:[ require('postcss-px2rem')(&#123; remUnit:75 //转换基本单位 &#125;) ]&#125; 4. 如何扩展webpack配置 背景：给utils目录添加别名 刚刚说到，Nuxt.js内置了webpack配置，如果想要扩展配置，可以在nuxt.config.js文件中添加。同时也可以在该文件中，将配置信息打印出来。 123456789extend(config,ctx)&#123; console.log('webpack config',config) if(ctx.isClient)&#123; //添加alias配置 Object.assign(config.resolve.alias,&#123; 'utils'：path.resolve(__dirname,'utils') &#125;) &#125;&#125; 5. 如何添加vue plugin 背景：自己封装了一个toast vue plugin,由于vue实例化的过程没有暴露出来，不知道在哪个时机注入进去 可以在nuxt.config.js中添加plugins配置，这样插件就会在Nuxt.js应用初始化之前被加载导入 123mudule.exports=&#123; plugins:['~plugins/toast']&#125; ~plugins/toast.js文件 12345import Vue from 'vue'import toast from '../utils/toast'import '..assets/css/toast.css'Vue.use(toast) 6. 如何修改环境变量NODE_ENV 背景：在项目中，设置3个NODE_ENV的值，来对应不同的版本。development，本地开发；release,预发布版本；production，线上版本。其中，预发布版本比production版本，多出，vconsole 12345//package.json\"script\":&#123; \"buildDev\"：\"cross-env NODE_ENV=release nuxt build &amp;&amp; backpack build\", \"startDev\": \"cross-env NODE_ENV=release PORT=3000 node build/main.js\"&#125; 打印process.env.NODE_ENV依旧是，production. 在backpack的源码中，找到了答案，在执行backpack build命令是会把process.env.NODE_ENV修改为production，并且是写死的不可配置的.. 无奈之下，只能在process.env下，添加__ENV属性，代表NODE_ENV 这时，在页面中打印出来的信息process.env.ENV undefined，但是可以打印出来process.env.NODE_ENV 可以通过配置nuxt.config.js中的env属性，解决该问题 123env:&#123; __ENV:process.env.__ENV&#125; 7. window或document对象未定义？ 背景：在引入第三方插件，或者直接在代码中写window时，控制台会发出警告，window为定义 发生这个问题的原因时，node服务端并没有window或document对象。解决方法，通过process.browser来区分环境 123456if(process.browser)&#123; //引入第三方插件 require('!***') //或者修改window对象下的某一属性 window.mdk=&#123;&#125;&#125; 8. nuxt必须在接口地址前加上访问域名解决：可以使用axios的baseURL来代理 123456import Vue from 'vue'import axios from 'axios'axios.defaults.baseURL =\"http://localhost:3000/\"export default axios 9. 不想服务端渲染的地方12345678(1)&lt;no-ssr&gt;插件或组件&lt;&#x2F;no-ssr&gt;（2）nuxt.config.js里ssr该成falseplugins:[ &#123;src:&#39;~plugins&#x2F;ElementUI&#39;，ssr:false&#125;] 10. 按需引入(UI框架等等)例如使用UI框架：element-ui 先看下，如果不按需引入vendor.js的体积大小为： 第一步，下载依赖 1234//先下载element—uinpm install element-ui --save//如果使用按需引入，必须安装babel-plugin-componentnpm install babel-plugin-component --save-dev 安装好以后，按照nuxt.js中的规则，你需要在plugins/目录下创建相关插件文件 在文件根目录创建plugins/目录，创建名为element-ui.js的文件，内容如下 12345import Vue from 'vue'import &#123;Button&#125; from 'element-ui'export default （）=&gt;&#123; Vue.use(Button)&#125; 第二步，引入插件 在nuxt-config.js中添加配置为：plugins 123456789css:[ 'element-ui/lib/theme-chalk/index.css'], plugins:[ &#123; src:'~/plugins/element-ui', ssr:false //关闭ssr &#125; ] 第三步，配置babel选项 在nuxt.config.js中，配置在build选项中，规则为官网规则： 123456789101112131415161718192021222324build:&#123; babel:&#123; \"plugins\":[ [ \"component\", &#123; \"librayName\":\"element-ui\", \"styleLibrayName\"：\"theme-chalk\" &#125; ] ] &#125;&#125;, extend (config, ctx) &#123; if (ctx.isClient) &#123; config.module.rules.push(&#123; enforce: 'pre', test: /\\.(js|vue)$/, loader: 'eslint-loader', exclude: /(node_modules)/ &#125;) &#125; &#125; &#125; 此时，我们再观察打包以后文件体积大小，如图： 此时，我们成功完成了按需引入配置","categories":[],"tags":[]},{"title":"Nuxt.js介绍","slug":"Nuxt.js介绍","date":"2021-01-30T13:33:47.604Z","updated":"2021-01-30T14:48:01.058Z","comments":true,"path":"posts/60077/","link":"","permalink":"http://blog.liurugang.cn/posts/60077/","excerpt":"","text":"Nuxt爬坑第一节：nuxt.js相关概述nuxt.js简单的说是Vue.js的通用框架，最常用的就是用来做SSR(服务端渲染)，Vue.js是开发SPA(单页应用)的，Nuxt.js这个框架，用Vue开发多页应用，并在服务端完成渲染，可以直接用命令把我们制作的vue项目生成为静态html 1. 那服务器端渲染到底有什么好处？主要的原因是SPA(单页应用)不利于搜素引擎的SEO操作，Nuxt.js适合做新闻，博客，电影，资讯这样的需要搜索引擎提供流量的项目。如果你要做移动端的项目，就没必要使用这个框架了。 2. 什么是SSR?在认识SSR之间，首先对CSR与SSR之间做个对比、 首先看一下传统的web开发，传统的web开发是，客户端向服务端发送请求，服务端查询数据库，拼接HTML字符串(模板)，通过一系列的数据处理之后，把整理好的HTML返回给客户端，浏览器相当于打开了一个页面，这种比如我们经常听说过的jsp，PHP,aspx也是传统的MVC的开发。 SPA应用，到了Vue，React，单页应用优秀的用户体验，逐渐成为了主流，页面整体式javascript渲染出来的，称之为客户端渲染CSR。SPA渲染过程。由客户端访问URL发送请求到服务端，返回HTML结构。客户端接收到了返回结果之后，在客户端开始渲染HTML，渲染时执行对应javascript最后渲染template，渲染完成之后，再次向服务端发送数据请求，注意这里时数据请求，服务端返回json格式数据。客户端接收数据，然后完成最后渲染。 SPA虽然给服务器减轻了压力，但是也是有缺点的： 首屏渲染时间比较长；必须等待javascript加载完毕，并且执行完毕，才能渲染出首屏。 SEO不友好：爬虫只能拿到一个div元素，认为页面是空的，不利用SEO 为了解决如下两个问题，出现了SSR解决方案，后端渲染出首屏的DOM结构返回，前端首先拿到内容带上首屏，后续的页面操作，再用单页路由和渲染，称之为服务端渲染（SSR）。 SSR渲染流程时这样的，客户端发送URL请求到服务端，服务端读取对应的URL的模板信息，在服务端做出html和数据的渲染，渲染完成之后返回html结构，客户端这是拿到的之后首屏页面的html结构。所以用户在浏览器首屏的时候速度会很快，因为客户端不需要再次发送ajax请求。并不是做了SSR我们的页面就不属于SPA应用了，它仍然是一个独立的SPA应用。 SSR是处于CSR与SPA应用之间的一个折中的方案，在渲染首屏的时候再服务端做出了渲染，注意仅仅是首屏，其他页面还是需要在客户端渲染的，在服务端接收请求之后并且渲染出首屏页面，会携带着剩余的路由信息预留给客户端去渲染其他路由的页面。 Nuxt.js的特点(优点)： 基于Vue 自动代码分层 服务端渲染 强大的路由功能，支持异步数据 静态文件服务 ECMAScript6和ECMAScript7的语法支持 打包和压缩javascript和css HTML头部标签管理 本地开发支持热加载 集成ESLint 支持各种样式预编译器SASS,LESS等等 支持HTTP/2推送 第二节：Nuxt环境搭建1. Nuxt.js安装在使用npm前你需要先安装Node到系统中 （1） 用npm来安装vue-cli这个框架 1npm install vue-cli -g 安装完成后使用vue -V 来测试是否安装成功。 （2）使用vue安装nuxt安装好vue-cli后，就可以使用init命令来初始化Nuxt.js项目 1vue init nuxt/starter (3) 使用npm install来安装依赖包 1npm install 这个过程是要等一会的，如果你这个安装失败，可以直接删除项目中的node_modules文件夹后，重新npm install进行安装 （4）使用npm run dev启动服务 （5）在浏览器输入localhost:3000，可以看到结果如下： 2. 第一个Nuxt应用程序安装1234npm i create-nuxt-app -gcreate-nuxt-app my-nuxt-democd my-nuxt-demonpm run dev 安装向导 123456789Project name // 项目名称Project description // 项目描述Use a custom server framework // 选择服务器框架Choose features to install // 选择安装的特性Use a custom UI framework // 选择UI框架Use a custom test framework // 测试框架Choose rendering mode // 渲染模式Universal // 渲染所有连接页面Single Page App // 只渲染当前页面 3. Nuxt渲染流程一个完整的服务器请求到渲染的流程 通过上面的流程图可以看出，当一个客户端请求进入的时候，服务端有通过nuxtServerInit这个命令在Store的action中，在这里接收到客户端请求的时候，可以将一些客户端信息存储到Store中，也就是说可以把服务端存储的一些客户端的一些登录信息存储到Store中。之后使用了中间件机制，中间件其实就是一个函数，会在每个路由执行之前去执行，在这里可以做很多事情，或者说可以理解为是路由器的拦截器的作用。然后再validate执行的时候对客户端携带的参数进行效验，在asyncData与fetch进入正式的渲染周期，asyncData向服务端获取数据，把请求到的数据合并到Vue中的data中 第三节：Nuxt目录结构目录结构介绍123456789101112131415161718└─my-nuxt-demo ├─.nuxt // Nuxt自动生成，临时的用于编辑的文件，build ├─assets // 用于组织未编译的静态资源如LESS、SASS或JavaScript,对于不需要通过 Webpack 处理的静态资源文件，可以放置在 static 目录中 ├─components // 用于自己编写的Vue组件，比如日历组件、分页组件 ├─layouts // 布局目录，用于组织应用的布局组件，不可更改⭐ ├─middleware // 用于存放中间件 ├─node_modules ├─pages // 用于组织应用的路由及视图,Nuxt.js根据该目录结构自动生成对应的路由配置，文件名不可更改⭐ ├─plugins // 用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。 ├─static // 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。 服务器启动的时候，该目录下的文件会映射至应用的根路径 / 下。文件夹名不可更改。⭐ └─store // 用于组织应用的Vuex 状态管理。文件夹名不可更改。⭐ ├─.editorconfig // 开发工具格式配置 ├─.eslintrc.js // ESLint的配置文件，用于检查代码格式 ├─.gitignore // 配置git忽略文件 ├─nuxt.config.js // 用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。文件名不可更改。⭐ ├─package-lock.json // npm自动生成，用于帮助package的统一设置的，yarn也有相同的操作 ├─package.json // npm 包管理配置文件 ├─README.md 配置文件12345678910111213141516171819202122232425262728293031const pkg = require('./package')module.exports = &#123; mode: 'universal', // 当前渲染使用模式 head: &#123; // 页面head配置信息 title: pkg.name, // title meta: [ // meat &#123; charset: 'utf-8' &#125;, &#123; name: 'viewport', content: 'width=device-width, initial-scale=1' &#125;, &#123; hid: 'description', name: 'description', content: pkg.description &#125; ], link: [ // favicon，若引用css不会进行打包处理 &#123; rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' &#125; ] &#125;, loading: &#123; color: '#fff' &#125;, // 页面进度条 css: [ // 全局css（会进行webpack打包处理） 'element-ui/lib/theme-chalk/index.css' ], plugins: [ // 插件 '@/plugins/element-ui' ], modules: [ // 模块 '@nuxtjs/axios', ], axios: &#123;&#125;, build: &#123; // 打包 transpile: [/^element-ui/], extend(config, ctx) &#123; // webpack自定义配置 &#125; &#125;&#125; Nuxt运行命令123456789101112&#123; \"scripts\": &#123; // 开发环境 \"dev\": \"cross-env NODE_ENV=development nodemon server/index.js --watch server\", // 打包 \"build\": \"nuxt build\", // 在服务端运行 \"start\": \"cross-env NODE_ENV=production node server/index.js\", // 生成静态页面 \"generate\": \"nuxt generate\" &#125;&#125; 第四节： Nuxt常用配置项1. 配置IP和端口开发中经常会遇到端口占用或指定IP的情况，我们需要在根目录下的package.json里对config项进行配置。比如现在我们想把IP配置成127.0.0.1，端口设置1000 123456\"config\":&#123; \"nuxt\":&#123; \"host\":'127.0.0.1', \"port\":\"1000\" &#125;&#125; 配置好后，我们在终端输入npm run dev，然后你就会看到服务地址改为了127.0.0.1:1000 2. 配置全局CSS在开发多页项目时，都会定义一个全局的CSS来初始化我们的页面渲染，比如把padding和margin设置成0，网上有非常出名的开源css文件normalize.css。要定义这些配置，需要在nuxt.config.js里进行操作。 比如现在我们要把页面字体设置为红色，就可以在assets/css/common.css文件，然后把字体设置为红色。 /assets/css/common.css 123html&#123; color:red&#125; /nuxt.config.js 1css:['~assets/css/normalize.css'] 设置好后，在终端输入npm run dev然后你会发现字体已经变成了红色 3. 配置webpack的loader在nuxt.config.js里可以对webpack的基本配置进行覆盖的，比如现在我们要配置衣蛾url-loader进行小图片的64位打包。就可以在nuxt.config.js的build选项里进行配置， 12345678910111213141516171819202122232425build: &#123; loaders:[ &#123; test:/\\.(png|jpe?g|gif|svg)$/, loader:\"url-loader\", query:&#123; limit:10000, name:'img/[name].[hash].[ext]' &#125; &#125; ], /* ** Run ESLint on save */ extend (config, &#123; isDev, isClient &#125;) &#123; if (isDev &amp;&amp; isClient) &#123; config.module.rules.push(&#123; enforce: 'pre', test: /\\.(js|vue)$/, loader: 'eslint-loader', exclude: /(node_modules)/ &#125;) &#125; &#125; &#125; 4. 全局修改seo的head信息nuxt.config文件中，修改title为wfaceboss： 1234567891011head&#123; title: 'wfaceboss', meta: [ &#123; charset: 'utf-8' &#125;, &#123; name: 'viewport', content: 'width=device-width, initial-scale=1' &#125;, &#123; hid: 'description', name: 'description', content: 'Nuxt.js project' &#125; ], link: [ &#123; rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' &#125; ]&#125; 修改后重启服务，即运行npm run dev交过如下 第五节： Nuxt的路由配置和参数传递Nuxt.js的路由并不复杂，它给我们进行了封装，让我们节省了很多配置环节 1. 基本路由Nuxt.js依据pages目录结构自动生成vue-router模块的路由配置 假设pages的目录如下 12345└─pages ├─index.vue └─user ├─index.vue ├─one.vue 那么，Nuxt.js自动生成的路由配置如下： 123456789101112131415161718router:&#123; routes:[ &#123; name:'index', path:'/', component:'pages/index.vue' &#125;, &#123; name:'user', path:'/user', component:'pages/user/index.vue' &#125;,&#123; name:'user-one', path：'/user/one', component：'pages/user/one.vue' &#125; ]&#125; 2. 页面跳转 不要写成a标签，因为是重新获取一个新的页面，并不是SPA &lt;nuxt-link to=&quot;/users&quot;&gt;&lt;/nuxt-link&gt; this.$router.push(&#39;/users&#39;) 3.动态路由 在Nuxt.js里面定义带参数的动态路由，需要创建对应的以下划线作为前缀的Vue文件或目录 获取动态参数 4. 跳转路由传递参数并且取值路由进化出那个需要传递参数，我们可以简单的使用params来进行传递参数，我们现在向新闻页面(news)传递个参数，然后在新闻页面进行简单的接收 (1 ) 使用nuxt传递参数 1234567&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;nuxt-link to&#x3D;&quot;&#96;informa&#x2F;$&#123;item.newsCode&#125;-$&#123;item.newType&#125;&#96;&quot;&gt;&lt;&#x2F;nuxt-link&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 注意：name其实指向的是路由，而路由区分大小写，所有to后面区分大小写，建议文件夹都写成小写 （2） 使用nuxt接收参数 1234async asyncData(context)&#123; let newsCode =context.route.params.code.split('-')[0] let newsType = context.route.parmas.code.split('-')[1]&#125; (3) 使用this.$router.push的params传递参数 传递参数： 1this.$router.push(&#123;path:'路由',query:&#123;key:value&#125;&#125;) 参数取值 1this.$router.query.key 5. 路由参数校验nuxt.js可以让你在动态路由对应的页面组件中配置一个validate方法用于效验动态路由参数的有效性。该函数有一个布尔类型的返回值，如果返回true则表示效验通过，如果返回false则表示效验未通过 12345export default&#123; validate(obj)&#123; return /^\\d+$/.test(obj.params.id) &#125;&#125; 6. 嵌套路由 添加一个Vue文件作为父组件 添加一个与父组件同名的文件夹存放子视图组件 在父文件中，添加组件，用于展示匹配到的子视图 第六节：Nuxt的路由动画效果路由的动画效果，也叫做页面的更换效果。Nuxt.js提供两种方法为路由提供动画效果，一种是全局的，一种是针对单独页面制作。 1. 全局路由动画全局动画默认使用page来进行设置，例如现在我们为每个页面都设置一个进入和退出时的渐隐渐现的效果。我们可以现在根目录的assets/css下建立一个normalize.css文件 （1）添加样式文件 /assets/css/normalize.css 123456.page-enter-active, .page-leave-active&#123; transition: opacity 2s&#125;.pgae-enter, .page-leave-active&#123; opacity: 0&#125; (2) 文件配置 然后在nuxt.config.js里加入一个全局的css文件就可以了 1css:['assets/css/main.css'] 这时候在页面切换的时候就会有2秒钟的动画切换效果了，但是你会发现一些页面是没有效果的，这是因为你没有是&lt;nuxt-link&gt;组件来制作跳转连接，你需要进行更改 比如我们上节课做得动态路由新闻页，你就需要改成下面的连接 1&lt;li&gt;&lt;nuxt-link :to=\"&#123;name:'new-id',params:&#123;id:123&#125;&#125;\"&gt;&lt;/nuxt-link&gt;&lt;/li&gt; 改完之后你就可以看到动画效果了 2. 单独设置页面动效相给一个页面单独设置特殊的效果时，我们只要在css里改变默认的page，然后在页面组件的配置中加入transition字段即可。例如，我们想要给about页面加入一个字体放大然后缩小的效果，其他页面没有这个效果 (1) 在全局样式assets/main.css中添加以下内容 12345678.test-enter-active,.test-leave-active&#123; transition:all 2s; font-size:12px;&#125;.test-enter,.test-leave-active&#123; opacity:0; font-size:40px;&#125; (2) 然后在about/index.vue组件中设置 123export default&#123; transition:'test'&#125; 这时候就有了页面切换独特动效了 总结：在需要使用的页面导入即可。 第七节：Nuxt的默认模板和默认布局在开发应用时，经常会用到一些公用的元素，比如网页的标题是一样的，每个页面都是一模一样的标题。这时候我们有两种方法，第一种方法是作一个公用的组件出来，第二种方法是修改默认模板。这两种方法各有利弊，比如公用组件更叫灵活，但是每次都需要我们动手引入；模板比较方便，但是只能每个页面都引入。 1. 默认模板Nuxt为我们提供了超简单的默认模板定制方法，只要在根目录下创建一个app.html就可以实现了。现在我们希望每个页面的最上面都加入“学习nuxt.js”这几个字，我们就可以使用模板来完成 app.html中： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &#123;&#123;HEAD&#125;&#125; &lt;/head&gt; &lt;body&gt; &lt;p&gt;学习nuxt.js&lt;/p&gt; &#123;&#123;APP&#125;&#125; &lt;/body&gt;&lt;/html&gt; 这里的读取的是nuxt.config.js里的消息，就是我们写的apges文件夹下的主体页面了。需要注意的是HEAD和APP都需要大写，如果小写会报错的 注意：如果你建立了默认模板后，记得要重启服务器，否则显示不会成功；但是默认布局是不用重启服务器的。 2. 默认布局默认模板类似的功能还有默认布局，但是从名字上可以看出，默认布局主要针对对于页面的统一布局使用。它在位置根目录下的layouts/default.vue需要注意的是在默认布局里不要加入头部信息，知识关于&lt;template&gt;标签下的内容统一定制。 需求：我们在每个页面的最顶部放入“学习nuxt.js”这几个字，看一下在默认布局开的实现。 12345678&lt;template&gt; &lt;div&gt; &lt;p&gt; 学习nuxt.js &lt;/p&gt; &lt;nuxt&gt;&lt;/nuxt&gt; &lt;/div&gt;&lt;/template&gt; 这里的&lt;nuxt/&gt;就相当于我们每个页面的内容，你也可以把一些通过那个样式放在这个默认布局里，但这会增加页面的复杂程度。 总结：要区分默认模板和默认布局的区别,模板可以定制很多头部信息，包括IE版本的判断；模板只能定制&lt;template&gt;里的内容，根布局有关系。在工作中修改时要看情况来编写代码 第八节：Nuxt插件的使用1. ElementUI使用 下载npm i element-ui -S 在plugins文件夹下面创建ElementUI.js文件 123import Vue from 'vue'import ElementUI from 'element-ui'Vue.use(ElementUI) 在nuxt.config.js中添加配置 123456789css: [ 'element-ui/lib/theme-chalk/index.css'],plugins:[ &#123;src:'~/plugins/ElementUI',ssr:true&#125;], build:&#123; vendor:['element-ui'] &#125; 2. axios的使用 安装npm install --save axios 使用 123456789import axios from 'axios'asyncData(context,callback)&#123; axios.get('http://localhost:3301/in_theaters') .then(res=&gt;&#123; console.log(res) callback(null,&#123;list:res.data&#125;) &#125;)&#125; 为了防止重复打包，在nuxt.config.js中配置 12345module.exports =&#123; build:&#123; vendor:['axios'] &#125;&#125; 第九节： Nuxt的错误页面和个性meta设置当用户输入路由错误的时候，我们需要给他一个明确的指引，所以说在应用程序开发中404页面必不可少的，Nuxt.js支持在默认布局文件夹里建立错误页面 1. 建立错误页面在根目录的layouts文件夹下建立一个error.vue文件，它相当于一个显示应用错误的组件。 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h2 v-if&#x3D;&quot;error.statusCode&#x3D;&#x3D;404&quot;&gt;404页面不存在&lt;&#x2F;h2&gt; &lt;h2 v-else&gt;500服务器错误&lt;&#x2F;h2&gt; &lt;ul&gt; &lt;li&gt;&lt;nuxt-link to&#x3D;&quot;&#x2F;&quot;&gt;HOME&lt;&#x2F;nuxt-link&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props:[&#39;error&#39;],&#125;&lt;&#x2F;script&gt; 代码用v-if进行判断错误类型，需要注意的是这个错误时你需要在&lt;script&gt;里进行声明的，如果不声明程序是找不到err.statusCode的。 这里我也用一个&lt;nuxt-link&gt;的简单写法直接根上路径就可以了。 2. 个性meta设置页面的Meta对于SEO的设置非常重要，比如你现在要做个新闻页面，那为了搜索引擎对新闻的收录，需要每个页面对新闻都有不同的title和meta设置。直接使用head方法来设置头部信息就可以了。我们现在要把New-1这个页面设置成个性的meta和title 我们先把pages/news/index.vue页面的链接进行修改一下，传入一个title，目的是为了在新闻具体页面进行接收title，形成文章的标题。 /pages/news/index.vue 1&lt;li&gt;&lt;nuxt-link :to=\"&#123;name:'news-id',params:&#123;id:123,title:'nuxt.com'&#125;&#125;\"&gt;News-1&lt;/nuxt-link&gt;&lt;/li&gt; 第一步完成后，我们修改/pages/news/_id.vue，让它根据传递值编程独特的meta和title标签。 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt; &lt;h2&gt; News-Content [&#123;&#123;$route.params.id&#125;&#125;] &lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; validate(&#123;params&#125;)&#123; //必须是一个数字 return /^\\d+$/.test(params.id) &#125;， data()&#123; return&#123; title:this.$router.params.title &#125; &#125;, //独立设置head消息 head()&#123; return &#123; title:this.title, meta：[ &#123; hid:'description', name:'news', content:'This is news page' &#125; ] &#125; &#125; &#125;&lt;/script&gt; 注意：为了避免子组件中的meta标签不能正确覆盖父组件中相同的标签而产生重复的现象，建议利用hid键为meta标签配一个唯一的标示编号。 第十节：asyncData方法获取数据Nuxt.js贴心的为我们扩展了Vue.js的方法，增加了asyncData，异步请求数据 1. 造假数据（1）创建远程数据 在这里制作一些假的远程数据，我选择的网站是myjson.com。它是一个json的简单仓库，学习使用非常适合的。我们打开网站，在对话空中输入json代码。这个代码可以随意输入，key和value均采用字符串格式创建 12345&#123; \"name\":\"nuxt\", \"age\":18, \"interest\":\"I love coding!\" &#125; 输入后保存，网站会给你一个地址，这就是你这个json仓库的地址了. （2）安装Axios Vue.js官方推荐使用的远程数据方式就是Axios，所以我们安装官方推荐，来使用Axios。这里我们使用npm来安装axios。直接在终端中输入下面的命令 1npm install axios --save 2. asyncData的promise方法我们在pages下面新建一个文件，叫做asyncData.vue。然后写入下面的代码： 1234567891011121314151617&lt;script&gt;import axios from 'axios' export default&#123; data()&#123; return &#123; name:'hello world' &#125; &#125;, asyncData()&#123; return axios.get('https://api.myjson.com/bins/1ctwlm') .then((res)=&gt;&#123; console.log(res) return &#123;info:res.data&#125; &#125;) &#125; &#125;&lt;/script&gt; 这时候我们可以看到，浏览器中已经能输出结果了，asyncData的方法会把值返回到data中。是组件创建(页面渲染)之前的动作，所以不能使用this.info 一定要return出去获取到的对象，这样就可以在组件中使用，这里返回的数据会和组件中的data合并。这个函数不光在服务端会执行，在客户端同样也会执行。 3. asyncData的promise并发应用1234567891011121314151617181920212223242526async asyncData(context) &#123; let [newDetailRes, hotInformationRes, correlationRes] = await Promise.all([ axios.post('http://www.huanjingwuyou.com/eia/news/detail', &#123; newsCode: newsCode &#125;), axios.post('http://www.huanjingwuyou.com/eia/news/select', &#123; newsType: newsType, // 资讯类型： 3环评资讯 4环评知识 start: 0, // 从第0条开始 pageSize: 10, newsRecommend: true &#125;), axios.post('http://www.huanjingwuyou.com/eia/news/select', &#123; newsType: newsType, // 资讯类型： 3环评资讯 4环评知识 start: 0, // 从第0条开始 pageSize: 3, newsRecommend: false &#125;) ]) return &#123; newDetailList: newDetailRes.data.result, hotNewList: hotInformationRes.data.result.data, newsList: correlationRes.data.result.data, newsCode: newsCode, newsType: newsType &#125;&#125;, 4. asyncData的await方法现在都在用async…await来解决异步改写上面的代码 1234567891011121314&lt;script&gt;import axios from 'axios' export default&#123; data()&#123; return&#123; name:'hello world' &#125; &#125;, async asyncData()&#123; let &#123;data&#125; =await axios.get('https://api.myjson.com/bins/8gdmr') return &#123;info:data&#125; &#125; &#125;&lt;/script&gt; 5. 注意事项+生命周期 asyncData方法会在组件(限于页面组件)每次加载之前被调用 asyncData可以在服务端或路由更新之前被调用 第一个参数被设定为当前页面的上下文对象 Nuxt会将asyncData返回的数据融合到组件的data方法返回的数据一并返回给组件使用 对于asyncData方式是在组件实例化前被调用的，所以在方法内饰没办法通过this引用组件的实例对象 第十一节：静态资源和打包1. 静态资源123(1)静态引入图片在网上任意下载一个图片，放到项目中的static文件夹下面，然后可以使用下面的引入方法进行引用&lt;div&gt;&lt;img src&#x3D;&quot;~static&#x2F;logo.png&quot; &#x2F;&gt;&lt;&#x2F;div&gt; “~”就相当于定位到了项目根目录，这时候图片路径就不会出现错误，就算打包也是正常的。 12（2）CSS引入图片如果在CSS中引入图片，方法和html中直接引入是一样的，也是用“~”符号引入。 1234567&lt;style&gt; .diss&#123; width:300px; height:100px; background-image:url('~static/logo.png') &#125;&lt;/style&gt; 这时候在npm run deb下完全正常的 2. 打包用Nuxt.js制作完成后，你可以打包成静态文件并放在服务器上，进行运行。 在终端中输入： 1npm run generate 然后在dist文件夹下输入live-server基于可以了 总结：Nuxt.js框架非常简单，因为大部分的事情它都为我们做好了，我们只要安装它的规则来编写代码","categories":[],"tags":[]},{"title":"Vue面试题","slug":"Vue面试题","date":"2021-01-29T15:57:13.708Z","updated":"2021-01-29T16:32:01.055Z","comments":true,"path":"posts/719/","link":"","permalink":"http://blog.liurugang.cn/posts/719/","excerpt":"","text":"Vue面试题1. 说说你对SPA单页面的理解，它的优缺点分别是什么？SPA仅在Web页面初始化时加载相应的HTML，JavaScript和CSS。一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现HTML内容的变化，UI与用户的交互，避免页面的重新加载 优点： 用户体验好，快，内容的改变不需要重新加载整个页面，避免可不必要的跳转和重复渲染 SPA对服务器压力小 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理 缺点： 初次加载耗时多；为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript，css统一加载，部分页面按需加载 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理 SEO难度大；由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势 2. v-show 和v-if有什么区别v-if是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；如果在初始化渲染时条件为假，则什么都不做——-知道条件第一次变为真时，才会开始渲染条件块。 v-show就简单得多—–不管初始化条件是什么，元素总是会被渲染，并且只是简单地基于CSS的“display”属性进行切换 所以，v-if适用于运行时很少改变条件，不需要频繁切换条件的场景；v-show则适用于需要非常频繁切换条件的场景 3.class与style如何动态绑定class可以通过对象语法和数组语法进行动态绑定： 对象语法： 123456&lt;div v-bind：class&#x3D;”&#123;active:isActive,&#39;text-danger&#39;:hasError&#125;“&gt;&lt;&#x2F;div&gt;data:&#123; isActive:true, hasError:false&#125; 数组语法 123456&lt;div v-bind:class&#x3D;&quot;[isActive?activeClass:&#39;&#39;,errorClass]&quot;&gt;&lt;&#x2F;div&gt;data:&#123; activeClass:&#39;active&#39;, errorClass:&#39;text-danger&#39;&#125; style也可以通过语法和数组语法进行动态绑定 对象语法 123456&lt;div v-bind:style&#x3D;&quot;&#123;color:activeColor,fontSize:fontSize+&#39;px&#39;&#125;&quot;&gt; data:&#123; activeColor:&#39;red&#39;, fontSize:30 &#125; 数组语法 123456789&lt;div v-bind&#x3D;&quot;[styleColor,styleSize]&quot;&gt;&lt;&#x2F;div&gt;data:&#123; styleColor:&#123; color:&#39;red&#39; &#125;, styleSize:&#123; fontSize:&#39;23px&#39; &#125; &#125; 4. 怎样理解Vue的单向数据流所有的prop都使得其父子prop之间形成了一个单向下行绑定：父级prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父组件的状态，从而导致你的应用的数据流向难以理解。 每次父级组件发生更新时，子组件中所有的prop都会刷新为最新的值，这意味着你不应该在一个子组件内部改变prop。如果你这样做了，Vue会在浏览器的控制台中发生警告。子组件想修改时，只能通过$emit派发一个自定义事件，父组件接收到后，有父组件修改。 有两种常见的视图改变一个prop的情景 这个prop用来传递一个初始值；这个子组件接下来希望将作为一个本地饿的prop数据来使用。在这种情况下，最好定义一个本地的data属性，并将这个prop用作其初始化值： 12345props:['initialCounter'],data:function()&#123; counter: this.initialCounter &#125;&#125; 这个prop以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个prop的值来定义一个计算属性 123456prop:['size'],computed:&#123; normalizedSize:function()&#123; return this.size.trim().toLowerCase() &#125;&#125; 5. computed和watch的区别和运用场景computed：是计算属性，依赖其他属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值 watch:更多的是观察的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作： 运用场景： 当我们需要进行数值计算，并且依赖于其他数据时，应该使用computed，因为可以利用computed的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，这些都是计算属性无法做到的 6. 直接给一个数组项赋值，Vue能检测到变化吗？由于JavaScript的限制，Vue不能检测到一下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem]=newValue 当你修改数组的长度时，例如:vm.items.length=newLength 为了解决第一个问题，Vue提供了以下操作方法： 12345Vue.set(vm.items,indexOfItem,newValue)Vue.$set(vm.items,indexOfItem,newValue)vm.items.splice(indexOfItem,newValue) 为了解决第二个问题，Vue提供了以下操作方法： 1vm.items.splice(newLength) 7. 谈谈你对Vue生命周期的理解 生命周期 Vue实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模板，挂载DOM，渲染，更新 —&gt;渲染，卸载等一系列过程，我们称这是Vue的生命周期。 各个生命周期的作用 beforeCreate 组件实例被创建之初，组件的属性生效之前 created 组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用 beforeMount 在挂载开始之前被调用；相关的render函数首次被调用 mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子 beforeUpdate 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前 update 组件数据更新之后 activited keep-alive 专属，组件被激活时调用 deactivated keep-alive 专属，组件被销毁时调用 beforeDestory 组件销毁前调用 destoryed 组件销毁后调用 8. Vue的父组件和子组件生命周期钩子函数执行顺序Vue的父组件和子组件生命周期钩子函数执行顺序可以归为4个部分 加载渲染过程 父beforeCreate –&gt;父created –&gt;父beforeMount -&gt;子beforeCreate –&gt;子 created —&gt;子beforeMount –&gt;子mounted –&gt;父 mounted 子组件更新过程 ​ 父beforeUpdate –&gt; 子beforeUpdate –&gt;子updated —&gt;父updated 销毁过程 ​ 父beforeDestory —&gt;子beforeDestory —&gt;子destoryed –&gt;父destoryed 9. 在哪个生命周期内调用异步请求？可以在钩子函数created，beforeMounted，mounted中进行调用，因为这三个钩子中data已经被创建，可以将服务端返回的数据进行赋值，但是本人推荐在created钩子中调用异步请求，因为在created钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面loading时间 ssr不支持beforeMount，mounted钩子函数，所以放在created有助于一致性 10. 在什么阶段才能访问操作DOM在钩子函数mounted被调用前，Vue已经将编译好的模板挂载到页面上，所以在mounted中可以访问操作DOM。Vue具体的生命周期可以参考下图 11. 父组件可以监听到子组件的生命周期吗？比如有父组件Parent和子组件Child，如过父组件监听到子组件挂载mounted就做一些逻辑处理，可以通过以下写法实现： 1234567//parent.vue&lt;child @mounted=\"dosomething\"&gt; //child vuemounted()&#123; this.$emit(\"mounted\");&#125; 以上需要手动通过$emit触发父组件的事件，更简单的方式可以在父组件引用子组件时通过@hook来监听即可，如下所示： 1234567891011&#x2F;&#x2F;parent.vue&lt;Child @hook:mounted&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;child&gt;doSomething()&#123; console.log(&#39;父组件监听mounted钩子函数...&#39;)&#125;&#x2F;&#x2F;child.vuemounted()&#123; console.log(&#96;子组件触发mounted钩子函数...&#96;)&#125; 当然@hook方法不仅仅可以监听的是mounted，其他的生命周期事件，例如：created,updated等都可以监听 12. 谈谈你对keep-alive的了解？keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，避免重新渲染，器有以下特性： 一般结合路由和动态组件一起使用，用于缓存组件； 提供include和exclude属性，两者都支持字符串或正则表达式，include表示只有名称匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会被缓存，其中exclude的优先级比include高 对应两个钩子函数actived和deactived，当组件被激活时，触发钩子函数activated，当组件被移除时，触发钩子函数和deactived 13.组件中data为什么是一个函数? 为什么组件中的data必须是一个函数，然而return一个对象，而new Vue实例里，data可以直接是一个对象？ 1234567891011121314//datadata()&#123; return &#123; message:'子组件', childName:this.name &#125;&#125;//new Vuenew Vue(&#123; el:'#app', router, tempate:'&lt;App/&gt;', components:&#123;App&#125;&#125;) 因为组件是用来复用的，而JS里对象是引用关系，如果组件中data是一个对象，那么这样作用域没有隔离，子组件中的data属性值会相互影响，如果组件中data选项时一个函数，那么每个实例可以维护一个被返回对象的独立拷贝，组件实例之间的data属性不会相互影响；而new Vue的实例，是不会被复用的，因此不存在引用对象的问题 14. v-model原理我们在vue项目中主要使用v-model指令在表单input，textarea，select等元素上，创建双向数据绑定，我们知道 v-model本质上不过是语法糖，v-model在内部为不同的输入元素使用不同的属性并跑出不同的事件： text和textarea元素使用value属性和input事件 checkbox和radio使用checked和change事件 select字段将value作为prop将change作为事件 以input表单元素为例 1234&lt;input v-model&#x3D;&quot;something&quot;&gt;&#x2F;&#x2F;相当于&lt;input v-bind&#x3D;&quot;something&quot; v-on:input&#x3D;&quot;something&#x3D;$event.target.value&quot;&gt; 如果在自定义事件中。v-model 默认会利用名为value的prop和名为input的事件，如下所示： 1234567891011121314父组件&lt;ModelChild v-model&#x3D;&quot;message&quot;&gt;&lt;&#x2F;ModelChild&gt;子组件&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;&#x2F;div&gt;props:&#123; value:String&#125;,methods:&#123; test1()&#123; this.$emit(&#39;input&#39;,&#39;小红&#39;) &#125;&#125; 15. Vue组件间通信有哪几种方式Vue组件间的通信是面试常考的知识点之一，Vue组件间通信主要是以下3类通信；父子组件通信，隔代组件通信，兄弟组件通信 (1) props/$emit使用父子组件通信 这种方法是Vue组件的基础 （2）ref与$parent/$children适用于父子组件通信 ref:如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果在子组件上，引用就是指向组件实例 $parent/$children：访问父/子实例 （3） EventBus($emit、$on)适用于父子，隔代，兄弟组件通信 这种方法通过一个空的Vue实例作为中央事件总线(事件中心)，用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子，隔代，兄弟组件 (4) $attrs/$listeners使用隔代组件通信 $attrs：包含了父租用与中不被prop所识别的特性绑定。当一个组件没有声明任何prop时，这里会包含所有副作用的绑定，并且可以通过v-bind:$attrs传入内部组件，通常配合inheritAttrs渲染一起使用 $listeners:包含了父作用域中的v-on事件监听器，它可以通过v-on=&quot;$listeners&quot;传入内部组件 (5) Vuex使用于父子，隔代，兄弟组件通信 Vuex是一个专为Vue.js应用程序开发的状态管理模式。每个Vuex应用的核心就是store（仓库）。“store”基本上就是一个容器，它包含着你的应用大部分的状态(state) Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应的高效更新 改变store中的状态的唯一途径就是显式地提交mutation这样使得我们可以方便地跟踪每一个状态的变化 17. 使用过Vue SSR吗？ 说说SSR？ Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。 即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。 服务端渲染 SSR 的优缺点如下： （1）服务端渲染的优点： 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面； 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间； （2) 服务端渲染的缺点： 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境； 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 18. 能说一下vue-router中常用的hash和history路由模式实现原理吗？(1) hash模式的实现原理 早期的前端路由的实现就是基于location.hash来实现的。其实现原理很简单，location.hash的值就是URL中#后面的内容。比如下面这个网站，它的lcoation.hash的值为#search 1http://www.word.com#search hash路由模式的实现主要基于下面几个特性： URL中hash值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash部分不会被发送 hash值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退，前景按钮控制hash的切换 可以通过a标签，并设置href属性，当用户点击这个标签后。URL的hash值会发生改变；或者使用JavaScript来对location.hash惊醒赋值，改变URL的hash值； 我们可以使用hashchange事件来监听hash值的变化，从而对页面进行跳转 （2）history模式的实现原理 HTML5提供了historyAPI来实现URL的变化，其中做最主要的API有以下两个：history.pushState()和history.replaceState()这两个API在不进行刷新的情况下，浏览器的历史记录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示： 12window.history.pushState(null,null,path)window.history.replaceState(null,null,path) history路由模式的实现主要基于存在下面几个特性： pushState和replaceState两个API来操作实现URL的变化 我们可以使用popState事件来监听url的变化，从而对页面进行跳转 history.pushState()和history,replaceState()不会触发popState事件，这是我们需要手动触发页面跳转 19. 什么是MVVMMVVM源自经典的Model-View-Controller（MVC）模式，MVVM的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM的核心是VIewModel层，它就像是一个中转站，负责Model中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与Model层接口进行数据交互，起承上启下作用如下图所示： (1)View层 View是视图层，也就是用户界面。前端主要由HTML和CSS来构建 (2)Model层 Model是指数据模型，泛指后端进行的业务逻辑处理和数据控制，对于前端来说就是祸端提供的APi接口 （3）ViewModel层 ViewModel是由前端开发人员组织生成和维护的视图数据层，在这一层，前端开发者对从后端获取的Model数据进行转换处理，做二次封装，以生成符合View层使用预期的视图数据模型。 通过一个Vue实例来说明MVVM的具体实现 (1) VIew层 12345678&lt;div id&#x3D;&quot;app&quot;&gt; &lt;p&gt; &#123;&#123;message&#125;&#125; &lt;&#x2F;p&gt; &lt;button v-on:click&#x3D;&quot;showMessage()&quot;&gt; click me &lt;&#x2F;button&gt;&lt;&#x2F;div&gt; (2) ViewModel层 123456789101112131415161718192021var app =new Vue(&#123; el:'#app', data:&#123; message:'Hello Vue' &#125;, methods:&#123; showMessage()&#123; let vm = this; alert(vm.message) &#125; &#125;, created()&#123; let vm =this; ajax(&#123; url:'/your/server/data/api', success(res)&#123; vm.message= res; &#125; &#125;) &#125; &#125;) （3） Model层 12345678&#123; \"url\":'/your/server/data/api', \"res\":&#123; \"success\"：true, “name”:\"IoveC\", \"domain\":\"www.cnblogs.com\" &#125; &#125; 20. Vue是如何实现数据双向绑定的？Vue数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示： 即： 输入框内容变化时，Data中数据同步变化。即View=&gt;Data的变化 Data中数据变化时，文本节点的内容同步变化。即Data=&gt;View的变化 其中，View变化更新Data，可以通过事件绑定的方式来实现，所以Vue的数据双向绑定的工作主要是如何根据Data变化更新View Vue主要通过以下4个不走来实现数据双向绑定的： 实现一个监听器Observer：对数据进行遍历，包括子属性对象的属性，利用Object.defineProperty()对属性加上setter和getter这样的话，给这个对象的某个值赋值就会触发setter，那么就能监听到了数据变化。 实现一个解析器Complie:解析Vue模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变化；收到通知，调用更新函数进行数据更新 实现一个订阅者Watcher：Watcher订阅者是Observer和Complie之间通信的桥梁，主要的任务是订阅Observer中属性值的变化的消息，当收到属性变化的消息时，触发解析器Complie中对应的更新函数。 实现一个订阅器Dep：订阅器采用发布-订阅设计模式，用来收集订阅者Watcher，对监听器Observer和订阅者Watcher进行统一管理 21. Vue框架怎么实现对象和数据的监听？如果被问到Vue怎么实现数据双向绑定的，大家肯定会回答通过Object.defineProperty()对数据进行劫持，但是Object.defineProperty()只能对属性进行数据劫持，不能对整个对象进行劫持，同理也无法对数组进行劫持，Vue是怎么检测到对象和数组的变化，查看相关代码如下 1234567observeArray(items:Array&lt;any&gt;)&#123; for(let i&#x3D;0,i&#x3D;items.length;i&lt;1;i++)&#123; observe(items[i]) &#x2F;&#x2F;observe 功能为检测数据的变化 &#125;&#125;let childOb &#x3D; !shallow &amp;&amp; observe(val) &#x2F;&#x2F; observe 功能检测数据的变化 通过Vue源码查看，Vue框架是通过遍历数组和递归遍历对象，从而达到利用Object.defineProperty()也能对对象和数组进行监听。 22. proxy与Object.defineProperty优劣对比Proxy的优势如下： proxy可以直接监听对象而非属性 Proxy可以直接监听数组的变化 Proxy有多达13中拦截方法，不限于apply，ownKeys,deleteProperty等等Object.defineProperty不具备的 Proxy返回的是一个新的对象，我们可以只操作新的对象达到目的，而Objecct.defineProperty只能遍历对象属性直接修改 Object.defineProperty的优势如下： 兼容性好，支持IE9，而Proxy的存在浏览器兼容器问题，而且无法用polyfill磨平 23.Vue怎么用vm.$set()解决对象新增属性不能响应的问题？受现代JavaScript的限制，Vue无法检测到对象属性的添加或删除。由于Vue会在初始化实例时对属性执行getter/setter转化，所以属性必须在data对象上存在才能让Vue将它转换为响应式的。但是Vue提供了Vue.set(object,propertyName,value)/Vue.$set(object,propertyName,value)来实现对选哪个添加响应式属性，那么框架本身是如何实现的呢？ 查看对应的Vue源码: 12345678910111213141516171819202122232425export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123; // target 为数组 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; // 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误 target.length = Math.max(target.length, key) // 利用数组的splice变异方法触发响应式 target.splice(key, 1, val) return val &#125; // key 已经存在，直接修改属性值 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val return val &#125; const ob = (target: any).__ob__ // target 本身就不是响应式数据, 直接赋值 if (!ob) &#123; target[key] = val return val &#125; // 对属性进行响应式处理 defineReactive(ob.value, key, val) ob.dep.notify() return val&#125; vm.$set的实现原理是： 如果目标是数组，直接使用数组的splice方法触发响应式 如果目标是对象，会先判断属性是否存在，对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用defineReactive方法进行响应式处理(defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法) 24. 虚拟DOM的优缺点优点： 保证性能下限：框架的虚拟DOM需要适配任何上层API可能产生的操作，它的一些DOM操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的DOM操作性能要好很多，因此框架的虚拟DOM至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限。 无需手动操作DOM：我们不需要手动去操作DOM，只需要写好view-Modek的代码逻辑，框架会根据虚拟DOM和数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率 跨平台：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，相比之下虚拟DOM可以更方便地跨平台操作，例如服务器渲染，weex开发等等 缺点： 无法进行极致优化：虽然虚拟DOM+合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化 25. 虚拟DOM实现原理虚拟DOM的实现原理主要包括以下3部分 用JavaScript对象模拟真实DOM树，对真实DOM树进行抽象 diff算法 —比较两棵虚拟DOM树的差异 pach算法—-将两个虚拟DOM对象的差异应用到真正的DOM树 26. Vue中的key有什么用key是Vue中vnode的唯一标识，通过这个key，我们的diff操作可以更准确，更快速。Vue的diff过程可以概括为:oldCh和newCh各有两个头尾的变量oldStartIndex，oldEndIndex和newStartIndex，newEndIndex他们会新节点和旧节点进行两两对比，即一共有4中比较方式：newStartIndex和oldStartIndex， newEndIndex和oldEndIndex，newStartIndex和oldEndIndex，newEndIndex和newStartIndex，如果以上4中比较都没有匹配，如果设置了key，就会用key再进行比较。 所以Vue中key的作用是：key是作为Vue中Vnode的唯一标识，通过这个key我们的diff操作可以更准确，更快速 更准确：因为带key就不是就地复用了，在sameNode函数a.key===b.key对比中可以避免就地复用的情况，所以会更加准确 更快速：利用key的唯一性生成map对象来获取对应节点，比遍历方式更快，源码如下： 123456789function createKeyToOldIdx(children,beginIdx,endIdx)&#123; let i,key const map =&#123;&#125;; for(i=beginIdx;i&lt;=endIdx;++i)&#123; key=children[i].key; if (isDef(key))map[key]=i &#125; return map&#125; 27. 对Vue项目进行哪些优化？（1）代码层面的优化 v-if和v-show区别使用场景 computed和watch区分使用场景 v-for遍历必须为item添加key，且避免同时使用v-if 长列表性能优化 事件的销毁 图片资源懒加载 路由懒加载 第三方插件按需引用 服务端渲染SSR or预渲染 （2）webpack层面的优化 webpack对图片进行压缩 减少ES6转为ES5的冗余代码 提取公共代码 模板预编译 提取组件的CSS VUe项目编译优化 （3）基础的web技术的优化 开启gzip压缩 浏览器缓存 CDN的使用 28. 对于vue3.0特性你有什么了解（1）检测机制的改变 3.0将带来基于Proxy的observer实现，提供全语言覆盖的反应性跟踪。消除了Vue2当基于Object.defineProperty的实现存在的很多限制 只能检测属性，不能检测对象 检测属性的添加和删除 检测数组索引和长度的变更 支持Map，set，weakMap和WeakSet （2）模板 模板方面，改了作用域插槽，把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。 （3）对象式的组件声明方式 3.0修改了组件的声明方式，改成了类式的写法，这样使得和TypeScript的结合更加容易","categories":[],"tags":[]},{"title":"git","slug":"git","date":"2021-01-26T10:50:20.509Z","updated":"2021-01-26T10:51:49.744Z","comments":true,"path":"posts/43167/","link":"","permalink":"http://blog.liurugang.cn/posts/43167/","excerpt":"","text":"gitgit是什么 官方话：Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务 引用廖雪峰老师的话，它能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想要查看某次改动，只需要在软件里喵一眼就可以。 为什么要学习Git 面试要被问。可以应付面试‘ 很多公司开发都用GIt来处理项目。现在不学，以后肯定还要学 在我看来Git是现如今所有程序员都要掌握的，以后与同事共同开发项目必定要用到的，熟练掌握Git命令，可以提高开发效率 安装git windows ​ 直接在官网上去下载。下载完成后，随便在某个文件下右键如果有Git Bash Here 就安装成功了。安装后，还要再命令行输入 12$git config --global user.name \"你的名字\"$git config --global user.email \"你的邮箱\" global表示全局，这台机器所有的GIt仓库都会使用这个配置。允许单个仓库使用其他的名字和邮箱 仓库 本地仓库是对于远程仓库而言的 本地仓库 = 工作区 + 版本区 工作区即磁盘上的文件集合 版本区即.git文件 版本库 = 暂存区(stage) + 分支(master) +指针(head) 以我使用最频繁的git命令为例，即提交到github为例 git init 原本本地仓库只包含着工作区，这是最常见的工作状态。此时，git init一下，表示在本地区域创建了一个.git文件，版本区建立 git add .表示把工作区的所有文件提交到版本区里面的暂存区 当然你也可以通过git add ./xxx/一条条分批添加到暂存区 git commit -m &#39;xxx&#39;把暂存区的所有文件提交到仓库区，暂存区空空荡荡 git remote add origin https://github.com/name/name_canku.git把本地仓库与远程仓库连接起来 git push -u origin master把仓库区的文件提交到远程仓库里 一旦提交了，如果你又没有对工作区做任何修改，那么工作区就是干净的。会有这样的信息noting to commit,working tree clean 提交到Github git init .初始化，表示把这个文件变成Git可以管理的仓库。初始化后打开隐藏的文件可以看到有一个.git文件。 git add . 后面的一个点表示把这个文件全部提交到暂存区。 git add ./readme.md/ 表示把这个文件下面的readme.md文件提交到暂存区。 git commit -m &quot;你要评论一点什么东西&quot; git commit的意思是把暂存区的全部文件提交到本地仓库。-m后接评论。 git remote add origin https://github.com/name/name_cangku.git表示把你本地的仓库与GitHub上的远程仓库连接起来。只需要连接一次，以后提交的时候就可以不用谢这条命令了。name是你的github名字，name_cangku是你的仓库名。注意不要把后面的.git给漏掉了。因为我前面就是这么走过来的，绕了很多弯路。至于如何在GitHub上新建仓库，网上有很多教程，这里不再赘述了。 git push -u origin master 把本地仓库提交到远程仓库。(最后一步)在你的远程仓库上刷新一下就可以看到你提交的文件了。 最后提到的是，在git commit -m &quot;&quot;之前，可以重复git add到暂存区。但是git commit会把你之前存放在暂存区的全部文件一次性全部提交到本地仓库。 版本的回溯与前进提交一个文件，有时候我们会提交很多次，在提交历史中，这样就产生了不同的版本。每次提交，GIt会把他们串成一条时间线。如何回溯到我们提交的上一个版本，用git reset --hard+ 版本号即可。版本可以用git log来查看，每一次的版本都会产生不一样的版本号。回溯之后，git log查看一下发现我们最近的那个版本已经不见了。但是我们还想要前进到最近的版本应该如何？只要git reset --hard +版本号就行。退一步来讲，虽然我们可以通过git reset --hard+ 版本号，靠记住版本号来可以正在不同的版本之间来回穿梭。但是，有时候把版本号弄丢了怎么办？git reflog帮你记录了每一次的命令，这样就可以找到版本号了，这样你又可以通过git reset来版本穿梭了。 撤销 场景1:在工作区时，你修改了一个东西，你想撤销修改，git checkout --file。廖雪峰老师指出撤销修改就回到和版本库一模一样的状态，即用版本库里的版本踢馆工作区的版本。 场景2: 你修改了一个内容，并且已经git add 到暂存区了。向撤销怎么办？回溯版本，git reset --hard --hard + 版本号,再git checkout --file，替换工作区的版本 场景3：你修改了一个内容，并且已经git commit到了master。跟场景2一样，版本回溯，在进行撤销 删除 如果你git add一个文件到暂存区，然后在工作区又把文件删除了，git会知道你删除了文件，如果你把版本库里的文件删除，git rm并且git commit -m &#39;xxx&#39;。 如果你误删了工作区的文件，怎么办？使用撤销命令，git checkout --&lt;file&gt;就可以。这再次证明了撤销命令其实就是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以一键还原 分支分支，就像平行宇宙，廖雪峰老师如是说。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，向提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作 创建与合并分支 在没有其他分支插进来时，只有一个master主分支。每次你git push -u origin master提交就是增加哦一条事件轴，master也会跟着移动 创建一个other的分支，通过other提交，虽然时间轴向前走了，但是主分支还在原来的位置 理论分析完，看一下命令怎么写 创建分支other，切换到other分支 12git branch othergit checkout other 查看当前所有分支 1git branch 12* other master 当前的分支会有一个* 用other提交 12git add .&#x2F;xxx&#x2F;git commit -m &#39;xxx&#39; other分支完成，切换会master 1git checkout master 此时，master分支上并没有other的文件，因为分支还没有合并 合并分支 1git merge other 合并完成之后，就可以在master分支上查看到文件了 删除other分支 1git branch -d other 在以后的工作中，应该是一个开发小组共同开发一个项目，组长会创建很多分支，每一个分支可以交给一个人开发某一个功能，一个小组共同开发而且不会相互干扰。谁的功能完成了，就可以有组长合并一下完成了的分支。 解决合并分支问题 假如有这样一种情况，分支other已经commit了，但是此时指针指回master时，并且master没有合并，而是git add/commit提交了。这样，就产生了冲突，主分支master文件内容与other分支的内容不一样。合并不起来 修改文件的内容，让其保持一致。 git add ``git commit提交 分支合并了 git log --graph 查看分支合并图 git branch -d other删除分支，任务结束。 删除分支 git branch -d + 分支有可能会删除失败，因为会保护没有被合并的分支 git branch -D + 分支强行删除，丢弃没有被合并的分支 多人协作 git remote查看远程库的信息，会显示origin,远程仓库默认名称为origin git remote -v 显示更详细的信息 git push -u origin master推送master分支到origin远程仓库 git push -u origin master推送other到origin远程仓库 抓取分支 产生上图的冲突时， git pull把最新的提交从远程仓库中抓取下来，在本地合并，解决冲突。再进行git push 如果git pull也失败了，还要指定分支之间的链接，这一步git会性你怎么做。然后再git push 廖雪峰老师的总结：多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并 如果合并有冲突，则姐姐冲突，并在本地提交 没有冲突或解决掉冲突后，再用git push origin &lt;branch-nam&gt;推送就能成功 如果git push 提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt;origin/&lt;branch-name&gt; 标签管理 比如一个APP要上线，通常在版本库中打一个标签(tag)，这样就确定了打标签的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照 git的标签虽然是版本库的快照，但是它其实就是指向某个commit的指针。 tag其实就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。比如tagv2,1就是把历史上的一个版本的东西叫做v2.1 创建标签 git branch查看当前分支，git checkout master切换到master分支。 git tag &lt;name&gt;打标签，默认为HEAD。比如git tag v1.0默认标签是打在最新提交的commit上的。如果想要打标签在以前的commit上，要git log找到历史提交的commit id 如果一个commit id是du2nd9，执行git tag v1.0 du2nd9就把这个版本打上了v1.0的标签了 git tag查看所有标签，可以知道历史版本的tag 标签不是按照时间顺序列出，而是按照字母顺序的 git show &lt;tagname&gt;查看标签信息 git tag -a &lt;标签名&gt; -m &quot;说明&quot;，创建带说明的标签。-a指定标签名，-m指定说明文字。用show可以查看说明 操作标签 git tag -d v1.0删除标签。因为创建的标签都只存储在本地，不会自动推送感到远程，所以，打错的标签可以在本地安全删除 git push origin &lt;tagname&gt;推送某个标签到远程 git push origin --tags一次性推送全部尚未推送到远程的本地标签 如果标签推送到远程。git tag -d v1.0先删除本地标签v1.0。git push origin:refs/tags/v1.0删除远程标签v1.0 常用git命令总结 git config --global user.name &quot;你的名字&quot; 让你全部的Git仓库绑定你的名字 git config --global user.email &quot;你的邮箱&quot; 让你全部的Git仓库绑定你的邮箱 git init 初始化你的仓库 git add . 把工作区的文件全部提交到暂存区 git add ./&lt;file&gt;/ 把工作区的&lt;file&gt;文件提交到暂存区 git commit -m &quot;xxx&quot; 把暂存区的所有文件提交到仓库区，暂存区空空荡荡 git remote add origin https://github.com/name/name_cangku.git 把本地仓库与远程仓库连接起来 git push -u origin master 把仓库区的主分支master提交到远程仓库里 git push -u origin &lt;其他分支&gt; 把其他分支提交到远程仓库 git status查看当前仓库的状态 git diff 查看文件修改的具体内容 git log 显示从最近到最远的提交历史 git clone + 仓库地址下载克隆文件 git reset --hard + 版本号 回溯版本，版本号在commit的时候与master跟随在一起 git reflog 显示命令历史 git checkout -- &lt;file&gt; 撤销命令，用版本库里的文件替换掉工作区的文件。我觉得就像是Git世界的ctrl + z git rm 删除版本库的文件 git branch 查看当前所有分支 git branch &lt;分支名字&gt; 创建分支 git checkout &lt;分支名字&gt; 切换到分支 git merge &lt;分支名字&gt; 合并分支 git branch -d &lt;分支名字&gt; 删除分支,有可能会删除失败，因为Git会保护没有被合并的分支 git branch -D + &lt;分支名字&gt; 强行删除，丢弃没被合并的分支 git log --graph 查看分支合并图 git merge --no-ff &lt;分支名字&gt; 合并分支的时候禁用Fast forward模式,因为这个模式会丢失分支历史信息 git stash 当有其他任务插进来时，把当前工作现场“存储”起来,以后恢复后继续工作 git stash list 查看你刚刚“存放”起来的工作去哪里了 git stash apply 恢复却不删除stash内容 git stash drop 删除stash内容 git stash pop 恢复的同时把stash内容也删了 git remote 查看远程库的信息，会显示origin，远程仓库默认名称为origin git remote -v 显示更详细的信息 git pull 把最新的提交从远程仓库中抓取下来，在本地合并,和git push相反 git rebase 把分叉的提交历史“整理”成一条直线，看上去更直观 git tag 查看所有标签，可以知道历史版本的tag git tag &lt;name&gt; 打标签，默认为HEAD。比如`git tag v1.0 git tag &lt;tagName&gt; &lt;版本号&gt; 把版本号打上标签，版本号就是commit时，跟在旁边的一串字母数字 git show &lt;tagName&gt; 查看标签信息 git tag -a &lt;tagName&gt; -m &quot;&lt;说明&gt;&quot; 创建带说明的标签。 -a指定标签名，-m指定说明文字 git tag -d &lt;tagName&gt; 删除标签 git push origin &lt;tagname&gt; 推送某个标签到远程 git push origin --tags 一次性推送全部尚未推送到远程的本地标签 git push origin :refs/tags/&lt;tagname&gt; 删除远程标签` git config --global color.ui true 让Git显示颜色，会让命令输出看起来更醒目 git add -f &lt;file&gt; 强制提交已忽略的的文件 git check-ignore -v &lt;file&gt; 检查为什么Git会忽略该文件","categories":[],"tags":[]},{"title":"JavaScript面试题","slug":"JavaScript面试题","date":"2021-01-26T10:50:14.665Z","updated":"2021-01-26T10:51:49.740Z","comments":true,"path":"posts/53500/","link":"","permalink":"http://blog.liurugang.cn/posts/53500/","excerpt":"","text":"JavaScript面试题1. 闭包 闭包就是能够读取其他函数内部变量的函数 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用域链 闭包的特性： 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 说说你对闭包的理解 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中 闭包的另一个用处，是封装对象的私有属性和私有方法 2. 说说你对作用域链的理解 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的 简单来说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期 3. javascript原型，原型链？有什么特点？ 每个对象都会在其内部初始化一个属性，就是prototype原型)，当我们访问一个对象的属性时，若果这个对象内部不存在这个属性，那么它就会去prototype里面找这个属性，这个prototype又有自己的prototype，于是就这样一直找下去，也就是我们所说的原型链的概念 关系： instance.constructor.prototype =instance.__proto__ 特点： javascript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变 当我们需要一个属性时，JavaScript引擎会先看当前对象是否有这个属性，如果没有的话，就会查找它的prototype对象是否有一个属性，如此递推下去，一直检索到Object内建对象 4. 请解释什么是事件代理 事件代理，又被称之为事件委托，是JavaScript中产能常用绑定事件的常用技巧。顾名思义，”事件代理“即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听对的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以大大提交性能 可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就很好 可以实现当新增子对象时无需再次对其绑定 5. 谈谈this对象的理解 this总是指向函数的直接调用者 如果有new关键字，this指向new出来的那个对象 在事件中，this指向触发这个事件的对象。特殊的是，IE中的attacheEvent中的this总是指向全局对象window 6. 事件模型 w3c中定义事件的发生经历三个阶段：捕获阶段，目标阶段，冒泡阶段 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发 DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件 阻止冒泡：在w3c中使用stopPropagation()方法 阻止捕获；阻止默认事件的行为，在w3c中，使用preventDefault()方法 7. new操作符具体干了什么？ 创建一个空对象，并且this变量引入该对象，同时继承了该函数的原型 属性和方法被加入到this引用的对象中 新创建的对象由this所引用，并且最后隐式的返回this 8. Ajax原理 Ajax的原理简单的来说就是在用户和服务器之间加了一个中间层(AJAX引擎)，通过xmlHttpRequest对象来向服务器发异常请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据 Ajax的过程只涉及Javascript，XMLHttpRequest和DOM。XMLHttpRequest是ajax的核心机制 1234567891011121314151617//1.创建连接var xhr =null；xhr = new XMLHTTPRequest();//2.连接服务器xhr.open('get',url,true)//3.发送请求xhr.send(null)//4.接收请求xhr.onreadystatechange = function()&#123; if(xhr.readyState==4)&#123; if(xhr.status ==200)&#123; success(xhr.responseText) &#125;else&#123; fail&amp;&amp; fail(xhr.status) &#125; &#125;&#125; 9. 谈谈变量提升 当执行JS代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境。在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为undefined，所以在第二阶段，也就是代码执行阶段，我们可以直接提前使用 123456b();//call bconsole.log(a)//undefinedvar a ='hello world'function b()&#123; console.log('call b')&#125; 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升 12345678b()//call b secondfunction b()&#123; console.log('call b first')&#125;function b()&#123; console.log('call b second')&#125;var b = 'Hello world' 10.bind，call，apply区别 call 和apply都是为了解决改变this的指向。作用都是相同的，只是传参的方式不同 除了第一个参数外，call可以接收一个参数列表，apply只接受一个参数数组 12345678910let a =&#123; value:1&#125;function getValue(name,age)&#123; console.log(name) console.log(age) console.log(this.value)&#125;getValue.call(a,'yck','24');getValue.apply(a ['yck','24']) bind和其他两个方法的作用也是一致的，只是该方法会返回一个函数。 11. 如何实现一个call函数实现以下几个函数，可以从几个方面思考 不传入第一个参数，那么默认为window 改变了this指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除 1234567891011Function.prototype.myCall = function(context)&#123; var context = context||window //给context添加一个属性 context.fn =this; //将context后面的参数取出来 var args =[...arguments.slice(1)] var result= context.fn(...args) //删除fn delete context.fn return result&#125; 12. 如何实现一个apply函数123456789101112131415161718192021Function.prototype.myApply = function(context)&#123; var context = context ||window; context.fn = this; var result; //需要判断是否存储第二个参数 //如果存在，就将第二个参数展开 if(arguments[1])&#123; result =context.fn(...arguments[1]) &#125;else&#123; result =context.fn() &#125; delete context.fn return result; &#125; let a = &#123;value:1&#125; function getValue(name,age)&#123; console.log(name) console.log(age) console.log(this.value) &#125; getValue.myApply(a,'yck','24') 13.如何实现apply函数1234567891011121314Function.prototype.myBind =function(context)&#123; if(typeof this!=='function')&#123; throw new TypeError('error') &#125; var _this =this; var args = [...arguments].slice(1) //返回一个函数 return function F()&#123; if(this instanceof F)&#123; return new _this(...args, ...arguments) &#125; return _this.apply(context, args.concat(...arguments)) &#125; &#125; 14. 箭头函数的特点12345678function a()&#123; return ()=&gt;&#123; return ()=&gt;&#123; console.log(this) &#125; &#125;&#125;console.log(a()()()) 箭头函数其实没有this的，这个函数中的this只取决于他外面的第一个不是箭头函数的函数的this。在这个例子中，因为调用a符合前面代码的第一种情况，所以this是window、并且this一旦绑定了上下文，就不会被任何代码改变 15. async，await优缺点 async和await相比直接使用Promise来说，优势在于处理then的调用链，能够更清晰准确的写出代码。缺点在于滥用await可能会导致性能问题，因为await会阻塞代码，也许之后的异步代码并不依赖前者，但仍然需要等待前者完成，导致代码失去了并发性 下面看一个使用await的代码 12345678910var a =0;var b= async()=&gt;&#123; a =a +await 10 console.log('2',a) // '2' 10 a= (await 10) +a console.log('3',a) // '3' 20&#125;b();a++;console.log('1',a)//'1'1 首先函数b先执行，在执行await 10 之前变量a 还是0，因为在await内部实现了generators，generators会保留堆栈中东西，所以这时候a =0,被保留了下来 因为await是异步操作，遇到await会立即返回一个pending状态的Promsie对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行console.log(&#39;1&#39;,a) 这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候a=10 然后后面就是常规执行代码了 16. Promise Promise 是ES6新增的语法，解决了回调地狱问题。 可以把Promise看成一个状态机。初始是pending状态，可以通过函数resolve和reject将状态转变成resolved或者rejected状态，状态一旦改变不能再次变化 then函数会返回一个Promise实例，并且该返回值是一个新的实例而不是之前的实例。 17. instance原理能在实例的原型对象链中找到该构造函数的prototype属性所指向的原型原型，就返回true 123//__proto__:代表原型对象链instance.[__proto__...] === instance.constructor.prototype//return true 18. 执行上下文(EC)执行上下文可以简单理解为一个对象 它包含三个部分： 变量(VO) 作用域链(词法作用域) this指向 它的类型 全局执行上下文 函数执行上下文 evel执行上下文 代码执行过程 创建全局上下文 全局执行上下文逐行自上而下执行。遇到函数时，函数执行上下文(callee)被push到执行栈顶 函数执行上下文(callee)被激活，开始执行函数函数中的代码，全局执行上下文(caller)被挂起 函数执行完后，函数执行上下文(callee)被pop移除执行栈，控制权交还全局上下文(caller)继续执行 19. 对象的拷贝 浅拷贝：以赋值的形式拷贝引用对象，仍指向同一个地址，修改时源对象也会受到影响 Object.assign 展开运算符 深拷贝：完全拷贝一个新对象，修改时源对象不再受到任何影响 JSON.parse(JSON.stringify(obj)):性能最快 具有循环引用的对象时，报错 当值为函数，undefined或symbol时无法拷贝 递归进行注意赋值 20. 防抖与节流防抖与节流函数是一种最常见的高频触发优化方式，能对性能有较大帮助 防抖：将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需要再输入完成后做一次输入校验即可。 1234567891011121314function debounce(fn,wait,immediate)&#123; let timer =null; return function()&#123; let args = arguments let context =this; if(immediate &amp;&amp; !timer)&#123; fn.apply(context,args) &#125; if(timer) clearTimeout(timer) timer = setTimeout(()=&gt;&#123; fn.apply(context,args) &#125;,wait) &#125;&#125; 节流: 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景：滚动条事件或者resize事件，通常每隔100~500ms执行一次即可。 123456789101112131415161718function throttle(fn,wait,immediate)&#123; let timer =null; let callNow =immediate return function()&#123; let context = this, args =arguments; if(callNow)&#123; fn.apply(context,args) callNow =false &#125; if(!timer)&#123; timer =setTimout(()=&gt;&#123; fn.apply(context,args) timer=null &#125;,wait) &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Nuxt.js实战和配置","slug":"Nuxt.js实战和配置","date":"2021-01-26T10:50:10.696Z","updated":"2021-01-26T10:51:49.725Z","comments":true,"path":"posts/39766/","link":"","permalink":"http://blog.liurugang.cn/posts/39766/","excerpt":"","text":"Nuxt.js实战和配置为什么要用Nuxt.js目的是为了利用Nuxt.js的服务端渲染能力来解决Vue项目的SEO问题 Nuxt.js和纯Vue项目的简单对比 build后目标产物不同 vue:dist nuxt:nuxt 页面渲染流程 Vue：客户端渲染，先下载js后，通过ajax来渲染页面 nuxt:服务端渲染，可以做到服务端拼接好html后直接返回，首屏可以无需发起ajax请求 部署流程 Vue：只需要部署dist目录到服务端，没有服务端，需要用nginx等做web服务器； nuxt：需要部署几乎所有文件到服务器，自带服务端，需要pm2管理，若要求用域名，则需要nginx做代理 项目入口 vue：/src/main.js，在main.js可以做一些全局注册的初始化工作；nuxt没有main.js入口文件，项目初始化的操作需要通过nuxt.config.js进行配置指定。 从零搭建一个Nuxt.js项目并配置新建一个项目直接使用脚手架进行安装 1npx create-nuxt-app &lt;项目名&gt; 大概选上面这些选项 Nuxt开发相关生命周期Nuxt扩展了Vue的生命周期，大概如下： 12345678910export default&#123; middleware()&#123;&#125;,//服务端 validate()&#123;&#125;,//服务端 asyncData()&#123;&#125;,//服务端 fetch()&#123;&#125;，//store数据加载 beforeCreate()&#123;&#125;,//服务端和客户端都会执行 created()&#123;&#125;, //服务端和客户端都会执行 beforeMount()&#123;&#125;, mounted()&#123;&#125; //客户端 &#125; asyncData 该方法是Nuxt最大的一个卖点，服务端渲染的能力就在这里，首次渲染务必使用该方法。asyncData会传进一个context参数，通过该参数获得一些信息，如： 123456789export default&#123; asyncData(ctx)&#123; ctx.app //根实例 ctx.route //路由实例 ctx.params //路由参数 ctx.query //路由问好后面的参数 ctx.error //错误处理方法 &#125;&#125; 渲染出错的ajax请求出错的处理 asyncData渲染出错 使用asyncData钩子时可能会由于服务器错误或api错误导致无法渲染，此时页面还未渲染出来，需要针对这种情况做一些处理，当遇到asyncData错误时，跳转到错误页面，nuxt提供了context.error方法用于错误处理，在asyncData1中调用该方法可跳转到错误页面 123456789export default&#123; async asyncData(ctx)&#123; try&#123; throw new Error() &#125;catch&#123; ctx.error(&#123;statusCode:500,message:'服务器来小差'&#125;) &#125; &#125;&#125; 这样，当出现异常时，会跳转到默认的错误页，错误页面可以通过/layout/error.vue自定义 这里会遇到一个问题,context.error的参数必须是类似{statusCode:500.message:&#39;服务器开小差了&#39;},statusCode必须是http状态码，而我们服务端返回的错误往往有一些其他的自定义代码，如{resultCode:10005,resultInfo:&#39;服务器内部错误&#39;},此时需要对返回的api错误进行转换一下。 为了方面，我引入了/plugins/ctx-inject.js为context注册一个全局的错误处理方法： context.$errorHandler(err)。ctx-injecct.js: 12345678910111213141516//为context注册全局的错误处理事件export default(ctx,inject)=&gt;&#123; ctx.$errorHandler =err=&gt;&#123; try&#123; const res =err.data if(res)&#123; //由于nuxt的错误只能识别http的状态码，因此statusCode统一传500.表示服务器异常 ctx.error(&#123;statusCode:500,message:res.resultInfo&#125;) &#125;else&#123; ctx.error(&#123;status:500,message:'服务器开小差'&#125;) &#125; &#125;catch&#123; ctx.error(&#123;status:500,message:'服务器开小差'&#125;) &#125; &#125;&#125; 然后在nuxt.config.js使用该插件： 12345export default&#123; plugins:[ '~/plugins/ctx-injecct.js' ]&#125; 注入完毕，我们可以在asyncData中进行使用 123456789export default&#123; async asyncData(ctx)&#123; try&#123; throw new Error() &#125;catch(err)&#123; ctx.$errorHandler(err) &#125; &#125;&#125; ajax请求错误 对于ajaxx的异常，此时页面已经渲染，出现错误时不必跳转到错误页，可以通过this.$toast.error(res.message)toast出来即可 loading方法 nuxt内置了页面顶部loading进度条推荐使用，提供页面跳转体验。打开：this.$nuxt.$loading.start()完成this.$nuxt.$loading.finish() 打包部署一般来说，部署前可以现在本地打包，本地跑一下，确认无误之后再上传到服务器部署。命令： 1234//打包npm run build//本地跑npm start 除node_modules,.git .env，将其他的文件都上传到服务器，然后通过pm2进行管理，可以在项目根目录建一个pm2.json方面维护： 123456&#123; \"name\":\"nuxt-test\", \"script\":\"./server/index.js\", \"instances\":2, \"cwd\":\".\"&#125; 首次部署或有新到的依赖包，需要在服务器上npm install一次，然后可以用pm2启动进程 12//项目根目录下运行pm2 start ./pm2.json 需要的话，可以设置开机自动启动pm2:pm2 save&amp;&amp;pm2 startup。需要注意，每次部署都得重启一下进程:pm2 reload nuxt-test","categories":[],"tags":[]},{"title":"pm2","slug":"pm2","date":"2021-01-26T10:50:05.436Z","updated":"2021-01-26T10:51:49.733Z","comments":true,"path":"posts/40620/","link":"","permalink":"http://blog.liurugang.cn/posts/40620/","excerpt":"","text":"pm2背景对于线上项目，如果直接用node app 来启动，如果报错了，可能直接停止导致整个服务器崩溃，一般监控node有几种方案 supervisor： 一般用作开发环境的使用 forever：管理多个站点，一般每个站点的访问量不大的情况，不需要监控 PM2:网站的访问量比较大，需要完整的监控页面 PM2的主要特性 内部负载均衡 后台运行 0秒停机重载，我理解大概意思是维护升级的时候不需要停机 具有Ubuntu和CentOS的启动脚本 停止不稳定的进程(避免无限循环) 控制台检测 提供HTTP API 远程控制和实时的API 安装12//全局安装pm2，依赖node和npmnpm install -g pm2 用法 基本启动命令 123//pm2 start//start命令启动对应的node server文件pm2 start ./build/server.js 启动之后，控制台会看到如下消息： 如上图所示，可以看到项目kafazhe启动成功，id是0，并且状态是online 查看详细状态信息 12&#x2F;&#x2F; pm2 show (appname|id)pm2 show kaifazhe 如上图所示，可以查看kaifazhe进程的详细信息 查看所有启动的进程列表 1pm2 list 监控每个node进程对的cpu和内存使用情况 1pm2 monit 可以使用pm2 monit功能监控所有node进程的运行情况，包括各种响应，错误信息 显示所有进程的日志 1pm2 logs 监控运行这些进程的机器的状态 1pm2 web 停止 指定/所有进程 1pm2 stop (id|all) 如图，我们运行了两个服务状态都是online，使用stop 0 之后，kaifazhe的服务编程了stopped，然后使用stop all，所有进程状态变成了stopped 启动 指定/所有进程 1pm2 restart (id|all) 杀死 指定/所有进程 1pm2 delete (id|all) 从上图我们可以看出，restart 0 之后，0进程从stopped状态变成了online，然后我们使用delete 0，进程0 就消失不见了，我们再delete all,可以看到现在没有任何进程在运行。 配置PM2启动文件pm2启动的方式可以进行很多的扩展，比如设置环境，设置错误信息打印，设置输入信息打印等等高级功能。那么一条命令就不能完成这些任务，所有pm2提供了配置文件的方式来启动 pm2.config.js1234567891011121314151617181920212223242526272829303132module.exports = &#123; apps: [ &#123; name: 'kaifazhe', // 应用名称 script: './build/server.js', // 启动文件地址 cwd: './', // 当前工作路径 watch: [ // 监控变化的目录，一旦变化，自动重启 'src', 'build', ], ignore_watch: [ // 忽视这些目录的变化 'node_modules', 'logs', 'public', ], node_args: '--harmony', // node的启动模式 env: &#123; NODE_ENV: 'development', // 设置运行环境，此时process.env.NODE_ENV的值就是development ORIGIN_ADDR: 'http://www.yoduao.com' &#125;, env_production: &#123; NODE_ENV: 'production', &#125;, out_file: './logs/out.log', // 普通日志路径 error_file: './logs/err.log', // 错误日志路径 merge_logs: true, log_date_format: 'YYYY-MM-DD HH:mm Z', &#125;, ],&#125;; 负载均衡pm2厉害的点是，自动给你做负载均衡，只需要一条命令 12345pm2 start server.js -i (number|max)//开启三个进程运行项目pm2 start app.js -i 3//根据机器CPU核数，开启对应数目的进程运行项目pm2 start app.hs 04-i max 配置文件里对应的：&quot;instance&quot;:(number|max) 12//pm2 config.js“instances”:2 //启动两个实例 配合pm2-web实现监控可视化安装1npm install -g pm2-web 使用默认pm2-web会自动启动一个8080，但是我们还是喜欢可控状态，因此安装配置文件的方法启动 1pm2-web --config pm2-web-config.json 1234567&#123; \"www\":&#123; \"host\":\"localhost\", \"address\":\"0.0.0.0\", \"port\":6666 &#125;&#125; 这样你就要可以在浏览器查看可视化的监控状态了","categories":[],"tags":[]},{"title":"html面试题","slug":"html面试题","date":"2021-01-26T08:18:08.423Z","updated":"2021-01-26T10:51:49.747Z","comments":true,"path":"posts/7559/","link":"","permalink":"http://blog.liurugang.cn/posts/7559/","excerpt":"","text":"前端面试题基础篇HTML，HTTP，web综合问题1. 前端需要注意哪些SEO 合理使用title ，description，keywords 语义化的HTML代码 重要内容HTML代码放在最前面 重要内容不要用JS输出 少用iframe 非装饰性图片必须加alt 提高网站访问速度 2. &lt;img&gt;的title和alt有什么区别 title通常当鼠标滑动到元素上的时候显示 alt是img的特有属性，是图片内容的等价描述，用于图片无法加载时显示，读屏器阅读图片。可以提高图片高可访问性。搜索引擎会重点分析 3. HTTP的几种请求方法用途 GET 方法 。 发送一个请求来取得服务器上的某一资源 POST方法。向URL指定的资源提交数据或附加新的数据 DELETE方法。删除服务器上的某资源 CONNECT方法。把请求连接转换到透明的TCP/IP通道4. 从浏览器地址栏输入url到显示页面的步骤 基础版本 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发送请求 服务器交给后台处理完成后返回数据，浏览器接收文件(HTML,JS,CSS,图像等) 浏览器对加载到的资源(HTML,JS,CSS等等)进行语法解析，建立相应的内部数据结构（如DOM树，CSSOM树） 载入解析到的资源文件，渲染页面，完成。 详细版 在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证 检验新鲜通常由两个HTTP头进行控制EXpires和Cache-Control HTTP1.0提供expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-control：max-age=，值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP(GET)请求报文 浏览器获取主机IP地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 DNS缓存 DNS递归查询 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=x的包到服务器端口 服务器发挥SYN=1，ACK=x+1,Seq=Y的响应包 客户端发送ACK=Y+1,Seq =z TCP链接建立以后发送HTTP请求 服务器接收请求并解析，处理程序读取晚会智能请求并准备HTTP响应，可以需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，广播TCP的四次握手如下： 主动方发送Fin=1 Ack=z，Seq=x报文 被动方发送Ack=x+1,Seq=z报文 被动方大宋Fin=1，ACK=x,Seq=Y报文 主动方大宋ACK=Y，Seq=x报文 浏览器检查响应状态码：是否为1xx,3xx,4xx,5xx，这些情况处理与2xx不同 如果资源可缓存，进行缓存 解析HTML文档，构建DOM树，下载资源，构建cssom树，执行JS脚本 构建DOM树 根据HTML规范将字符流解析为标记 词法分析将标记转换为对象并定义属性和规则 根据HTML标记关系将对象组成DOM树 解析构成中遇到图片，样式表，js文件，启动下载 构建CSSOM树 字符流转换成标记流 根据标记创建节点 节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树 从DOM树的根节点遍历所有可见节点 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 JS引擎解析过程 显示页面 5. 如何进行网站性能优化 content方面 减少HTTP请求：合并文件，css精灵(雪碧图），inline Image(内联图片) 减少DNS查询:DNS缓存，将资源分布到恰当数量的主机名 减少DOM元素数量 Cookie方面 减少cookie大小 css方面 将样式表放在页面的顶部 不使用css表达式 使用&lt;link&gt;不使用@import JavaScript方面 将脚本放到页面底部 将JavaScript和css从外部引入 压缩JavaScript和css 删除不需要的脚本 减少DOM访问 图片方面 优化图片：根据实际颜色需要选择色深，压缩 优化css图片 不要在HTML中拉伸图片 6. HTTP状态码及含义 1xx:信息状态码 100 continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 2xx:成功状态码 200 ok 正常返回信息 201 created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 3xx 重定向 301 请求的网页已永久移动到新位置 302 临时性重定向 304 自从上次请求后，请求的网页未修改过 4xx: 客户端错误 400 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发送请求 401 请求未授权 403 禁止访问 404 找不到如何与URI相匹配的资源 5xx: 服务器错误 500 最常见的服务器端错误 503 服务器端暂时无法处理请求 ​ 7. 语义化的理解 用正确的标签做正确的事情 HTML语义化就是让页面的内容结构化，便于对浏览器，搜索引擎解析 在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于SEO 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 8. 介绍一下你对浏览器内核的理解 主要分为两部分：渲染引擎和JS引擎 渲染引擎：负责取得网页的内容，整理讯息，以及计算网页的显示方式，然后会输出至显示器。 jS引擎则：解析和执行JavaScript来实现网页的动态效果 9. HTML5有哪些新特性，移除了哪些元素？新增功能 绘画canvas 用于媒介回放的video和audio元素 本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失 sessionStorage的数据在浏览器关闭后自动删除 语义化更好的内容元素，比如artcle，footer，header，nav，section 表单控件， url，email，time，date 新的技术：webwoker。websocket 移除功能 移除一些标签 之处HTML5新标签 IE8/IE7等浏览器支持通过document.createElement方法产生的标签 可以利用这一特性让这些浏览器支持HTML5新标签 10. 请描述一下cookies，sessionStorage和localStorage的区别？ cookie是网站为了标示用户身份而储存在用户本地终端上的数据 cookie数据始终在同源的http请求中携带(即使不需要)，记会在浏览器和服务器间来回传递 sessionStroage和localStorage不会自动把数据发给服务器，仅在本地保存 存储大小： cookie数据大小不能超过4k sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大的多，可以达到5m或更大 有效时间 localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage数据在当前浏览器窗口关闭后自动删除 cookie设置的cookie在cookie过期时间之前一直有效，即使窗口或浏览器关闭 11. iframe有哪些缺点 iframe会阻塞主页面的Onload事件 搜索引擎的检查程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑着两个缺点。如果需要使用iframe最好是通过JavaScript动态给iframe添加src属性 12. WEB标准以及W3C标准是什么？web标准 html是表现。css是结构，JavaScript是行为 w3c标准 对于表现要求 标签字母要小写 标签要闭合 标签不允许随意嵌套 对于css和js来说 尽量使用外链css样式表和js脚本 样式尽量少用行间样式表，使结构与表现分离，标签id和class等属性命名要做到见文知义 13. Doctype作用？ &lt;!DOCTYPE&gt;声明位于文档中的最前面，处于&lt;html&gt;标签之前。告知浏览器的解析器，用什么文档类型规范来解析这个文档 14. HTML全局属性有哪些 class：为元素设置类标示 data-*: 为元素增加自定义属性 draggable： 设置元素是否可拖拽 id：元素id，文档内唯一 lang；元素内容的语言 style：行内css样式 title：元素相关的建议信息 15. 你能描述一下渐进增强和优雅降级之间的不同吗？ 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果，交互等改进和追加功能达到更好的用户体验 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 区别：优雅降级是从复杂的现状开始，并视图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级(功能衰减)意味着往后看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带 16. 简述一下src与href的区别 src用于替换当前元素，href用于在当前文档和引用资源之间确立关系 src，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如JS脚本img图片和frame等元素 &lt;script src=&quot;js.js&quot;&gt;&lt;/script&gt;当浏览器解析到元素时，会暂停其他资源的下载和处理，直到将该资源加载，编译，执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部 href 指向网络资源所在位置，建立和当前元素或当前文档之间的连接，如果我们在文档中添加&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;&gt;bane浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理 17. 页面访问cookie的限制条件cookie(存储在用户本地终端上的数据) cookie指某些网站为了辨别用户身份，进行session跟踪而存储在用户本地终端上的数据 跨域问题： cookie允许web开发者保留他们的用户的登录状态。但是当你的站点有一个以上的域名时就会出现问题了。在cookie规范上说，一个cookie只能用于一个域名，不能够发给其他的域名。因此在浏览器群中对一个域名设置了一个cookie，这个cookie对其他域名将无效 解决： 通过nginx反向代理 jsonp方式请求 设置了 HTTP only： 如果在cookie中设置了HttpOnly属性，那么通过程序(JS脚本)将无法读取cookie信息，这样能有效的防止XSS攻击 cookie的作用于弊端cookie的作用 可以在客户端保存用户数据，起到简单的缓存和用户身份识别等作用 保存用户的登录状态，用户进行登录，成功登录后，服务器生成特点的cookie返回给客户端，客户端下次访问该域名下的任何页面，将该cookie的信息发送给服务器，服务器经过检验，来判断用户是否登录 记录用户的行为 cookie弊端 增加流量消耗，每次请求都需要带上cookie信息 安全性隐患，cookie使用明文传输，如果cookie被人拦截，那么就可以取得所有session信息 cookie数量和长度的限制。每个域名下最多只能有20条cookie，每个cookie长度不能超过4kb，否则会被截掉","categories":[],"tags":[]},{"title":"剖析JavaScriptAMDCMDCOMMONJSES6模块化","slug":"剖析JavaScriptAMDCMDCOMMONJSES6模块化","date":"2021-01-21T14:39:19.200Z","updated":"2021-01-26T10:51:49.735Z","comments":true,"path":"posts/35712/","link":"","permalink":"http://blog.liurugang.cn/posts/35712/","excerpt":"","text":"剖析JavaScriptAMD/CMD/COMMONJS/ES6模块化CommonJScommonJS出现就是解决原本js文件引入出现的不足点，即模块依赖和全局污染问题。它并不是一个js语言规则，而是对于模块化的一个规范 CommonJS实际上就是用了require这个玩意，只要引用，就会创建一个模块的实例，即实例化 做法是通过requrire引入模块，通过module.exports导出，并且文件加载时同步完成的 对服务端比较友好，内含缓存机制，也就是只要require导入一次模块，那么这个模块就是被缓存，并且还会进行一次比较异同的操作，例如我修改了这个模块，那么将会缓存的模块替换新的模块 在node上运行，不依赖客户端 而当我们引入一个模块后，其实会解析成一个立即执行函数，类似于原本的ES5利用自治性函数封装一样，类似下面，因此，引入模块并不是全局变量 123(function(exports,requrire,module,__filename,__dirname&#123; &#125;)() AMDCommonJS只能在nodejs服务端那边使用，在客户端没法运行。因此AMD诞生，全程异步模块定UI，是通过RequireJS来实现的，区别于CommonJS,它是异步的。 定义模块:define(moduleName,[module],factory); 引入模块：requrie([module],callback) 下面看这个例子： 定义一个模块moduleA 123456define('moduleA',function()&#123; var a =[1,2,3,4,5]; return&#123; a: a.reverse() &#125;&#125;) 再来定义一个模块moduleB，此时它依赖于模块A，按照如下方法进行依赖 123456define('moduleB',[moduleA],function(moduleA)&#123; var b= [6,7,8,9,10]; return&#123; b:moduleA.a.concat(b) &#125;&#125;) 然后在index.js文件中我们需要通过require.config来配置我们的模块路径，如若没有配置的话，就会报错找不到。 123456789101112require.config(&#123; paths:&#123; moduleA:'js/module_a', moduleB:'js/mdoule_b', moduleC:'js/module_c', &#125;&#125;)require(['moduleA','moduleB','moduleC'],function()&#123; console.log(moduleA.a); console.log(moduleB.b); console.log(moduleC.c);&#125;) 注意点：上述依赖模块只有当全部加载完毕后，才会执行后面的回调函数。这种方式就前置依赖 CMD阿里也为模块化做了贡献，推出了CMD全称通用模块定义，同理。它也没法在浏览器端运行 定义模块：define(function(require，exports,module){}) 引入模块：sea.js([module路径],function(moduleA,moduleB,moduleC){}) 下面看这个例子： 定义一个模块moduleA 123456define(function(require,exports,module)&#123; var a=[1,2,3,4,5]; return&#123; a:a.reverse() &#125;&#125;) 再定义一个模块moduleB，此时它依赖于模块A，按照如下方式进行依赖 1234567define(function(require，exports，module)&#123; var moduleA =require('module_a'), b =[6,7,8,9,10]; return &#123; b:moduleA.a.cancat(b) &#125;&#125;) 然后在index.js文件中，我们需要首先通过数组确定模块路径，如下所示 1234seajs.use(['module_a.js','module_b.js'],function(moduleA，moduleB)&#123; console.log(moduleA.a) console.log(moduleB.b)&#125;) 下面总结CMD·相关知识： 通过require加载,define定义，exports导出,module操作模块 而在使用模块时，需要配置相关url，依赖加载完毕之后，再执行回调函数，这里和AMD没啥区别 CMD就行依赖，按需加载，增强了灵活性 ES6模块化导入模块：import module from &#39;模块路径&#39; 导出模块：export module; 下面看这个例子： 定义一个模块moduleA 123export default&#123; a:[1,2,3,4,5].reverse()&#125; 再来定义一个模块moduleB,此时它依赖于模块A，按照如下方式进行依赖 1234import moduleA from './module_a';export default&#123; b:moduleA.a.concat([6.7.8,9,10])&#125; 然后在index.js文件中我们需要配置我们的模块路径，如没有配置的话，就会报错找不到。 123456import moduleA from './module_a';import moduleB from './module_b';import moduleC from './module_c';console.log(moduleA.a)console.log(moduleB.b)console.log(moduleC.c) ES6模块化与commonjs对比 区别1： commonjs模块输出的是一个值的拷贝 ES6输出的是一个值的引用 区别2： commonjs运行在服务端，因此模块是在运行时加载，即程序执行时require才会加载 ES6模块在编译时加载","categories":[],"tags":[]},{"title":"webpack(3)","slug":"webpack(3)","date":"2021-01-20T09:54:16.843Z","updated":"2021-01-20T09:54:17.151Z","comments":true,"path":"posts/61015/","link":"","permalink":"http://blog.liurugang.cn/posts/61015/","excerpt":"","text":"webpack(3)webpack对图片的处理 file-loader：解决引用路径的问题，拿background样式用url引入背景图来说，我们都知道webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在路径的。这就导致图片引入失败。这个问题我们是用file-loader解决的，file-loader可以解析项目中的url引入，根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。 url-loader：如果图片较多，会发很多的http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码。生成dataURL。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被传入DataURL，大于limit的还会使用file-loader进行copy 1npm install --save-dev file-loader url-loader 文件中的图片分为三种，在css中引入，在js中引入，在html中引入 处理css，js中图片 123456789&#123; test: /\\.(png|svg|jpg|gif)$/, use: &#123; loader: 'file-loader', options: &#123; name:'assets/[name].[ext]', &#125; &#125;&#125;, 直接使用file-loader。url-loader进行配置即可，但是要注意在output(出口)中加入publicPath:&#39;/&#39; 123456789module.exports= &#123; entry:__dirname +'/src/index.js'， output:&#123; path:__dirname+'/dist', filename:'bundle.js'， publicPath:'/' //需要在图片上传的时候添加 &#125;&#125;&#125; 在html中的图片不能被直接打包，需要借助html-withimg-loader 1npm install html-withimg-loader --save 在webpack.config.js中配置 1234module.exports =&#123; test:/\\/.(htm|html)$/, use:['html-withimg-loader']&#125; html-webpack-pluginhtmlwenpackplugin会在打包结束后，自动生成一个html文件，并把打包生成的js模块引入到该html中 1npm install --save-dev html-webpack-plugin 配置 1234567891011121314151617181920212223title: ⽤用来⽣生成⻚页⾯面的 title 元素filename: 输出的 HTML ⽂文件名，默认是 index.html, 也可以直接配置带有⼦子⽬目录。template: 模板⽂文件路路径，⽀支持加载器器，⽐比如html!.&#x2F;index.htmlinject: true | &#39;head&#39; | &#39;body&#39; | false ,注⼊入所有的资源到特定的 template 或者 templateContent 中，如果设置为true 或者 body，所有的 javascript 资源将被放置到 body 元素的底部， &#39;head&#39; 将放置到 head 元素中。favicon: 添加特定的 favicon 路路径到输出的 HTML ⽂文件中。minify: &#123;&#125; | false , 传递 html-minifier 选项给 minify输出hash: true | false, 如果为 true, 将添加⼀一个唯⼀一的webpack 编译 hash 到所有包含的脚本和 CSS ⽂文件，对于解除cache 很有⽤用。cache: true | false，如果为 true, 这是默认值，仅仅在⽂文件修改之后才会发布⽂文件。showErrors: true | false, 如果为 true, 这是默认值，错误信息会写⼊入到 HTML ⻚页⾯面中chunks: 允许只添加某些块 (⽐比如，仅仅 unit test 块)chunksSortMode: 允许控制块在添加到⻚页⾯面之前的排序⽅方式，⽀支持的值： &#39;none&#39; | &#39;default&#39; | &#123;function&#125;-default:&#39;auto&#39;excludeChunks: 允许跳过某些块， (⽐比如，跳过单元测试的块) 案例: 123456789101112const path = require(\"path\");const htmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports=&#123; ... plugins:[ new htmlWebpackPlugin(&#123; title:\"My App\", filename:\"app.html\", template:\"./src/index.html\" &#125;) ]&#125; 需要注意想要在打包的html的文件中生成正确的title，需要在原来的html模板上进行以下修改 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;&lt;%= webpackConfig.title %&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"index.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 因为htmlwenpackplugin默认识别的ejs语法 Clean-webpack-plugin1npm install --save-dev clean-webpack-plugin 12345const &#123; CleanWebpackPlugin &#125; = require(\"cleanwebpack-plugin\");...plugins: [new CleanWebpackPlugin()] 需要注意的是引入的时候需要加上括号 mini-css-extract-plugin123456789const MiniCssExtractPlugin = reqirue(\"mini-css-extract-plugin\")&#123; test:/\\.css$/, use:[MiniCssExtractPlugin.loader,\"css-loader\"]&#125;new MiniCssExtractPlugin(&#123; filename:[name][chunkhash:8].css&#125;) 需要注意引入的时候还需要引入loader MiniCssExtractPlugin.loader webpack-dev-server 提升开发效率的利器 每次改完代码都需要重新打包一次，打开浏览器，刷新一次，很麻烦，我们可以安装使用webpackdevserver来改善这块的体验 安装 1npm install webpacl-dev-server -D 配置 修改下package.json 123\"scripts\":&#123; \"server\":\"webpack-dev-server\"&#125; 在webpack.config.js配置： 12345devServer&#123; contentBase:&quot;.&#x2F;dist&quot;, open:true, port:8081&#125; 启动 1npm run server 启动服务后，会发现dist目录没有了，这是因为devServer把打包后的模块不会放在dist目录下，而是放到了内存中，从而提升速度","categories":[],"tags":[]},{"title":"webpack(2)","slug":"webpack(2)","date":"2021-01-20T09:54:16.840Z","updated":"2021-01-20T09:54:17.152Z","comments":true,"path":"posts/32342/","link":"","permalink":"http://blog.liurugang.cn/posts/32342/","excerpt":"","text":"webpack(2)webpack核心内容Entry(入口)Entry是webpack的入口文件，一开始运行webpack它会找到webpack.config.js里的Entry。它会从这里开始着手，构建内部依赖图。入口点可以有一个或多个 entry的类型 string类型 12//一个入口entry:'./src/main.js' array类型 1entry:['./src/main.js','./src/main2.js'] object类型 12345//对象类型entry:&#123; a:'./src/main.js', b:['./src/main1.js','./src/main2.js'] &#125; 只有对象且键值对的形式，才是多入口文件。如果是多入口，就一定要是多出口 例如： 1234567891011121314//多入口文件entry:&#123; index:'./src/main.js', other:'./src/other.js'&#125;output:&#123; path:path.reslove(__dirname,\"./dist\"), filename:\"[name].js\"&#125;//占位符//hash整个项目的hash值，每次构建一次，就会有一个hash值,hash是1-16为数字字母组成的，可以截取[hash:6].js//chuckhash 根据不同入口entry进行依赖解析，构建对应的chunkhash，只要组成entry的模块没有内容改动，则对应的hash不变//name//id 多个入口是，每个入口生成都会生成chuck 1chuck(代码块) = 1bundle(资源文件) output(出口)chuck 如果entry是string类型或者是array类型，只会生成一个chuck 如果entry是一个object，就可能出现多个chuck，这时候的chunck值是object名称。比如上面的a.js,b.jsChuck名称在output可以配置 使用入口名称赋值，[name]为entry的key值 1filename:\"[name].bundle.js\" 使用内部chunk id,从0开始 1filename:\"[id].bundle.js\" 使用每次构建过程中，都会生成一段hash值 1filename:\"[hahs].boundle.js\" 也可以对hash值进行截取 1filename:\"[chunkhash].boundle.js\" pathoutput.path配置输出文件存放在本地的目录，必须是string类型的绝对路径。通常通过Node.js的path模块去获取绝对路径： 1path:path.resolve(__dirname,'dist_[hash]') __dirname就是当前文件所在的文件夹的名字 publicPath对构建出的资源进行一步加载(图片，文件)。加载这些一步资源需要对应的URL地址。默认是空字符串。简单说，就是静态文件托管在cdn上 1234output:&#123; filename:'[name]_[chunkhash:8],js', publicPath:'https://www.qdtalk.com/assets' &#125; 打包编译之后，HTML页面就变成 1&lt;script src=\"https://www.qdtalk.com/assets/a_12345678.js\"&gt;&lt;/script&gt; LoaderLoader在webpack中承担翻译的作用。因为webpack自身只支持js和json文件，把源文件转化翻译后输出的新结果，且一个文件还可以链式的经过多个翻译员翻译 以处理Scss文件为例： scss源码先后交给sass-loader把scss转成css 把sass-loader输出的css交给css-loader处理，找出css中依赖的资源，压缩css等 把css-loader输出的css交给style-loader处理。转换成通过脚本加载的JavaScript代码 常用的Loader 样式：style-loader、css-loader、less-loader、sass-loader等。 文件：raw-loader、file-loader 、url-loader等 编译：babel-loader、coffee-loader 、ts-loader等 校验测试：mocha-loader、jshint-loader 、eslint-loader等 vue-loader、coffee-loader、babel-loader等可以将特定文件格式转成js模块、将其他语言转化为js语言和编译下一代js语言 file-loader、url-loader等可以处理资源，file-loader可以复制和放置资源位置，并可以指定文件名模板，用hash命名更好利用缓存。 url-loader可以将小于配置limit大小的文件转换成内敛Data Url的方式，减少请求。 raw-loader可以将文件已字符串的形式返回 imports-loader、exports-loader等可以向模块注入变量或者提供导出模块功能 expose-loader:暴露对象为全局变量 安装Loader以安装css-loader和style.loader为例，直接在终端： 1npm install css-loader style-loader --save-dev 配置单个Loaderwebpack.config.js中 12345678module.exports =&#123; module:&#123; rules:[&#123; test:/\\.css$/, use:'css-loader' &#125;] &#125;&#125; test后面接一个正则表达式，表示有哪些后缀文件被处理 use:表示应该用什么loader 1234567891011121314module.exports= &#123; module:&#123; rules:[ &#123; test:/\\.css$/, use:[&#123; loader:'style-loader' &#125;,&#123; loader:'css-loader' &#125;] &#125; ] &#125;&#125; 几个重要的loader Babel Babel可以让你使用Es6/7/8写代码而不用顾忌浏览器的问题，babel可以帮你转换代码 安装几个必要的babel库 1234npm i --save-dev babel-loader babel-core babel-preset-env// babel-loader让webpack去处理一些使用了es6的js文件。//babel-core 提供一系列API，其实是让babel-loader去调用babel-core的API。//babel-preset-env 这个库可以根据环境的不同转换代码 配置babel规则。在webpack.json里增加一个babel属性。作用是设置项目中的babel转码规则和使用到的babel插件，格式如下： 1234\"babel\":&#123; “presets”:[\"evn\"], //设定转码规则 \"plugins\":[] //要用到的插件 &#125; 表示告诉npm，在本项目中将使用babel,并且使用babel-preset-env规则进行转码 除了上一种写法，也可以在根目录下面新建.babelrc文件，然后做一下配置 123&#123; \"presets\":[\"babel-preset-env\"]&#125; 配置好babel的规则，但是webpack依然不知道何时使用该规则。我们还要再接着在配置里写入 1use:'babel-loader' 处理图片 1npm i --save-dev url-loader file-loader 在webpack.config.js里面修改配置： 12345678910111213test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,use : [ &#123; loader: 'url-loader', options: &#123; // 限制 图片大小 10000B，小于限制会将图片转换为 base64格式 limit: 10000, // 超出限制，创建的文件格式 // build/images/[图片名].[hash].[图片格式] name: 'images/[name].[hash].[ext]' &#125; &#125;] Plugins(插件)插件用来扩展webpack功能，可以用于执行范围更广的任务，包括打包，优化，压缩，搭建服务器等等，功能十分强大。要是用一个插件，一般是先使用npm包管理器进行安装，然后在配置文件webpack.config.js中的require引入，最后再这个文件下使用new来创建一个实例。loader一次只能处理单个相同类型文件，但是plugins可以对整个过程起作用。 常用的Plugin插件 webpack内置UglifyJsPlugin插件，压缩和混淆代码。 webpack内置CommonsChunkPlugin，提高打包效率，将第三方库和业务代码分开打包 ProvidePlugin：自动加载模块，代替require和import html-webpack-plugin可以根据模板自动生成html代码，并自动引用css和js文件 extract-text-webpack-plugin 将js文件中引用的样式单独抽离成css文件 DefinePlugin 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。 HotModuleReplacementPlugin热更新 optimize-css-assets-webpack-plugin 不同组件中重复的css可以快速去重 webpack-bundle-analyzer 一个webpack的bundle文件分析工具，将bundle文件以可交互缩放的treemap的形式展示 compression-webpack-plugin 生产环境可采用gzip压缩JS和CSS happypack：通过多进程模型，来加速代码构建 一个简单的插件使用 npm install --save-dev html-webpack-glugin安装一个插件。有的插件webpack自带，如果没有，则需要npm安装 const HtmlWebpackPlugin =require(&#39;html-webpack-plugin&#39;)在webpack.config.js中引用 new一个实例 1234567plugins: [ new HtmlWebpackPlugin(&#123; template: &#39;.&#x2F;src&#x2F;index.html&#39;, &#x2F;&#x2F;以src目录下的index.html文件为模板生成html5新文件 filename: &#39;index.html&#39;,&#x2F;&#x2F;指定生成的HTML文件叫啥名 inject: &#39;head&#39;,&#x2F;&#x2F;指定把脚本script标签放在那里，这里放在&lt;head&gt;标签里。还可以放&lt;body&gt; &#125;)] 利用html-webpack-plugin插件自动生成html每次执行webpack打包生成js文件后，都必须在index.html中手动插入打包好的文件的路径。但在真实生产环境中，一次运行webpack后，完整的index.html应该是被自动生成的。例如静态资源，js脚本都被自动插入了。 根目录下的index.html会被html-webpack-plugin作为最终生成对的html文件的模板。打包后，相关引用关系和文件路径都会按照正确的配置被添加进去 12345678910111213141516171819202122const HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;);module.exports &#x3D; &#123; entry: &#123; app: &quot;.&#x2F;src&#x2F;app.js&quot; &#125;, output: &#123; publicPath: __dirname + &quot;&#x2F;dist&#x2F;&quot;, path: path.resolve(__dirname, &quot;dist&quot;), &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: &quot;index.html&quot;, template: &quot;.&#x2F;index.html&quot;, chunks: [&quot;app&quot;], &#x2F;&#x2F; entry中的app入口才会被打包 minify: &#123; &#x2F;&#x2F; 压缩选项 collapseWhitespace: true &#125; &#125;) ]&#125; 最后执行打包命令，然后在dist目录下就给你自动生成了index.html文件。dist目录下的index.html文件是以根目录下的inde.html文件为模板的。 Mode分为开发模式development和生产模式production两种模式的区别在于一个是为生产环境编译打包，一个是为了开发环境编译打包。生产环境模式下，webpack会自动对代码进行压缩等优化，省去了配置的麻烦","categories":[],"tags":[]},{"title":"webpack(1)","slug":"webpack(1)","date":"2021-01-20T09:54:16.837Z","updated":"2021-01-20T09:54:17.150Z","comments":true,"path":"posts/36438/","link":"","permalink":"http://blog.liurugang.cn/posts/36438/","excerpt":"","text":"webpack(1)webpack是什么为什么要使用webpack我们都知道一个大公司的网站往往做的都很炫酷，美观，功能齐全。在这背后前端工程师花了很大的精力去优化。大型网站和大型项目中背后都拥有着复杂的JS代码和很多依赖。为了简化开发的复杂度，往往对程序切割分裂成不同的模块 如图所示，把大型项目切割成很多不同的模块。里面带的箭头可以理解为require。因为两个文件之间相互通联是靠require连接的。好比如，html文件利用link中引入样式一样。webpack整合了项目里的模块打包的更为精简。所以我们需要wepack webpack分析大型项目的结构 找到JS模块以及浏览器不能直接运行的模块(cjs,sass,hbs等等) 将浏览器不能直接处理的文件装换和打包为合适的格式供浏览器直接处理 这样前端工程师即可以更轻松系统的开发，浏览器也能更高效流畅的运行 webpack的工作原理 webpack的工作原理就是webpack分析大型项目的结构，找到浏览器不能直接运行的模块，将浏览器不能直接处理的文件装换和打包为合适的格式供浏览器处理。 webpack安装&amp;使用 初始化项目 1npm inint -y //快速创建nodejs项目 两种webpack安装 12npm install -g webpack webpaack-cli //全局安装(不推荐使用)npm install -D webpack webpack-cli //本地安装 全局安装会将项目锁定在特定的版本的webpack 打包一个简单的文件 在文件夹下新建一个src文件，下面新建一个main.js文件 根目录下新建一个webpack.config.js文件。为什么要建这个文件，因为直接使用webpack。它会寻找webpack.config.js把当当成默认的配置去运行。此时他不需要使用任何参数，就能读取里面的内容12345678//webpack.config.jsmodule.exports= &#123; entry:__dirname+'/src/main.js'，指定入口文件，在src/main.js output:&#123; path:__dirname +‘/dist’,//打包后指定存放的目录，放在dist filename:'bundle.js' //打包后的文件叫做bundls.js &#125;&#125; __dirname是nodejs中一个全局变量，它指定当前执行脚本所在的目录 修改package.json文件，然后在命令行中运行指令npm run build 12345678910111213141516&#123; &quot;name&quot;: &quot;pack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot; &#x2F;&#x2F;需要修改的地方 &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^5.11.1&quot;, &quot;webpack-cli&quot;: &quot;^4.3.1&quot; &#125;&#125;","categories":[],"tags":[]},{"title":"静态博客访问优化之终极解决方案","slug":"静态博客访问优化之终极解决方案","date":"2021-01-20T08:16:31.499Z","updated":"2021-01-20T08:19:44.776Z","comments":true,"path":"posts/57538/","link":"","permalink":"http://blog.liurugang.cn/posts/57538/","excerpt":"","text":"前言 首先本教程是基于 域名已经备案 的前提下进行的，理论上，任何静态页面都可以使用本教程，哪怕是你写的一个小demo网页，想show给别人看，也可以使用，前提是域名已经备案。域名没有备案的也不要灰心，这里我给出三个解决方案： 一、就是去备案（这不废话吗？）备案一般必须要有域名服务商的服务器才行，而买服务器又得花很多钱。（我们玩Hexo的口号是什么？白嫖！）那么没服务器怎么办呢？——备案授权码！上哪搞呢？鲁迅曾经说过：有需求的地方，必有市场！（鲁迅：没错，什么都是我说的！）这就得靠我们强大的某淘了，给个关键字：XXX云服务号 二、就是不备案强行推广一波我的另一篇优化文章，一样可以获得很高的访问速度：Hexo博客优化 三、使用国外的云服务 备案是“中国特色”，国外的服务器是没有备案一说的。可以尝试 谷歌云 或者 亚马逊的AWS，这里不做过多介绍。 核心方案开门见山的说，今天的主角：对象存储 + CDN。 方案其实就是将自己的静态网页文件放到云服务商提供的 对象存储 中，而 对象存储 一般提供的都有pages服务，而且访问速度绝对要远比代码托管平台提供的pages服务快的多，但是这个pages服务，一般只有绑定了域名才可以开启，而且也只能绑定已备案的域名，最重要的是我们还可以使用云服务商提供的CDN，这样又进一步提升了访问速度，这绝对碾压代码托管平台的pages服务，任你再怎么优化也是没有对象存储快的，更何况还有CDN（付费的当然比免费的好用）。 这个方案的好处是：用远低于购买服务器的价格，就可以获得服务器级别甚至更强的访问性能！ 其实会玩的人看到这里，就已经明白怎么搞了，但是为了很多小白我还要再啰嗦一下。 科普 再讲解具体步骤之前，让我们先了解一些基础概念，以便有更好地阅读体验，大佬请忽略 对象存储：即每个文件都是一个对象， 所有的文件实际是都是在同一个文件夹内，只不过其前缀不同罢了，如果不能理解，就当是一个存储文件的网盘吧。 CDN： 全称Content Delivery Network即内容分发网络。 CDN加速意思就是在用户和我们的服务器之间加一个缓存机制，通过这个缓存机制动态获取IP地址根据地理位置，让用户到最近的服务器访问，从而可以得到更快的访问速度。 源站：即真正存储网站的服务器。（这里指的是我们的对象存储服务器） 回源： 是指CDN服务器缓存的资源过期后，从源站获取最新的访问资源，然后再缓存到CDN服务器，供下次访问 各云服务商的价格对比 云服务商有很多，大家可以根据自己的喜好选择，这里我只提供下参考，说的不对的地方请多多指正。 可能很多人会问，说好的白嫖呢？看下价格就明白了，花不了多少钱的。 服务商的选择因素有很多，比如服务、价格、稳定性等，由于我本人接触云服务这方面时间较短，没什么发言权，那我就只谈谈我们这些「平民」最关心的价格这方面，做个价格对比。 提供对象存储的云服务商有：阿里云、腾讯云、七牛云、又拍云等。考虑到各服务商的价格可能会有所变动，本节目前提供的价格参考日期为2019.11.26。 阿里云阿里云官网 先参考阿里云官方的计量项和计费项、OSS计费 和 CDN计费 文档。 CDN的计费方式有两种：按流量计费 和 按带宽峰值 计费，这里推介选择 按流量计费。 OSS计费项有很多（各种请求和以及所占容量大小的计费等，都很少，这里不做比较），对于几十M的静态博客来说： 当只用 OSS 时，主要费用就是 外网流出流量 的费用！ 00:00-08:00（闲时）：0.25元/GB 8:00-24:00（忙时）：0.50元/GB 当使用 OSS+CDN 时，因为CDN需要到源站获取资源，就不需要从外网获取了，所以这时的费用就是 回源流量 + CDN流量费用 0.15元/GB + 0.24元/GB = 0.39元/GB 是不是很便宜？相比于购买服务器。 腾讯云参考腾讯云官方文档 对象存储COS计费 CDN计费 。 当只用COS时 外网下行流量费：0.5元/GB 当用COS + CDN时 回源流量＋CDN流量 = 0.15元/GB + 0.21元/GB = 0.36元/GB 值得一说的是：腾讯云对这两个服务的新用户是有半年的优惠的。 COS：免费50GB 标准存储容量，6个月 CDN：送6个月的免费流量，每月50G，随便High！ 七牛云七牛云官网 七牛的对象存储10G内是免费的 外网流出流量费用：0.29元/GB CDN回源流量费：10G内免费 CDN-HTTP下载流量费：10G内免费 CDN-HTTPS下载流量费：0.28元/GB CDN-HTTP + 对象存储 = 免费 CDN-HTTPS + 对象存储 = 0.28元/GB （因为回源10G内免费，就只剩下CDN流量费了） 七牛是不是很良心？但是有次使用中，七牛的控制台竟然崩了，控制台居然都能崩掉。 总结我还是比较推介大家用七牛云，当然求稳的话还是阿里云，毕竟大公司。 我曾经看过一个关于阿里云、腾讯云、华为云的横向评测：结果就是华为云以很低的延迟和很高的带宽碾压另外两位。 具体配置 各服务商的配置大体相同，不做过多赘述，这里以腾讯云为例 创建存储桶 登录腾讯云，点击右上角控制台，找到云产品，开通对象存储服务。 存储桶列表-&gt;创建存储桶-&gt; 填写信息 所属地域 选择离自己位置最近的即可（创建后不可更改） 访问权限 选择 公有读私有写 标签 无所谓 上传文件到COS中 继续操作，点击左侧 工具-&gt;客户端下载-&gt; 选择对象系统的 COSBrowser 下载 -&gt; 然后安装即可 点击右上角 账号 下的访问管理-&gt;左侧的访问密钥 可能会有风险提示，点击继续使用 复制 SecretId 和 SecretKey 这两个是读写COS的密钥，不能泄露！ 打开 COSBrowser，输入刚才复制的两个值，点击 登录。 在 COSBrowser中，左下角点击 同步 本地文件夹选择 Hexo根目录中的public文件夹 （public文件夹中的文件为Hexo生成的静态网页文件，我们需要将这些文件放到COS中，供别人访问；git部署的文件也是这些文件！） 存储桶目录选择刚才创建的存储桶，存储桶目录留空（目的：将public文件夹中的文件上传到存储桶的根目录） 点击 开始同步 之后可以到网页版的控制台确认文件有没有上传上去。 开启pages服务 回到控制台，对象存储 -&gt; 存储桶列表 -&gt; 基础配置 -&gt; 静态网站 -&gt; 开启 访问节点：即 该COS的访问地址 强制 HTTPS：建议开启 索引文档（主页）：填 index.html 错误文档（404页面）：如果有404页面填上404页面的地址，如果没有留空即可。 重定向规则：设置发生4XX错误时，要填跳转到哪个页面，可以不配置。 保存 之后就可以直接复制 访问节点 的地址到浏览器打开，看能不能访问。 绑定域名并开启CDN 对象存储 -&gt; 存储桶列表 -&gt; 点击刚才创建的存储桶 -&gt; 点击 域名管理 找到 自定义域名加速，点击添加域名（只能添加已备案的域名） 域名：你的域名（将此域名添加到域名解析那里） 加速地域：国内加速 源站类型： 静态网站源站（非常重要！！） 回源鉴权：不用打开（公共读不需要鉴权） CDN 鉴权：不用设置 点击保存即可 复制该项的CNAME，然后配置到域名解析那里。 等待部署，一般5分钟作用；部署成功后试下自己的域名能不能访问 配置HTTPS证书先在域名服务商那里申请好免费https证书 （也可以在其他地方申请），这里以阿里云为例。 然后点击对应项的下载 选择其他 下载后的是一个压缩文件，解压后有两个文件 *.pem 和 *.key，编辑器将其打开。 控制台这边选择 内容分发网络 -&gt; 证书管理 -&gt; 配置证书 域名：选择刚才申请证书的域名 证书来源：自有证书 证书内容：将刚才以.pem结尾文件的内容粘进来 私钥内容：将以.key结尾文件的内容粘进来 回源协议：协议跟随 最后提交即可！ 成功之后就可以使用https协议 剩下的防盗链、IP访问限频配置之类的各自慢慢摸索、不配置也行。 刷新CDN缓存为什么要刷新CDN缓存？ 因为一旦我们更新了博客的内容，而别人访问的却还是CDN节点缓存的内容，这体验就很糟糕 如果你想刷新某个页面 内容分发网络 -&gt; 刷新预热 -&gt; URL刷新 -&gt; 填入URL提交刷新即可 如果你想刷新整站内容 在目录刷新填入URL，选择刷新全部资源，提交刷新即可 总结可能很多小伙伴还有点蒙，让我们来总结一下以后的使用流程： 先生成静态文件（hexo cl&amp;hexo g） 再将生成的文件上传到对象存储，要利用腾讯的上传软件上传 刷新CDN缓存（因为CDN都是有缓存的，你不刷新，别人访问的都是旧资源） 但是这样总归还是有些麻烦，不过云服务商都提供了各种SDK，如果你足够牛逼，你可以手写一个一键上传脚本，并自动更新CDN缓存。如果你跟我一样是个菜鸡，那还是老老实实用服务商给的“轮子”吧。 文章作者:\\ Sky03 文章链接:\\ https://blog.sky03.cn/posts/1663.html 版权声明:\\ 本博客所有文章除特別声明外，均采用 CC BY 4.0 许可协议。转载请注明来源 Sky03 !","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://blog.liurugang.cn/tags/%E6%80%BB%E7%BB%93/"},{"name":"面试","slug":"面试","permalink":"http://blog.liurugang.cn/tags/%E9%9D%A2%E8%AF%95/"}]}