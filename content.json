{"meta":{"title":"无聊才读书-博客","subtitle":"无聊才读书","description":"不轻言放弃的小小人儿","author":"刘如刚","url":"http://blog.liurugang.cn","root":"/"},"pages":[{"title":"","date":"2021-01-21T11:18:45.406Z","updated":"2021-01-18T16:10:00.000Z","comments":true,"path":"gitcalendar/css/gitcalendar.css","permalink":"http://blog.liurugang.cn/gitcalendar/css/gitcalendar.css","excerpt":"","text":".gitcalendar { font-family: SourceHanSans-Medium; border: 1px solid #DDDDDD; border-radius: 3px; min-height: 120px; text-align: center; margin: 0 auto; border-width:0px; width:100%; display: flex; display: -webkit-flex; justify-content: center; align-items:center; flex-wrap:wrap; } .gitcalendar-graph text.wday, .gitcalendar-graph text.month { font-size: 10px; fill: #aaa; } .contrib-legend { text-align: right; padding: 0 14px 10px 0; display: inline-block; float: right; } .contrib-legend .legend { display: inline-block; list-style: none; margin: 0 5px; position: relative; bottom: -1px; padding: 0; } .contrib-legend .legend li { display: inline-block; width: 10px; height: 10px; } .text-small { font-size: 12px; color: #767676; } .gitcalendar-graph { padding: 15px 0 0; text-align: center; } .contrib-column { text-align: center; border-left: 1px solid #ddd; border-top: 1px solid #ddd; font-size: 11px; } .contrib-column-first { border-left: 0; } .table-column { padding:10px; display: table-cell; width:33%; vertical-align: top; } .contrib-number { font-weight: 300; line-height: 1.3em; font-size: 24px; display: block; } .gitcalendar img.spinner { width: 70px; margin-top: 50px; min-height: 70px; } .monospace { text-align: center; color: #000; font-family: monospace; } .monospace a { color: #1D75AB; text-decoration: none; } .contrib-footer { font-size: 11px; padding: 0 10px 12px; text-align: left; width: 100%; box-sizing: border-box; height: 26px; } .left.text-muted { float: left; margin-left: 9px; color: #767676; } .left.text-muted a { color: #4078c0; text-decoration: none; } .left.text-muted a:hover, .monospace a:hover { text-decoration: underline; } h2.f4.text-normal.mb-3 { display: none; } .float-left.text-gray { float: left; } #user-activity-overview{ display:none; } .day-tooltip { white-space: nowrap; position: absolute; z-index: 99999; padding: 10px; font-size: 12px; color: #959da5; text-align: center; background: rgba(0,0,0,.85); border-radius: 3px; display: none; pointer-events: none; } .day-tooltip strong { color: #dfe2e5; } .day-tooltip.is-visible { display: block; } .day-tooltip:after { position: absolute; bottom: -10px; left: 50%; width: 5px; height: 5px; box-sizing: border-box; margin: 0 0 0 -5px; content: \" \"; border: 5px solid transparent; border-top-color: rgba(0,0,0,.85) } .position-relative {width:100%;padding-left:20px;padding-right:20px;} @media screen and (max-width: 650px){.contrib-column{display:none}} .angle-wrapper { z-index:9999; display:inline; display:none; width: 200px; height: 40px; position: relative; padding: 5px 0; background: rgba(0, 0, 0, 0.8); border-radius: 8px; text-align: center; color: white; } .angle-box { position:fixed; padding:10px } .angle-wrapper span{ padding-bottom:1em; } .angle-wrapper:before { content: ''; width: 0; height: 0; border: 10px solid transparent; border-top-color: rgba(0, 0, 0, 0.8); position: absolute; left: 47.5%; top: 100%; }"},{"title":"","date":"2021-01-21T11:26:03.760Z","updated":"2021-01-21T11:26:03.760Z","comments":true,"path":"gitcalendar/js/gitcalendar.js","permalink":"http://blog.liurugang.cn/gitcalendar/js/gitcalendar.js","excerpt":"","text":"const gitcalendar = new Vue({ el: '#gitcalendar', data: { simplemode: true, //打开时使用canvas绘制gitgitcalendar，关闭时使用svg绘制gitgitcalendar //canvas：dom数少，但图像会发生模糊，自适应一般 svg：dom数多，图像清晰，自适应更佳 user: 'liuboringbook', //这里填写你的github用户名 fixed: 'fixed', px: 'px', x: '', y: '', span1: '', span2: '', month: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'], monthchange: [], oneyearbeforeday: '', thisday: '', amonthago: '', aweekago: '', weekdatacore: 0, datacore: 0, total: 0, datadate: '', data: [], positionplusdata: [], firstweek: [], lastweek: [], beforeweek: [], thisweekdatacore: 0, mounthbeforeday: 0, mounthfirstindex: 0, crispedges: 'crispedges', thisdayindex: 0, amonthagoindex: 0, amonthagoweek: [], firstdate: [], first2date: [], montharrbefore: [], monthindex: 0, purple: ['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f',], green: ['#ebedf0', '#f0fff4', '#dcffe4', '#bef5cb', '#85e89d', '#34d058', '#28a745', '#22863a', '#176f2c', '#165c26', '#144620'], blue: ['#ebedf0', '#f1f8ff', '#dbedff', '#c8e1ff', '#79b8ff', '#2188ff', '#0366d6', '#005cc5', '#044289', '#032f62', '#05264c',], color: ['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f',] }, methods: { selectStyle(data, event) { document.querySelector('.angle-wrapper').style.display = 'block' this.span1 = data.date; this.span2 = data.count; this.x = event.clientX - 100; this.y = event.clientY - 60 }, outStyle() { document.querySelector('.angle-wrapper').style.display = 'none' }, thiscolor(x) { if (x === 0) { let i = parseInt(x / 2); return this.color[0] } else if (x < 2) { return this.color[1] } else if (x < 20) { let i = parseInt(x / 2); return this.color[i] } else { return this.color[9] } }, } }); let githubapiurl = \"https://python-github-calendar-api.vercel.app/api?\" + gitcalendar.user; //let githubapiurl = \"https://githubapi.ryanchristian.dev/user/\" + gitcalendar.user; //旧的api策略 //canvas绘图 function responsiveChart() {if(gitcalendar.simplemode){ let c = document.getElementById(\"gitcanvas\"); let cmessage = document.getElementById(\"gitmessage\"); let ctx = c.getContext(\"2d\"); c.width = document.getElementById(\"gitcalendarcanvasbox\").offsetWidth; let linemaxwitdh = 0.96 * c.width / gitcalendar.data.length; c.height = 9 * linemaxwitdh; let lineminwitdh = 0.8 * linemaxwitdh; let setposition = { x: 0.02 * c.width, y: 0.025 * c.width }; for (let week in gitcalendar.data) { weekdata = gitcalendar.data[week]; for (let day in weekdata) { let dataitem = {date: \"\", count: \"\", x: 0, y: 0}; gitcalendar.positionplusdata.push(dataitem); ctx.fillStyle = gitcalendar.thiscolor(weekdata[day].count); setposition.y = Math.round(setposition.y * 100) / 100; dataitem.date = weekdata[day].date; dataitem.count = weekdata[day].count; dataitem.x = setposition.x; dataitem.y = setposition.y; ctx.fillRect(setposition.x, setposition.y, lineminwitdh, lineminwitdh); setposition.y = setposition.y + linemaxwitdh } ; setposition.y = 0.025 * c.width; setposition.x = setposition.x + linemaxwitdh } ; ctx.font = \"600 Arial\"; ctx.fillStyle = '#aaa'; ctx.fillText(\"日\", 0, 1.9 * linemaxwitdh); ctx.fillText(\"二\", 0, 3.9 * linemaxwitdh); ctx.fillText(\"四\", 0, 5.9 * linemaxwitdh); ctx.fillText(\"六\", 0, 7.9 * linemaxwitdh); let monthindexlist = c.width / 24; for (let index in gitcalendar.monthchange) { ctx.fillText(gitcalendar.monthchange[index], monthindexlist, 0.7 * linemaxwitdh); monthindexlist = monthindexlist + c.width / 12 } ; cmessage.onmousemove = function (event) { document.querySelector('.angle-wrapper').style.display = 'none' }; c.onmousemove = function (event) { document.querySelector('.angle-wrapper').style.display = 'none' getMousePos(c, event); }; function getMousePos(canvas, event) { var rect = canvas.getBoundingClientRect(); var x = event.clientX - rect.left * (canvas.width / rect.width); var y = event.clientY - rect.top * (canvas.height / rect.height); //console.log(\"x:\"+x+\",y:\"+y); for (let item of gitcalendar.positionplusdata) { let lenthx = x - item.x; let lenthy = y - item.y; //console.log(lenthx,lenthy); if (0 < lenthx && lenthx < lineminwitdh) { if (0 < lenthy && lenthy < lineminwitdh) { //console.log(item.date,item.count) document.querySelector('.angle-wrapper').style.display = 'block' gitcalendar.span1 = item.date; gitcalendar.span2 = item.count; gitcalendar.x = event.clientX - 100; gitcalendar.y = event.clientY - 60 } } //if(0< x - item.x"}],"posts":[{"title":"深入理解Vue响应式原理","slug":"深入理解Vue响应式原理","date":"2021-06-22T07:44:47.718Z","updated":"2021-06-22T07:44:47.901Z","comments":true,"path":"posts/22732/","link":"","permalink":"http://blog.liurugang.cn/posts/22732/","excerpt":"","text":"深入理解Vue响应式原理 初步Vue通过Object.defineProperty的getter/setter对收集的依赖项进行监听，在属性被访问和修改时通知变化，进而更新视图数据 Vue数据响应式变化主要涉及Observer，Watcher，Dep这三个主要类； 123456789101112131415var vue = new Vue(&#123; el: \"#app\", data: &#123; name: 'Junga' &#125;, created () &#123; this.helloWorld() &#125;, methods: &#123; helloWorld: function() &#123; console.log('my name is' + this.name) &#125; &#125; ...&#125;) Vue初始化实例根据Vue的生命周期我们知道，Vue首先会进行init初始化操作；源码在 src/core/instance/init.js中 1234567891011121314/*初始化生命周期*/initLifecycle(vm)/*初始化事件*/initEvents(vm)Object.defineProperty /*初始化render*/initRender(vm)/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/callHook(vm, 'beforeCreate')initInjections(vm) // resolve injections before data/props/*初始化props、methods、data、computed与watch*/initState(vm)initProvide(vm) // resolve provide after data/props/*调用created钩子函数并且触发created钩子事件*/callHook(vm, 'created') 以上代码可以看到initState(vm)是用来初始化props，methods，data,computed和watch; src/core/instance/state.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*初始化props、methods、data、computed与watch*/export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options /*初始化props*/ if (opts.props) initProps(vm, opts.props) /*初始化方法*/ if (opts.methods) initMethods(vm, opts.methods) /*初始化data*/ if (opts.data) &#123; initData(vm) &#125; else &#123; /*该组件没有data的时候绑定一个空对象*/ observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; /*初始化computed*/ if (opts.computed) initComputed(vm, opts.computed) /*初始化watchers*/ if (opts.watch) initWatch(vm, opts.watch)&#125;.../*初始化data*/function initData (vm: Component) &#123; /*得到data数据*/ let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125;defi ... //遍历data中的数据 while (i--) &#123; /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/ if (props &amp;&amp; hasOwn(props, keys[i])) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"$&#123;keys[i]&#125;\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(keys[i])) &#123; /*判断是否是保留字段*/ /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/ proxy(vm, `_data`, keys[i]) &#125; &#125; // observe data /*这里通过observe实例化Observe对象，开始对数据进行绑定，asRootData用来根数据，用来计算实例化根数据的个数，下面会进行递归observe进行对深层对象的绑定。则asRootData为非true*/ observe(data, true /* asRootData */)&#125; 1. initDatainitData这里主要做了两件事，一是将_data上面的数据代理到vm上，二是通过执行*observe(data,true)将所有data编程可观察的，即对data定义的每个属性进行getter/setter操作，这里就是Vue实现响应式的基础；observe的实现如下src/core/observer/index.js 1234567891011121314151617181920212223242526 /*尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。*/export function observe (value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value)) &#123; return &#125; let ob: Observer | void /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例，这里可以看Observer实例化的代码def(value, '__ob__', this)*/ if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。而且该对象在shouldConvert的时候才会进行Observer。这是一个标识位，避免重复对value进行Observer */ observerState.shouldConvert &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/ ob.vmCount++ &#125; return ob&#125; 这里new Observer(value)就是实现响应式的核心方法之一，通过它的data转变可以成观察的，用了Object.defineProperty实现了data的getter/setter操作，通过Watcher来观察数据的变化，进而更新视图中 2. ObserverObserver类是将每个目标对象(即data)的键值转换成getter/setter形式，用于进行依赖收集以及调度更新 src/core/observer/index.js 123456789101112131415161718192021222324252627282930313233export class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that has this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 /* 将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考/src/core/util/lang.js*/ def(value, '__ob__', this) if (Array.isArray(value)) &#123; /*如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。*/ const augment = hasProto ? protoAugment /*直接覆盖原型的方法来修改目标对象*/ : copyAugment /*定义（覆盖）目标对象或数组的某一个方法*/ augment(value, arrayMethods, arrayKeys) /*如果是数组则需要遍历数组的每一个成员进行observe*/ this.observeArray(value) &#125; else &#123; /*如果是对象则直接walk进行绑定*/ this.walk(value) &#125;, walk (obj: Object) &#123; const keys = Object.keys(obj) /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/ for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i], obj[keys[i]]) &#125; &#125; &#125; 首先将Observer实例绑定到data的ob属性上面去，防止重复绑定 若data为数组，线实现对应的变异方法(这里变异方法是指Vue重写了数组的7种原生方法)，再将数组的每个成员进行observer，使之成向响应式数据 否则执行walk()方法，遍历data所有的数据，进行getter/setter绑定。这里的核心方法就是defineReative(obj,[keys[i],obj[key[i]]]) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364export function defineReactive ( obj: Object, key: string, val: any, customSetter?: Function) &#123; /*在闭包中定义一个dep对象*/ const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/ // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set /*对象的子对象递归进行observe并返回子节点的Observer对象*/ let childOb = observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; /*如果原本对象拥有getter方法则执行*/ const value = getter ? getter.call(obj) : val if (Dep.target) &#123; /*进行依赖收集*/ dep.depend() if (childOb) &#123; /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/ childOb.dep.depend() &#125; if (Array.isArray(value)) &#123; /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/ dependArray(value) &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/ const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) &#123; customSetter() &#125; if (setter) &#123; /*如果原本对象拥有setter方法则执行setter*/ setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; /*新的值需要重新进行observe，保证数据响应式*/ childOb = observe(newVal) /*dep对象通知所有的观察者*/ dep.notify() &#125; &#125;)&#125; 其中getter方法 先为每个data声明一个Dep实例对象，被用于getter时执行dep.depend()进行收集相关的依赖； 根据Dep.target来判断是否收集依赖，还是普通取值。Dep.target是在什么时候，如何收集的后面再说明，先简单了解它的作用 123456789101112new Vue(&#123; template: `&lt;div&gt; &lt;span&gt;text1:&lt;/span&gt; &#123;&#123;text1&#125;&#125; &lt;span&gt;text2:&lt;/span&gt; &#123;&#123;text2&#125;&#125; &lt;div&gt;`, data: &#123; text1: 'text1', text2: 'text2', text3: 'text3' &#125;&#125;); data中text3并没有被模板实际用到，为了提高代码执行效率，我们没有必要对其进行响应式处理，因此，依赖收集简单点理解就是收集只在实际页面中用到的data数据，然后打上标记，这里就是标记为Dep.target 在setter方法中： 获取新的值并且进行observer,保证数据响应式 通过dep对象通过所有观察者去更新数据，从而达到响应式原理 在Observer类中，我们可以看到在getter时，dep会收集相关依赖，即收集依赖的watcher，然后在setter操作时候通过dep去通知watcher，此时watcher就执行变化，其实我们可以简单理解：Dep可以看做是书店，Watcher就是书店订阅者，而Observer就是书店的书，订阅者在书店订阅数据，就可以添加订阅者信息，一旦有新书就会通过书店给订阅者发送消息 3. WatcherWatcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Dep的subs中，数据变动的时候Dep会通知Watcher实例，然后由Watcher实例回调cb进行视图的更新 src/core/observer/watcher.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204export default class Watcher &#123; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: Object ) &#123; this.vm = vm /*_watchers存放订阅者实例*/ vm._watchers.push(this) // options if (options) &#123; this.deep = !!options.deep this.user = !!options.user this.lazy = !!options.lazy this.sync = !!options.sync &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false &#125; this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.lazy // for lazy watchers this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '' // parse expression for getter /*把表达式expOrFn解析成getter*/ if (typeof expOrFn === 'function') &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = function () &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed watching path: \"$&#123;expOrFn&#125;\" ` + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm ) &#125; &#125; this.value = this.lazy ? undefined : this.get() &#125; /** * Evaluate the getter, and re-collect dependencies. */ /*获得getter的值并且重新进行依赖收集*/ get () &#123; /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/ pushTarget(this) let value const vm = this.vm /*执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。 在将Dep.target设置为自生观察者实例以后，执行getter操作。 譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c， 那么在执行getter的时候就会触发a跟c两个数据的getter函数， 在getter函数中即可判断Dep.target是否存在然后完成依赖收集， 将该观察者对象放入闭包中的Dep的subs中去。*/ if (this.user) &#123; try &#123; value = this.getter.call(vm, vm) &#125; catch (e) &#123; handleError(e, vm, `getter for watcher \"$&#123;this.expression&#125;\"`) &#125; &#125; else &#123; value = this.getter.call(vm, vm) &#125; // \"touch\" every property so they are all tracked as // dependencies for deep watching /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/ if (this.deep) &#123; /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/ traverse(value) &#125; /*将观察者实例从target栈中取出并设置给Dep.target*/ popTarget() this.cleanupDeps() return value &#125; /** * Add a dependency to this directive. */ /*添加一个依赖关系到Deps集合中*/ addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125; &#125; /** * Clean up for dependency collection. */ /*清理依赖收集*/ cleanupDeps () &#123; /*移除所有观察者对象*/ ... &#125; /** * Subscriber interface. * Will be called when a dependency changes. */ /* 调度者接口，当依赖发生改变的时候进行回调。 */ update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; /*同步则执行run直接渲染视图*/ this.run() &#125; else &#123; /*异步推送到观察者队列中，下一个tick时调用。*/ queueWatcher(this) &#125; &#125; /** * Scheduler job interface. * Will be called by the scheduler. */ /* 调度者工作接口，将被调度者回调。 */ run () &#123; if (this.active) &#123; /* get操作在获取value本身也会执行getter从而调用update更新视图 */ const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. /* 即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。 */ isObject(value) || this.deep ) &#123; // set new value const oldValue = this.value /*设置新的值*/ this.value = value /*触发回调*/ if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue) &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher \"$&#123;this.expression&#125;\"`) &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue) &#125; &#125; &#125; &#125; /** * Evaluate the value of the watcher. * This only gets called for lazy watchers. */ /*获取观察者的值*/ evaluate () &#123; this.value = this.get() this.dirty = false &#125; /** * Depend on all deps collected by this watcher. */ /*收集该watcher的所有deps依赖*/ depend () &#123; let i = this.deps.length while (i--) &#123; this.deps[i].depend() &#125; &#125; /** * Remove self from all dependencies' subscriber list. */ /*将自身从所有依赖收集订阅列表删除*/ teardown () &#123; ... &#125;&#125; 4. Dep被Observer的data在触发getter时，Dep就会收集依赖的Watcher，其实Dep就像刚才说的是一个书店，可以接受多个订阅者的订阅，当有新书时即在data变动时，就会通过Dep给Watcher发通知进行更新 src/core/observer/dep.js 123456789101112131415161718192021222324252627282930313233343536export default class Dep &#123; static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id = uid++ this.subs = [] &#125; /*添加一个观察者对象*/ addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; /*移除一个观察者对象*/ removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; /*依赖收集，当存在Dep.target的时候添加观察者对象*/ depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; /*通知所有订阅者*/ notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 总结 在Vue中模板编译过程中的指令或者数据绑定都会实例化一个Watcher实例，实例化过程中会触发get()将自身指向Dep.target; data在Observer时执行getter会触发dep.depend()进行依赖收集；依赖收集的结果：1. data在Observer时闭包的dep实例的subs添加观察它的Watcher实例；2. Watcher的deps中添加观察对象Observer时的闭包dep 当data中被Observer的某个对象值变化后，触发subs中观察它的watcher执行update()，方法，最后实际上是调用watcher的回调函数cb，进而更新视图。","categories":[],"tags":[]},{"title":"uni-app 快速入门 从零开始实现新闻资讯类跨端应用(2)","slug":"uni-app 快速入门 从零开始实现新闻资讯类跨端应用(2)","date":"2021-06-18T10:03:16.927Z","updated":"2021-06-20T06:32:18.686Z","comments":true,"path":"posts/2889/","link":"","permalink":"http://blog.liurugang.cn/posts/2889/","excerpt":"","text":"uni-app 快速入门 从零开始实现新闻资讯类跨端应用(2)四、uniCloud （云开发平台）的基础用法1. 认识uniCloud开发 uniCloud是基于serverless模式和js编程的云开发平台 用javascript开发前后台真题业务，开发成本大幅下降，只需专注业务 非H5,免域名使用服务器 uniCloud开发流程 uniCloud构成 云函数 云数据库 云存储和CDN 2. HBuilderX 中配置 uniCloud 环境第一步：确保uni-app应用标识处于获取状态 第二步：右键cloudfunctions创建云服务空间，回来后再次右键选择关联服务空间 ！！！ 注意：创建云函数后要点击右键部署到云开发平台 3. 使用 uniCloud web 控制台方式： 右键cloudfunctions就可以打开uniCloud web控制台 注意： 在云数据库中，所有字段和值都要用双引号。 localhost在uni-app中已经自动解决了跨域问题，如果要通过本机的ip访问云服务器就得在云控制台中进行跨域配置 项目可以直接使用云存储的图片，视频的链接，也可以直接上传文件到云存储 4. 开始使用云函数云函数 get_list/index.js 1234567891011'use strict';exports.main = async (event, context) =&gt; &#123; //event为客户端上传的参数 //context 包含了调用信息和运行状态，每次调用的上下文 console.log('event : ', event) //返回数据给客户端 return &#123; \"content\":\"成功\", \"event\":event &#125;&#125;; 页面index.vue 12345678910111213141516uniCloud.callFunction(&#123; &#x2F;&#x2F;调用云函数 name: &quot;get_list&quot;, &#x2F;&#x2F;传的参数 data: &#123; &quot;name&quot;:&quot;hzy&quot; &#125;, &#x2F;&#x2F;成功回调 success(res) &#123; console.log(&#39;云函数调用成功&#39;,res.result); &#125;, &#x2F;&#x2F;失败回调 fail(res) &#123; console.log(&#39;云函数调用失败&#39;,res); &#125;&#125;) 点击调用之后 5. 云数据库的添加和删除1234567891011121314151617181920212223'use strict';const db = uniCloud.database(); //1、获取数据库的引用// 获取 `user` 集合的引用exports.main = async (event, context) =&gt; &#123; const collection = db.collection('user'); //2、获取集合的引用 //给集合添加一条记录，就是添加一个json对象 //添加await 之后数据才能同步 let res = await collection.add( [ &#123; \"name\": \"angular\", \"age\": 60 &#125;, &#123; \"name\": \"gofa\", \"age\": 100 &#125; ] ) //删除云数据库中的记录，要传入ID,先用doc()找到，再用remove()删除 let res = await collection.doc('5fd8e308fb0f850001897146').remove() return &#123;&#125;&#125;; 6. 数据库的更新和查找 更新数据 1234567891011121314'use strict';const db = uniCloud.database(); //1、获取数据库的引用// 获取 `user` 集合的引用exports.main = async (event, context) =&gt; &#123; const collection = db.collection('user'); //2、获取集合的引用 //更新数据库记录，先用doc()找到，再用update()更新，也可以用set()来更新 //可以增加字段，减少字段，修改字段 //update() 只能更新存在的记录 //set 如果记录存在就更新，如果不存在就添加 const res = await collection.doc('5fd8e308fb0f850001897146').update( name:\"likeReact\" ) return &#123;&#125;&#125;; 查找数据 123456789101112131415'use strict';const db = uniCloud.database(); //1、获取数据库的引用// 获取 `user` 集合的引用exports.main = async (event, context) =&gt; &#123; const collection = db.collection('user'); //2、获取集合的引用 //查询，先通过doc()找到这条记录，再用get()把记录拿到 //doc()只能应用id，不能应用其他字段 const docRes = await collection.doc(\"5fd8e308fb0f850001897146\").get() //where(),可以通过字段名称来找到记录，注意，需要传对象 const whereRes = await collection.where(&#123; name:\"vue\" &#125;).get() console.log(JSON.stringify(whereRes)) return &#123;&#125;&#125;; 7. 使用云储存上传文件123456789101112131415'use strict';const db = uniCloud.database(); //1、获取数据库的引用// 获取 `user` 集合的引用exports.main = async (event, context) =&gt; &#123; const collection = db.collection('user'); //2、获取集合的引用 //查询，先通过doc()找到这条记录，再用get()把记录拿到 //doc()只能应用id，不能应用其他字段 const docRes = await collection.doc(\"5fd8e308fb0f850001897146\").get() //where(),可以通过字段名称来找到记录，注意，需要传对象 const whereRes = await collection.where(&#123; name:\"vue\" &#125;).get() console.log(JSON.stringify(whereRes)) return &#123;&#125;&#125;;","categories":[],"tags":[]},{"title":"uni-app 快速入门 从零开始实现新闻资讯类跨端应用(1)","slug":"uni-app 快速入门 从零开始实现新闻资讯类跨端应用(1)","date":"2021-06-18T09:52:12.234Z","updated":"2021-06-20T06:32:18.692Z","comments":true,"path":"posts/64329/","link":"","permalink":"http://blog.liurugang.cn/posts/64329/","excerpt":"","text":"uni-app 快速入门 从零开始实现新闻资讯类跨端应用一、微信小程序基础1.初始化文件目录结构 123456789101、utils文件夹主要存放工具类 pages目录存放所有页面代码 app.js是文件入口 app.jasn是项目配置 app.wxss是全局样式表2、index目录 index.js当前页面的业务逻辑 index.json当前页面的配置文件 index.wxml当前页面模板 index.wxss当前页面的样式 2.数据绑定，条件判断、列表渲染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//必须使用Page构造器来构造页面Page(&#123; /** * 页面的初始数据 */ data: &#123; name:'hzy', is_ok:false, list:['1','2','3','4'] &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; //改变数据的方法this.setData(obj) //this是指当前对象的实例，指向Page setTimeout(()=&gt;&#123;this.setData(&#123;name:'wwj',is_ok:true&#125;)&#125;,2000) &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; &#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123; &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; &#125;&#125;) index.wxml 1234567891011121314&lt;!--pages/index/index.wxml--&gt;&lt;text wx:if=\"&#123;&#123;is_ok&#125;&#125;\"&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt;&lt;!--text 是行级元素，相当于span--&gt;&lt;!--wx:if 控制标签是否渲染--&gt;&lt;view wx:for=\"&#123;&#123;list&#125;&#125;\"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;&lt;!--view 是块级元素，相当于div--&gt;&lt;!--wx:for 控制标签循环渲染--&gt;&lt;!--item 是指当前变量默认值 index 是指当前下标默认值--&gt;&lt;!-- &lt;view wx:for=\"&#123;&#123;list&#125;&#125;\" wx:for-item=\"list\"&gt;&#123;&#123;list&#125;&#125;&lt;/view&gt; 等价于 &lt;view wx:for=\"&#123;&#123;list&#125;&#125;\"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;--&gt; 二、uni-app基础1.uni-app核心知识点概况1.1 uni-app规范 页面文件遵循Vue单文件组件规范 组件标签接近小程序规范 接口能力(JS API)靠近小程序规范 数据绑定及事件处理同Vue.js规范 为兼容多端运行，建议使用flex布局进行开发 1.2 uni-app 特色 条件编译 App端的Nvue开发法 HTML5+ uni-app环境搭建 Hbuilder直接创建 vue-cli命令行创建 1231、npm install -g @vue&#x2F;cli 安装vue-cli2、 vue -V 查看vue-cli版本，是否安装成功3、 vue create -p dcloudio&#x2F;uni-preset-vue 名称 安装uni-app项目 uni-app 模板语法和数据绑定 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;view v-bind:class&#x3D;&quot;className&quot; v-on:click&#x3D;&quot;open&quot;&gt; &#123;&#123;title&#125;&#125; &lt;&#x2F;view&gt; &lt;!-- v-bind:表示class的值为动态 --&gt; &lt;!-- 与小程序不同的是这里的v-bind:class,直接赋值，而不用&#123;&#123;&#125;&#125; --&gt; &lt;!-- :是v-bind:简写 --&gt; &lt;!-- @是v-on:简写 --&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; &#x2F;&#x2F;初始化数据 data() &#123; return &#123; title: &#39;两秒之前&#39;, className:&#39;bul&#39; &#125; &#125;, onLoad() &#123; &#125;, &#x2F;&#x2F;自定义的事件方法写到methods里面 methods: &#123; &#x2F;&#x2F;两秒之后修改title和className open()&#123; setTimeout(()&#x3D;&gt;&#123; this.title&#x3D;&quot;两秒之后&quot; this.className&#x3D;&quot;gre&quot; &#x2F;&#x2F;this指向view实例，赋值方便，不用setstate和setData &#125;,2000) &#125; &#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt; .bul &#123; color: #007AFF; &#125; .gre&#123; color: #4CD964; &#125;&lt;&#x2F;style&gt; uni-app 条件判断 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;view&gt; &lt;view&gt;这是一直显示的内容&lt;&#x2F;view&gt; &lt;view&gt; &lt;view v-if&#x3D;&quot;show&#x3D;&#x3D;&#x3D;&#39;vue&#39;&quot;&gt;&#123;&#123;show&#125;&#125;&lt;&#x2F;view&gt; &lt;view v-else-if&#x3D;&quot;show&#x3D;&#x3D;&#x3D;&#39;react&#39;&quot;&gt;&#123;&#123;show&#125;&#125;&lt;&#x2F;view&gt; &lt;view v-else&gt;uni-app&lt;&#x2F;view&gt; &lt;&#x2F;view&gt; &lt;!-- v-if: 指令的表达式返回true才会渲染 --&gt; &lt;button @click&#x3D;&quot;isShow()&quot;&gt;点击&lt;&#x2F;button&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; show: &#39;vue&#39; &#125; &#125;, onLoad() &#123;&#125;, methods: &#123; isShow() &#123; this.show &#x3D; this.show &#x3D;&#x3D;&#x3D; &#39;vue&#39; ? &#39;react&#39; : &#39;vue&#39; &#125; &#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; uni-app 列表渲染 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;view&gt; &lt;!-- 列表渲染，通过数组来渲染列表 --&gt; &lt;view v-for&#x3D;&quot;(item,index) in arr&quot;&gt;&#123;&#123;index+1+&#39; &#39;+item&#125;&#125;&lt;&#x2F;view&gt; &lt;!-- item:被迭代的数组元素的别名 --&gt; &lt;!-- index:被迭代的数组元素的下标 --&gt; &lt;view v-for&#x3D;&quot;(value,key) in obj&quot;&gt;&#123;&#123;key+&#39; : &#39;+value&#125;&#125;&lt;&#x2F;view&gt; &lt;!-- 同时也可以遍历对象 可以获取value和key, 顺序不要弄错--&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; arr:[&#39;uni-app&#39;,&#39;vue&#39;,&#39;react&#39;], obj:&#123; name:&#39;hzy&#39;, age:18, type:&#39;man&#39;, &#125; &#125; &#125;, onLoad() &#123;&#125;, methods: &#123; &#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; uni-app 基础组件使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;!-- uni-app基础组件使用，view也是基础组件，相当于html的div标签 --&gt; &lt;view&gt; &lt;view&gt;view标签：&lt;&#x2F;view&gt; &lt;view hover-class&#x3D;&quot;redd&quot;&gt;vue&lt;&#x2F;view&gt; &lt;!-- hover-class指定点击下去的样式类 --&gt; &lt;view&gt;react&lt;&#x2F;view&gt; &lt;view&gt;text标签：&lt;&#x2F;view&gt; &lt;text&gt;vue&lt;&#x2F;text&gt; &lt;text&gt;react&lt;&#x2F;text&gt; &lt;!-- text标签相当于html的span,行内元素--&gt; &lt;scroll-view scroll-y&#x3D;&quot;true&quot; class&#x3D;&quot;height&quot; @scroll&#x3D;&quot;scroll&quot;&gt; &lt;view v-for&#x3D;&quot;item in 20&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;view&gt; &lt;&#x2F;scroll-view&gt; &lt;!-- 可滚动视图区域，必须设置高度 --&gt; &lt;!-- @scroll触发滚动时候的响应事件 --&gt; &lt;button type&#x3D;&quot;default&quot; @click&#x3D;&quot;input&quot;&gt;点击&lt;&#x2F;button&gt; &lt;!-- &lt;input type&#x3D;&quot;text&quot; v-bind:value&#x3D;&quot;value&quot;&gt; --&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;value&quot;&gt; &lt;view&gt;&#123;&#123;value&#125;&#125;&lt;&#x2F;view&gt; &lt;!-- value前面得加上v-bind:表示他是个动态绑定的值,或者使用v-model，指的是双向绑定 --&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; value: &#39;vue&#39; &#125; &#125;, onLoad() &#123;&#125;, methods: &#123; scroll(e) &#123; console.log(e) &#125;, input() &#123; this.value &#x3D; this.value &#x3D;&#x3D;&#x3D; &#39;vue&#39; ? &#39;react&#39; : &#39;vue&#39; &#125; &#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt; .redd &#123; border: 1px red solid; &#125; .height &#123; height: 50px; border: 1px red solid; &#125;&lt;&#x2F;style&gt; uni-app 自定义组件 123456789101112131415161718192021222324252627&lt;template&gt; &lt;view&gt; &lt;hzyBtn color&#x3D;&quot;blue&quot; @change&#x3D;&quot;change&quot;&gt;&lt;&#x2F;hzyBtn&gt; &lt;!-- 让组件去接收一个名为change的事件 --&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; &#x2F;&#x2F;在script标签下引用自定义组件,@表示的事根目录 import but from &#39;@&#x2F;components&#x2F;hzyBtn&#x2F;hzyBtn.vue&#39; export default &#123; data() &#123; return &#123; &#125; &#125;, onLoad() &#123;&#125;, methods: &#123; change(e) &#123; console.log(&#39;页面的事件被触发,组件返回了：&#39; + e) &#125; &#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; hzyBtn.vue 自定义按钮组件 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;view class&#x3D;&quot;btn-box&quot; :style&#x3D;&quot;&#123;color:color&#125;&quot; @click&#x3D;&quot;butClick&quot;&gt; 点击 &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; props: &#123; color: &#123; type: String, default: &#39;#000&#39; &#125;, &#x2F;&#x2F; color接受一个类型为String的对象,默认值为&#39;#000&#39; &#125;, &#x2F;&#x2F; props接收属性 data() &#123; return &#123;&#125;; &#125;, methods: &#123; butClick() &#123; console.log(&#39;组件内事件触发&#39;) this.$emit(&#39;change&#39;, this.color) &#x2F;&#x2F;触发页面传来的‘change’事件 &#125; &#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt; .btn-box &#123; width: 200px; height: 100px; text-align: center; line-height: 100px; border: 1px red solid; &#125;&lt;&#x2F;style&gt; 页面 点击之后控制台打印 uni-app基础api使用 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;view&gt;&lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123;&#125; &#125;, onLoad() &#123; uni.getSystemInfo(&#123; success(res) &#123; console.log(&#39;成功的回调&#39;, res) &#125;, fail(err) &#123; console.log(&#39;失败的回调&#39;, err) &#125;, complete(res) &#123; console.log(&#39;不管成功失败都会返回&#39;) &#125; &#125;) &#x2F;&#x2F;uni.getSystemInfo(obj)获取系统信息的api,异步的 &#125;, &#x2F;&#x2F; onLoad()只加载一次，监听页面加载，其参数为上个页面传递的数据，参数类型为Object methods: &#123;&#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; uni-app条件编译 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;view&gt; &lt;!-- 条件编译写在对应的注释里 --&gt; &lt;!-- 表示在h5和app端才进行这段代码的编译 --&gt; &lt;!-- #ifdef H5 || APP-PLUS--&gt; &lt;view&gt;h5和app平台才显示&lt;&#x2F;view&gt; &lt;!-- #endif --&gt; &lt;!-- #ifndef MP-WEIXIN --&gt; &lt;view&gt;微信小程序不显示，其他都显示&lt;&#x2F;view&gt; &lt;!-- #endif --&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123;&#125; &#125;, onLoad() &#123; &#125;, methods: &#123; &#x2F;&#x2F; #ifdef &#x2F;&#x2F; #endif &#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt; &#x2F;* #ifdef *&#x2F; &#x2F;* #endif *&#x2F;&lt;&#x2F;style&gt; uni-app页面布局 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;view class&#x3D;&quot;content color&quot;&gt;uni-app&lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123;&#125; &#125;, onLoad() &#123; &#125;, methods: &#123;&#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt; @import &#39;index.css&#39;; &#x2F;* 引入外部css方式 *&#x2F; &#x2F;* page&#123;&#125;等价于body&#123;&#125; *&#x2F; page &#123; background-color: #007AFF; &#125; &#x2F;* 尺寸单位*&#x2F; .content &#123; &#x2F;* px rpx rem vh vx*&#x2F; font-size: 50px; &#125;&lt;&#x2F;style&gt; uni-app生命周期 应用生命周期(定义在app.vue页面中) 12345678910111213141516171819202122232425&lt;script&gt; &#x2F;&#x2F; 生命周期分为三种: &#x2F;&#x2F; 应用生命周期：定义在app.vue页面中 &#x2F;&#x2F; 页面生命周期 &#x2F;&#x2F; 组件生命周期 export default &#123; &#x2F;&#x2F;应用初始化完成触发一次，全局只触发一次 &#x2F;&#x2F;可以做一些登录的事情，或者拿一些全局变量 onLaunch: function() &#123; console.log(&#39;App Launch&#39;) &#125;, &#x2F;&#x2F;应用启动的时候，或者从后台进入前台会触发 onShow: function() &#123; console.log(&#39;App Show&#39;) &#125;, &#x2F;&#x2F;应用从前台进入后台触发 onHide: function() &#123; console.log(&#39;App Hide&#39;) &#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt; &#x2F;*每个页面公共css *&#x2F;&lt;&#x2F;style&gt; 页面生命周期 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;view&gt; &lt;view&gt;生命周期&lt;&#x2F;view&gt; &lt;hzyText&gt;&lt;&#x2F;hzyText&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; import hzyText from &#39;@&#x2F;components&#x2F;hzyText&#x2F;hzyText.vue&#39; export default &#123; data() &#123; return &#123;&#125; &#125;, &#x2F;&#x2F;监听页面加载（页面加载之后执行，再次加载时候不执行，浏览器有缓存） onLoad() &#123; console.log(&#39;page onLoad&#39;) &#125;, &#x2F;&#x2F;监听页面初次渲染完成 onReady() &#123; &#x2F;&#x2F;如果渲染速度快，会在页面进入动画完成前触发 console.log(&#39;page onReady&#39;) &#125;, &#x2F;&#x2F;监听页面显示，页面每次出现在屏幕上都会触发 onShow()&#123; console.log(&#39;page onShow&#39;) &#125;, &#x2F;&#x2F;监听页面隐藏 onHide()&#123; console.log(&#39;page onHide&#39;) &#125;, &#x2F;&#x2F;监听页面卸载 onUnload()&#123; console.log(&#39;page onUnload&#39;) &#125;, methods: &#123;&#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; 组件生命周期 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;view&gt; hzyText组件 &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; &#125;; &#125;, &#x2F;&#x2F;在实例初始化之后，数据观测（data observer)和event&#x2F;watcher事件配置之前被调用 beforeCreate() &#123; console.log(&#39;beforeCreate&#39;) &#125;, &#x2F;&#x2F;实例创建完成之后立即调用，挂载阶段还没开始 created() &#123; console.log(&#39;created&#39;) &#125;, &#x2F;&#x2F;挂载到实例上去之后调用 mounted() &#123; console.log(&#39;mounted&#39;) &#125;, &#x2F;&#x2F;Vue实例销毁后调用 destroyed() &#123; console.log(&#39;destroyed&#39;) &#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; 项目基础配置1. uni-app项目配置 微信小程序，微信开发者工具要在设置的安全中打开服务端口，Hx才能启用 安卓真机，手机连接电脑后，点击关于手机，点击五次版本号，进入开发者模式，开启usb调试，打开传输文件 H5 2. uni-app目录结构了解目录结构 1、componens - 自定义组件目录2、pages - 页面存放目录 （里面页面的目录和文件需同名 例如：logon中的logon.vue）3、static - 静态文件资源目录（图片和字体可以放在该目录）4、unpackage - 编译后的文件存放目录5、utils - 自定义存放工具类的目录6、common - 自定义存放公用东西的目录7、App.vue - 页面入口（可以做用户登录、项目初始话、全局样式更改等）8、main.js - 应用入口9、manifest.json - 项目配置10、pages.json - 页面配置11、readme.md - 项目基本情况12、uni.scss - uni-app内置的常用样式变量 3. 配置项目底部选项卡pages.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&#123; //\"pages\"：注册页面文件，页面窗口表现形式 \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages &#123; \"path\": \"pages/index/index\", \"style\": &#123; \"navigationBarTitleText\": \"uni-app\", //app平台下特有窗口表现样式 \"app-plus\": &#123; &#125;, //微信小程序平台下特有窗口表现样式 \"mp-weixin\": &#123; &#125;, //h5平台下特有窗口表现样式 \"h5\": &#123; &#125; &#125; &#125; ,&#123; \"path\" : \"pages/about/about\", \"style\" : &#123; \"navigationBarTitleText\": \"\", \"enablePullDownRefresh\": false &#125; &#125; ,&#123; \"path\" : \"pages/my/my\", \"style\" : &#123; \"navigationBarTitleText\": \"\", \"enablePullDownRefresh\": false &#125; &#125; ], //\"globalStyle\"所有页面的默认配置，当\"pages\"下配置了和\"globalStyle\"一样的属性，就会将 \"globalStyle\"中的属性覆盖 \"globalStyle\": &#123; \"navigationBarTextStyle\": \"black\", \"navigationBarTitleText\": \"uni-app\", \"navigationBarBackgroundColor\": \"#F8F8F8\", \"backgroundColor\": \"#F8F8F8\" &#125;, //\"tabBar\"指得是tab栏的表现 \"tabBar\":&#123; \"color\":\"#666\", \"selectedColor\":\"#ff5a5f\",//选中时候的颜色 \"borderStyle\":\"black\", //tabBar关联页面 \"list\":[ &#123; \"pagePath\":\"pages/index/index\", \"text\":\"首页\", \"iconPath\":\"static/home.png\",//本地图片，大小40kb，尺寸81*81px \"selectedIconPath\":\"static/home-active.png\"//选中后图片 &#125;, &#123; \"pagePath\":\"pages/about/about\", \"text\":\"关于\", \"iconPath\":\"static/follow.png\",//本地图片，大小40kb，尺寸81*81px \"selectedIconPath\":\"static/follow-active.png\"//选中后图片 &#125;, &#123; \"pagePath\":\"pages/my/my\", \"text\":\"我的\", \"iconPath\":\"static/my.png\",//本地图片，大小40kb，尺寸81*81px \"selectedIconPath\":\"static/my-active.png\"//选中后图片 &#125; ] &#125;&#125; 总结：页面有个可以写onTabItemTap(e) { }，这个生命周期函数是点击tebbar时候触发 4. 在uni-app 中使用sass 安装scss插件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;view class&#x3D;&quot;content box&quot;&gt; &lt;image class&#x3D;&quot;logo&quot; src&#x3D;&quot;&#x2F;static&#x2F;logo.png&quot;&gt;&lt;&#x2F;image&gt; &lt;view class&#x3D;&quot;text-area&quot;&gt; &lt;text class&#x3D;&quot;title&quot;&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;text&gt; &lt;&#x2F;view&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; title: &#39;Hello&#39; &#125; &#125;, onLoad() &#123; &#125;, &#x2F;&#x2F;tabbar点击触发的钩子 onTabItemTap(e) &#123; console.log(e) &#125;, methods: &#123; &#125; &#125;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;scss&quot;&gt; &#x2F;&#x2F; scss可以写样式可以一层套一层 $width : 200rpx; &#x2F;&#x2F;变量定义用$ .content &#123; display: flex; flex-direction: column; align-items: center; justify-content: center; &#x2F;&#x2F;&amp;表示父级 box和content是同级的样式 &amp;.box&#123; border: 1px red solid; &#125; .logo &#123; height: $width; width: $width; margin-top: $width; margin-left: auto; margin-right: auto; margin-bottom: 50rpx; &#125; .text-area &#123; display: flex; justify-content: center; .title &#123; font-size: 36rpx; color: #8f8f94; &#125; &#125; &#125;&lt;&#x2F;style&gt; 注意：style标签中得写lang=”scss”来引用scss","categories":[],"tags":[]},{"title":"面试题整理(答案)","slug":"面试题整理(答案)","date":"2021-06-15T08:00:47.136Z","updated":"2021-06-22T00:36:49.672Z","comments":true,"path":"posts/19926/","link":"","permalink":"http://blog.liurugang.cn/posts/19926/","excerpt":"","text":"面试题整理(答案)CSS1. 介绍一下标准的css的盒子模型，与低版本IE的盒子模型有什么不同？介绍一下box-sizing属性答案： 标准盒模型 ： 宽度 = 内容的宽度(content)+ border + padding + margin怪异盒模型： 宽度 =内容宽度(content + border+ padding)+ margin box-sizing主要是用来计算一个元素中宽度和高度的总和的值，而具体的计算方式将会根据box-sizing的属性值来决定，共有两个属性值:content-box和border-box content-box:一个标准模式下的盒模型的计算方式 border-box：一个怪异模式下的盒模型的计算方式 2. css选择器有哪些？哪些属性可以继承？ css选择器： id选择器(#myid)，类选择器(.myclassname)，标签选择器(div h1 p) 相邻选择器(h1+ p) , 子选择器(ul &gt;li) ,后代选择器(li a) 通配符选择器(*) ,属性选择器(a[[rel=”external”]])，伪类选择器(a:hover) 可继承的属性： font-size，font-family，color 不可继承的属性: border，padding，margin，width，height 3. CSS优先级如何计算元素选择符： 1 class 选择符： 10 id选择符: 100 元素标签： 1000 !important声明的样式优先级最高 如果优先级相同，则选择最后出现的样式 继承得到的样式的优先级最低 4. 如何让一个div水平垂直居中 水平居中 行内元素 123.parent&#123; text-align:center;&#125; 块级元素 块级元素一般居中方法 123.son&#123; margin: 0 auto&#125; 子元素含float 1234567.parent&#123; width: fit-content; // 固定的宽度 margin：0 auto&#125;.son&#123; float: left&#125; Flex 1234.parent&#123; display:flex; justify-content：center;&#125; 绝对定位 transform 12345.son&#123; position:absolute; left:50%; transform: translate(-50%,0)&#125; left:50% 123456.son&#123; position: absolute; width:宽度 left：50%; margin-left: -0.5*宽度&#125; left/right: 0 1234567.son&#123; position: absolute; width:宽度; left： 0； right：0； margin: 0 auto; &#125; 垂直居中 行内元素 123456.parent&#123; height:高度;&#125;.son&#123; line-height: 高度;&#125; 块级元素 table 1234567.parent&#123; display:table;&#125;.son&#123; display:table-cell; vertical-align:middle;&#125; flex 1234.parent&#123; display:flex; align-items:center;&#125; transform 12345.son&#123; position:absolute; top:50%; transform:translate(0,-50%)&#125; top: 50% 123456.son&#123; position: absolute; top:50%; height:高度 margin-top:-0.5高度 &#125; top/bottom:0 123456.son&#123; position:absolute; top:0; bottom:0; margin:auto 0;&#125; 5. 常见的布局有哪些 流体布局 123456789101112131415161718192021222324252627&lt;style&gt; .left&#123; float:left; height:200px; width:100px; background-color:red; &#125; .right&#123; width:200px; height:200px; background-color:blue; float:right; &#125; .main&#123; margin-left:120px; margin-right:220px; height:200px; background-color:green; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 左右模块各自向左右浮动，并设置中间模块的margin值使得中间模块宽度自适应 缺点是主要内容无法最先加载，当页面内容较多时会影响用户体验 双飞翼布局 123456789101112131415161718192021222324252627282930313233&lt;style&gt; .content&#123; float:left; width:100%; &#125; .main&#123; height:200px; margin-left:110px; margin-right:220px; background-color:green; &#125; .left&#123; float:left; height:200px; width:100px; margin-left:-100%; background-color:red; &#125; .right&#123; width:200px; height:200px; float:right; margin-left:-200px; background-color:blue; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/body&gt; 利用的是浮动元素margin负值的应用，主体内容可以优先加载 圣杯布局 1234567891011121314151617181920212223242526272829303132333435&lt;style&gt;.container&#123; margin-left:120px; margin-right:220px;&#125;.main&#123; float:left; width:100%; height:300px; background-color:red;&#125;.left&#123; float:left; width:100px; height:300px; margin-left:-100%; position:relative; left:-120px; background-color:blue;&#125;.right&#123; float:left; width:200px; height:300px; margin-left:-200px; position:relative; right:-220px; background-color:green;&#125;&lt;/style&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 优先加载内容主体 Flex布局 12345678910111213141516171819202122232425&lt;style&gt; .container&#123; display:flex; &#125; .main&#123; flex:1; height:300px; background-color:red; &#125; .left:&#123; width:200px; height;300px; background-color:blue; &#125; .right&#123; width:100px; height:300px; background-color:green &#125;&lt;/style&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 绝对定位布局 12345678910111213141516171819202122232425262728293031&lt;style&gt; .container&#123; position:relative; &#125; .main&#123; height:400px; margin:0 120px; background-color:green; &#125; .left&#123; position:absolute; width:100px; height:300px; left:0; top:0; background-color:red; &#125; .right&#123; position: absolute; width:100px; height:300px; background-color:blue; right:0; top:0 &#125;&lt;/style&gt;&lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 简单实用，主要内容可以优先加载 6. CSS3有哪些新特性选择器 css新增了很多选择器属性 123456Ele:nth-last-child(n)Ele:nth-of-type(n)Ele:emptyEle:checkedEle:enabledEle:disabled 盒模型 盒模型有三种：box-sizing:content-box|border-box|inherit 布局 新增了很多布局相关的属性，比如flex布局和多列布局 背景 background-origin当设置图片时，图片是以左上角对齐，但是以border的左上角对齐还是以padding的左上角或者content左上角对齐 border-box padding-box content-box background-clip该属性是用来设置背景延伸的范围，有四个值可选 border-box：背景延伸至边框外沿 padding-box:背景延伸至内边框外沿，不会绘制到边框处 content-box：背景被裁剪到内容区外沿 text：背景被裁剪成文字的前景色 background-size用以设置背景图片大小。单张图片的背景大小可以使用以下三种方法的一种来规定 使用关键词contain 使用关键词cover 设置宽度和高度值 边框 边框圆角 使用border-radius可以设置边框为圆角的，border-radius的值就是圆角边框的半径 边框图片 指定边框使用的图片 123.demo&#123; border-image: url(http://7xv39r.com1.z0.glb.clouddn.com/box.png) 27 27 27 27 / 10px / 10px;&#125; border-image: 图片url 图片边界向内偏移 图像边界的宽度 用于指定在边框外部绘制偏移的量 铺满方式 border-image-source 边框的图片路径 border-image-slice 边框向内偏移 border-image-width 边框的宽度 border-image-outset 变宽图像区域超出边框的量 border-image-repeat 边框是否应为平铺 铺满或拉伸 过渡 12transition: css属性，花费时间，效果曲线(默认ease),延迟时间(默认0)transition: width,0.5s,ease,.2s 动画 1animation: 动画名称，一个周期花费时间，运动曲线(默认ease),动画延迟(默认0),播放次数(默认1)，是否反向播放动画（默认normal），是否暂停动画(默认running) animation-name:动画名称 animation-duration:动画持续时间 animation-timing-function:动画时间函数 animation-delay:动画延迟时间 animation-iteration-count:动画执行次数 animation-direction:动画执行方向 123456789101112131415.box:hover&#123; animation-name: move; animation-duration:1s;&#125;@keyframes move&#123; 0%&#123; transform: translateX(0px); &#125; 50%&#123; transform: translateX(100px) &#125; 100%&#123; transform:translateY(100px) &#125;&#125; 7. 介绍一下flex布局 flex-direction flex-wrap justify-content align-items align-content flex-direction是用来设置主轴的，它有以下四个可选 row: 默认值，主轴为水平方向，起点在左端 row-reverse: 主轴为水平方向，起点在右端 column： 主轴为垂直方向，起点在上沿 column-reverse: 主轴为垂直方向，起点在下沿。 flex-wrap 换行方式 nowrap: 默认值，不换行 wrap：换行，第一行在上方 wrap-reverse: 换行，第一行在下方 justify-content 是用来设置item在container在主轴上的对齐方式 flex-start 左对齐 flex-end: 右对齐 center： 居中对齐 space-between: 两端对齐，项目之间间隔相等 space-around: 每个项目两侧的间隔相等。随意，项目之间的间隔比项目与边框的间隔大一倍 align-items定义项目在交叉轴上如何对齐 first-start : 往上对齐 first-end：往下对齐 center： 居中对齐 baseline：item的第一行文字的基线对齐 align-content属性定义了多根轴线的对齐方式。 flex-start: 与交叉轴的起点对齐 flex-end: 与交叉轴的终点对齐 center： 与交叉轴的中点对齐 space-between: 与交叉轴两端对齐，轴线之间的间隔平均分布 space-around：每根轴线两侧的间隔都相等 8. 关于BFC规范的理解BFC 名为块级格式化上下文。BFC是一个完全独立的空间，让空间里的子元素不会影响到外面的布局。 怎样触发BFC overflow： hidden display：inline-block position：absolute position：fixed display：flex float：left/right BFC规则 BFC就是块级元素，块级元素会在垂直方向一个接一个的排列 BFC就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签 垂直方向的距离由margin决定，属于同一个BFC的两个相邻的标签外边距会发生重叠 计算BFC的高度时，浮动元素也参与计算 BFC解决了什么问题 使用Float脱离文档流，高度塌陷 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;高度塌陷&lt;/title&gt; &lt;style&gt; .box &#123; margin: 100px; width: 100px; height: 100px; background: red; float: left; &#125; .container &#123; background: #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果 可以看到上面效果给box设置完float结果脱离文档流，使container高度没有被撑开，从而颜色没有出来，解决此问题可以给container触发BFC，上面我们所说的触发BFC属性都可以设置 Margin边距重叠 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; margin: 10px; width: 100px; height: 100px; background: #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果 可以看到我们为两个盒子的margin外边距设置的是10px可结果显示两个盒子之间只有10px的距离，这就导致了margin塌陷问题，这时margin边距的结果为最大值，而不是合，为了解决此问题可以使用BFC规则，或者简单粗暴方法一个设置margin，一个设置padding 9. 为什么会出现浮动和什么时候清浮动？清浮动方式 这肯定不是我们想要的渲染效果，它可能存在如下问题： 文字围绕浮动元素排板，但我们可能希望文字(.textDiv)排列在浮动元素下方，或者，我们并不希望.textDiv两边有浮动元素存在 浮动元素超出了其父级元素(.topDiv)，父元素的高度出现了坍塌，若没有文字高度的支撑，不考虑边框，父级元素高度会塌陷成零 浮动元素甚至影响其父元素的兄弟元素（.bottomDiv）排板。因为浮动元素怒脱离了文档流，(.bottomDiv)在计算元素位置的时候会忽略其影线，紧接着上一个元素的位置继续排列。 清除浮动的四种方法 给浮动元素的父元素添加高度(扩展性不好) clear:both在最后一个子元素新添加最后一个冗余元素，然后将其设置clear:both。这样就可以清除浮动 伪元素清浮动。 12345678.clearfix::after&#123; content:'', display:block; clear:both; height:0; line-height:0; visibility:hidden;&#125; 给浮动元素添加一个clearfix的class，然后给这个class添加一个::after伪元素，实现元素末尾添加一个看不见的块元素来清理浮动。 给父元素使用overflow:hidden 这种方案让父容器形成了BFC，而BFC可以包含浮动，通常用来解决浮动元素高度塌陷的问题 10. 浏览器是怎样解析CSS选择器的？CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。 而在CSS解析完毕后，需要将解析的结果与DOM Tree的内容一起分析建立一棵Render Tree,最终用来进行绘图，在建立Render Tree时，浏览器就要为每个DOM Tree中的元素根据CSS的解析结果来确定生成怎样的Render Tree 11. link和@import的区别@import是CSS提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载CSS文件。 加载页面时，link标签引入的CSS被同时加载；@import引入的CSS将在页面加载完毕后被加载 link不存在兼容性问题，但是@import在IE5+才能识别 link方式样式的权重高于@import的 12. 重绘和回流(重排) DOM的变化影响到了元素的几何属性(宽高)，浏览器重新计算元素的几何属性，其他元素的几何属性和位置也会受到影响，浏览器需要重新构造渲染树，这个过程称为重排。 浏览器将受到影响的部分重新绘制到屏幕上的过程称为重绘。 常见的引起重排属性和方法 任何改变元素的位置和尺寸大小的操作，都会触发重排 添加或删除可见的DOM元素 元素尺寸改变 内容变化，比如在input框中输入文字 浏览器窗口尺寸改变 计算offsetTop，offsetLeft等布局属性 设置style属性的值 优化方法 使用visibility:hidden替换display:none 将频繁重绘或重排的节点设置为图层 对于复杂动画效果，使用绝对定位让其脱离文档流 动态改变类而不改变样式 批量修改DOM 总结： 重排是因为元素的几何属性更改触发的 重绘是由于元素的绘制属性更改触发的 触发重排也一定会触发重绘，触发重绘不一定会触发重排 重排的成本高于重绘 13. 解决移动端下1px像素问题 border-image 12border:1px solid transparentborder-image:url('./../../image/96.jpg' norepeat) 图片的颜色就是此border的颜色 总结：优点：没有副作用 缺点：border颜色改变了，就得重新绘制图片，而且圆角会比较模糊 使用box-shadow实现 1234box-shadow: 0 -1px 1px -1px; 1px 0 1px -1px; 0 1px 1px -1px; -1px 0 1px -1px; 总结 优点：使用简单，圆角也可以实现 缺点：模拟的实现方法，仔细看就知道不是边框 使用伪元素 1234567891011121314.setOnePx&#123; position:relative &amp;::after&#123; position:absolute; content:&#39;&#39;; background-color:#e5e5e5; display:block; width:100%; height: 1px; transform:scale(1,0.5) top:0; left:0; &#125;&#125; 将伪元素设置相对定位，并且和父元素的左上角对齐，将width设置100%，height设置为1px，然后进行在Y方向缩小0.5倍 总结： 全机型兼容，实现了真正的1px而且可以圆角 缺点：暂用了after伪元素，可能影响到清浮动 设置viewport的scale的值 14.CSS动画有哪些 属性 含义 animation(动画) 用于设置动画属性，它是一个简写的属性，包含6个属性 transition(过渡) 用于设置元素的样式过渡，和animation有着类似的效果，但细节上有很大的不同 transform(变形) 用于元素进行旋转，缩放，移动或倾斜，和设置样式的动画并没有什么关系，就相当于color一样用来设置元素的外表 translate(移动) translate只是transform的一个属性值，即移动 transition 字面意思上来讲，就是元素从这个属性的某个值过渡到这个属性的另一个值，这是一个状态的转变，需要一种条件来触发这种转变，比如我们平常用到的:hover,:foucs 值 描述 transition-property 规定设置过渡效果的CSS属性的名称 transition-duration 规定完成过渡效果需要多少秒或毫秒 transition-timing-function 规定速度效果的速度曲线 transition-delay 定义过渡效果何时开始 animation 值 描述 name 用来调用@keyframes定义好的动画，与@keyframes定义的动画名称一致 duration 指定元素播放所持续的时间 timing-function 规定速度效果的速度曲线，是针对每一个小动画在时间范围的变换速率 delay 定义在浏览器开始执行动画之前等待的时间，值整个animation执行之前等待的时间 iteration-count 定义动画的播放次数，可选具体次数或无限(infinite) direction 设置动画播放方向 play-state 控制元素动画的播放状态，通过此来控制动画的暂停和继续 15. 如何实现小于12px的字体效果 transform:scale()这个属性只可以缩放定义宽高的元素，而行内元素是没有宽高，我们可以加上display:inline-block 1234p&#123; font-size:10px; -webkit-transform:scale(0.8); //0.8是缩放比例&#125; 16. px/em/rem/vw的区别 px: 是固定单位，其他几种都是相对单位 em：默认字体大小的倍数。比如给元素设置font-size:2em rem: 根元素(html节点)字体大小的倍数 1vw： 代表浏览器视口宽度的1% 17. 伪类和伪元素的区别伪类：伪类就是一个选择处于特定状态的元素的选择器，比如某一个class的第一个元素，某个被hover的元素等等。。我们可以理解成一个特定的CSS类，但与普通的类不一样，它只有处于DOM树无法描述的状态才能为元素添加样式，所以将其称为伪类 伪元素：伪元素类似于增添一个新的DOM节点到DOM树，而不是改变元素的状态 两者的区别：伪类是操作文档中已有的元素，而伪元素是创建一个文档外的元素。一般伪类是单冒号，如：hover，而伪元素是双冒号::before 18. 层叠上下文 19. css sprite是什么，有什么优缺点 概念： 将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案 优点： 减少HTTP请求数，极大地提高页面加载速度 增加图片信息重复度，提高压缩比，减少图片大小 更换风格方便，只需要在一张或几张图片上修改颜色或者样式即可实现 缺点： 图片合并麻烦 维护麻烦，修改一张图片可能需要从新布局整个图片 20. display:inline-block什么时候不会显示间隙 移除空格 使用margin负值 使用font-size;0 word-spacing 21. 常见的兼容性问题如何机智的回答浏览器兼容性问题 https://juejin.cn/post/6844903633708908557 移动端兼容性问题 https://juejin.cn/post/6901940698518732808#heading-22 HTTP1. HTTP有哪些方法，具体作用是什么？ GET方法 发送一个请求来取得服务器上的某一个资源 POST方法 向URL指定的资源提交数据或附加新的数据 PUT方法 跟POST方法很像，也是想服务器提交数据。但是他们之间有不同。PUT指定了资源在服务器上的位置，而POST没有 HEAD方法 只请求页面的首部 DELETE方法 删除服务器上的某资源 CONNECT方法 把请求连接转换到透明的TCP/IP通道 2. GET和POST有什么区别 数据传输方式不同：GET请求通过URL传输数据，而POST的数据通过请求体传输 安全性不同：POST的数据因为在请求体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息 数据类型不同：GET只接收ASCII字符限制，而POST无限制 GET请求参数会被完整的保留在浏览器历史记录中，而POST中的参数不会被保留 GET请求在URL中传送的参数是有长度限制的，而POST没有限制 3. HTTP状态码及含义 1xx： 信息状态码 100 continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此消息，表示确认，之后发送具体参数信息 2xx： 成功状态码 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 3xx ： 重定向 301 请求的网页已永久移动到新位置 302 临时性重定向 303 临时性重定向，且总是使用GET请求新的URI 304 自从上次请求后，请求的网页未修改过 4xx： 客户端错误 400 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求 401 请求未授权 403 禁止访问 404 找不到如何与URI相匹配的资源 5xx: 服务器错误 500 最常见的服务器端错误 503 服务器端暂时无法处理请求 4. 请描述一下cookies，sessionStorage和localStorage的区别 cookie是网站为了标示身份而存储在用户本地终端上的数据 cookie数据始终在同源的http请求中携带，寄回在浏览器和服务器间来回传递 sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存 存储大小 cookie数据大小不能超过4k sessionStorage和localstorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有效时间 localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage数据在当前浏览器窗口关闭后自动删除 cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 5. 简述一下src与href的区别 使用场景 src指向外部资源的位置，src指向的内容会嵌套到文档中当前标签所在的位置 img标签 script标签 iframe标签 href 超文本引用 使用场景 用来建立当前元素与文档之间的连接 link标签 a标签 区别 浏览器识别href引用的文档并对该文档进行下载，同时不会停止当前文档的处理 当浏览器解析到src引用时，会暂停浏览器的渲染，直到该资源加载完毕 6.介绍一下对浏览器内核的理解 浏览器名称 内核 补充 IE Trident 主要包含在window操作系统的IE浏览器中 firefox Gecko Gecko的特点是代码完全公开，因此其开发程度很高 Safari webkit 苹果公司自己的内核 chorme webkit/Blink Blink是开源引擎WebKit中的一个分支 Opera Webkit/Blink 现在跟随chrome的步伐，同时参与开发 7. 为什么利用多个域名来存储网站资源会更有效 突破浏览器并发限制 同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞 节约cookie带宽 用户的每次访问，都会带上自己的cookie，但是图片是不需要知道用户的cookie的，所以这部分带宽就白白浪费了 8. 前端安全xss XSS: 跨站脚本攻击是常见和基本的攻击Web 网站的方式。就是攻击者想尽一切办法将可以执行的代码注入网页中 xss可以分为多种类型： 持久型和非持久型 持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害大，当攻击者提交一段XSS代码后，被服务器接收并存储，当所有浏览者访问某个页面都会被XSS，其中最典型的例子就是留言板 非持久型，发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后响应内容出现这段XSS代码，最后浏览器解析执行。 防御 httpOnly：在cookie中设置HttpOnly属性后，JS脚本将无法读取到cookie信息 过滤： 输入检查，一般是用于输入格式的检查，不仅仅是前端检查，后端也要做相同的过滤检查 转义输入输出的内容，对于引号，尖括号，斜杠进行转义 CSRF CSRF：跨站请求伪造，原理是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑 可能造成以下影响 利用已通过认证的用户权限更新设定信息。 利用已通过认证的用户权限购买商品 利用已通过的用户权限在留言板上发表言论 防御 验证码：强制用户必须与应用进行交互才能完成最终请求 尽量使用POST方式提交数据，限制使用GET方式 Token (后端随机产生一个token，把这个token保存到session状态中；同时后端把这个token交给前端页面) 9. TCP和UDP的区别TCP是一个面向连接，可靠，基于字节流的传输层协议 UDP是一个面向无连接的传输层协议 TCP是面向连接的，客户端和服务器端的连接，双方互相通信之前，TCP需要三次握手建立连接，而UDP没有建立连接的过程 tcp是面向字节流，udp是面向报文的。UDP的数据传输是基于数据报的，TCP继承了IP层的特性，TCP为了维护状态，将一个个IP包变成了字节流。 10. 介绍一下三次握手和四次挥手 URG，紧急指有效 ACK，确认序号有效 RST，重置连接 SYN，发起一个新连接 FIN，释放一个连接 PSH，接收方应该尽快将这个报文交给应用层 Seq，顺序号码 TCP三次握手的过程 客户端发送一个TCP的SYN=1，Seq=x的包到服务器端口 服务器发送SYN=1，ACK=x+1，Seq=Y的响应包 客户端发送ACK=Y+1,Seq=Z TCP四次挥手 主动方发送Fin=1,ACK=Z，Seq=X报文 被动方发送ACK=X+1，Seq=Z报文 被动方发送Fin=1,ACK=X,Seq=Y报文 主动方发送ACK=Y,Seq=X报文 11. webSocket的实现和应用 什么是webSocket WebSocket是HTML5中的协议，支持持久连接，http协议不支持持久性连接。Http1.0和HTTP1.1都不支持持久性的链接，HTTP1.1中的keep-alive，将多个http请求合并为1个 webSocket是什么样的协议，具体有什么优点 HTTP的生命周期通过Request来界定，也就是Request一个Response，那么在Http1.0协议中，这次Http请求就结束了。在Http1.1中进行了改进，是的有一个connection：Keep-alive，也就是说，在一个Http连接中，可以发送多个Request，接收多个Response。但是必须记住，在Http中一个Request只能对应有一个Response，而且这个Response是被动的，不能主动发起。 WebSocket是基于Http协议的，或者说借用了Http协议来完成一部分握手，在握手阶段与Http是相同的。我们来看一个websocket握手协议的实现，基本是2个属性，upgrade，connection。 多了下面2个属性 123456Upgrade:webSocketConnection:Upgrade告诉服务器发送的是websocketSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 12. iframe 是什么？有什么缺点定义： iframe元素会创建包含另一个文档的内联框架 缺点： 会阻塞主页面的onload事件 搜索引擎无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能 13. HTML5新特性 语义化标签 表单功能增强 HTML5对表单功能进行了增强，input标签可以输入各种类型从而渲染相应的表单内容。 123456789101112131415 &lt;form action=\"\" method=\"get\"&gt; &lt;p&gt;邮箱标签: &lt;input type=\"email\"&gt;&lt;/p&gt; &lt;p&gt;数字标签: &lt;input type=\"number\"&gt;&lt;/p&gt; &lt;p&gt;滑动条标签: &lt;input type=\"range\"&gt;&lt;/p&gt; &lt;p&gt;搜索框标签: &lt;input type=\"search\"&gt;&lt;/p&gt; &lt;p&gt;日期框: &lt;input type=\"date\"&gt;&lt;/p&gt; &lt;p&gt;星期框: &lt;input type=\"week\"&gt;&lt;/p&gt; &lt;p&gt;月份框: &lt;input type=\"month\"&gt;&lt;/p&gt; &lt;p&gt;颜色框: &lt;input type=\"color\"&gt;&lt;/p&gt; &lt;p&gt;网址框: &lt;input type=\"url\"&gt;&lt;/p&gt; &lt;div&gt; &lt;input type=\"submit\"&gt; &lt;input type=\"reset\"&gt; &lt;/div&gt;&lt;/form&gt; 音频/视频 浏览器原生支持 123&lt;autio src=\"./media/luffy.mp3\" controls=\"controls\"&gt;本网页不支持媒体标签&lt;/autio&gt; 可以设置多类型音视频，兼容性好 1234&lt;audio&gt; &lt;source src=\"./media/luffy.ogg\"&gt;&lt;/source&gt; &lt;source src=\"./media/luffy.map3\"&gt;&lt;/source&gt;&lt;/audio&gt; 画布—canvas 拖放 本地存储 webSocket 14. 浏览器缓存机制 浏览器缓存分为强缓存和协商缓存 强缓存 强缓存可以通过设置HTTP Header实现：Expires和Cache-Control。强缓存表示在缓存期间不需要请求，state code为200 Expires 该字段的值为一个绝对时间的GMT格式的时间字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。 Cache-Control Cache-Control 是 http1.1 时出现的 header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间 Cache-Control与Expires可以在服务器端配置同时启用，同时启用的时候Cache-Control优先级高 协商缓存 如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种HTTP Header实现:Last-Modified和ETag 当浏览器发起请求验证资源时，如果资源没有做变化，那么服务器就会返回304状态码，并且更新浏览器缓存有效期 Last-Modified 和if-Modified-Since Last-Modified 表示本地文件最后修改日期，If-Modified-Since会将Last-Modified的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就将新的资源发送回来，否则返回304状态码 ETag和if-None-Match ETag 类似于⽂件指纹， If-None-Match 会将当前 ETag 发送给服务器，询问该资源ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级⽐ Last-Modified ⾼。 15. 如何进行网站性能优化 content ⽅⾯ 减少 HTTP 请求：合并⽂件、 CSS 精灵、 inline Image 减少 DNS 查询： DNS 缓存、将资源分布到恰当数量的主机名 减少 DOM 元素数量 Server ⽅⾯ 使⽤ CDN 配置 ETag 对组件使⽤ Gzip 压缩 Cookie方面 减小cookie大小 css方面 将样式表放到⻚⾯顶部 不使⽤ CSS 表达式 使⽤ 不使⽤ @import JavaScript方面 将脚本放到⻚⾯底部 将 javascript 和 css 从外部引⼊ 压缩 javascript 和 css 删除不需要的脚本 减少DOM访问 图片方面 优化图⽚：根据实际颜⾊需要选择⾊深、压缩 优化 css 精灵 不要在 HTML 中拉伸图⽚ 16. 从浏览器地址输入url到显示页面的步骤简述 DNS解析 发起TCP请求 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束 详细版 在浏览器地址栏输⼊URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否⾜够新鲜，⾜够新鲜直接提供给客户端，否则与服务器进⾏验证。 检验新鲜通常有两个HTTP头进⾏控制 Expires 和 Cache-Control ： HTTP1.0提供Expires，值为⼀个绝对时间表示缓存新鲜⽇期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最⼤新鲜时间 浏览器解析URL获取协议，主机，端⼝，path 浏览器组装⼀个HTTP（GET）请求报⽂ 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts⽂件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不⼀样） 打开⼀个socket与⽬标IP地址，端⼝建⽴TCP链接，三次握⼿如下： 客户端发送⼀个TCP的SYN=1，Seq=X的包到服务器端⼝ 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z TCP链接建⽴后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使⽤HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报⽂通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重⽤，关闭TCP连接的四次握⼿如下： 主动⽅发送Fin=1， Ack=Z， Seq= X报⽂ 被动⽅发送ACK=X+1， Seq=Z报⽂ 被动⽅发送Fin=1， ACK=X， Seq=Y报⽂ 主动⽅发送ACK=Y， Seq=X报⽂ 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 对响应进⾏解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML⽂档） 解析HTML⽂档，构件DOM树，下载资源，构造CSSOM树，执⾏js脚本，这些操作没有严格的先后顺序，以下分别解释 解析过程中遇到图⽚、样式表、js⽂件，启动下载 显示⻚⾯（HTML解析过程中会逐步显示⻚⾯） JavaScriptjavascript知识点整理 https://juejin.cn/post/6844903778202845192 https://juejin.cn/post/6844904200917221389 Event Loop https://juejin.cn/post/6844903764202094606 Vue最全的 Vue 面试题+详解答案 https://juejin.cn/post/6961222829979697165 webpack带你深度解锁Webpack系列(基础篇) https://juejin.cn/post/6844904079219490830","categories":[],"tags":[]},{"title":"面试题整理","slug":"面试题整理","date":"2021-06-15T08:00:32.462Z","updated":"2021-06-17T10:33:59.518Z","comments":true,"path":"posts/10276/","link":"","permalink":"http://blog.liurugang.cn/posts/10276/","excerpt":"","text":"面试题整理CSS 介绍一下标准的css的盒子模型，与低版本IE的盒子模型有什么不同？介绍一下box-sizing属性 css选择器有哪些？哪些属性可以继承？ CSS优先级如何计算 如何让一个div水平垂直居中 常见的布局有哪些 CSS3有哪些新特性 介绍一下flex布局 关于BFC规范的理解 为什么会出现浮动和什么时候清浮动？清浮动的方式 浏览器是怎样解析CSS选择器的 link和@import的区别 重绘和回流 解决移动端下1px像素问题 CSS动画有哪些？ 如何实现小于12px的字体效果 px/em/rem/vw 区别 伪类和伪元素的区别 层叠上下文 css sprite是什么。有什么优缺点 display:inline-block什么时候不会显示间隙？ 常见的兼容性问题 HTTP HTTP 有哪些方法，具体作用是什么 GET 和POST有什么区别 HTTP状态码及含义 请描述一下cookies，sessionStorage和localStorage的区别 简述一下src与href的区别 介绍一下对浏览器内核的理解 为什么利用多个域名来存储网站资源会更有效 前端安全(xss和CSRF) TCP和UDP的区别 介绍一下三次握手和四次挥手 WebSocket的实现和应用 iframe是什么？有什么缺点？ 谈谈你对TCP三次握手和四次挥手的理解 介绍一下DNS 浏览器下事件循环(Event Loop) Node的Event Loop 6个阶段 HTML5新特性 浏览器缓存机制 如何进行网站性能优化 从浏览器地址输入url到显示页面的步骤 JavaScript 闭包 JavaScript原型，原型链？有什么特点？ 事件代理 继承 跨域问题的几种解决方案 简述ajax的过程 new操作符具体干了什么？ 内置类型 Typeof instanceof this的指向 深浅拷贝 防抖和节流 call ，apply ，bind函数 promise实现 Event Loop 数组 ES6 async/await ==和 === 有什么区别 var let 及const 区别 浏览器渲染 ES5中函数的4种调用 对象的声明方法 Class 事件机制 JavaScript的作用域和作用域链 事件模型 defer和async的区别 模块化发展历程 Vue Vue的生命周期方法有哪些？一般在哪一步发请求 MVC和MVVM区别 Vue组成通讯有哪几种 为什么data是一个函数 v-if和v-show的区别 怎样理解Vue的单向数据流 computed和watch的区别 Vue2.0响应式数据的原理 Vue如何检测数组变化 Vue3.0和2.0的响应式原理区别 Vue3.0用过吗 了解多少 Vue的父子组件生命周期钩子函数执行顺序 虚拟DOM是什么，有什么优缺点 V-model原理 v-for为什么要加key Vue事件绑定原理 谈谈对Vuex的个人理解 你都做过哪些Vue的性能优化 Vue.mixin的使用场景和原理 nextTick使用场景和原理 Keep-alive使用场景和原理 Vue.set方法原理 Vue修饰符有哪些 Vue模板编译原理 能说下vue-router中常用的路由模式实现原理吗 diff算法了解吗 webpack webpack的核心概念 有哪些常见的Loader？你用过哪些Loader？ 有哪些常见的Plugin？你用过哪些Plugin？ 说一下Loader和Plugin的区别 webpack执行流程 webpack的热更新是如何做到的？说明其原理 如何利用webpack来优化前端性能？","categories":[],"tags":[]},{"title":"uni-app入坑","slug":"uni-app入坑","date":"2021-06-12T07:21:36.057Z","updated":"2021-06-12T07:22:23.470Z","comments":true,"path":"posts/61960/","link":"","permalink":"http://blog.liurugang.cn/posts/61960/","excerpt":"","text":"uni-app入坑一、准备工作 下载HBuilderX编辑器，HBuilderX是uni-app官方推荐，其中包含可视化搭建uni-app项目，运行项目，打包编译项目 下载地址点这里 解决HBuilderX编辑器无法对less文件格式化问题 使用less作为css的预编译语言，如果使用的是sass作用css的预编译语言，可以跳过这步。 修改这两个文件的配置，就可以解决这个问题 把红框的内容添加进去即可 二、创建uni-app项目在HBuilderX编辑器中创建项目非常简单，只需要两步 推荐选择内置uni-ui模板。该模板已内置大量常用组件，而且不要删除太多无用文件和代码 创建好后项目的结构目录如图所示 components放置内置组件 pages放置开发页面 static静态资源 App.vue项目页面主入口相当Vue项目的APP.vue main.js相当Vue项目的main.js manifest.json一些打包编译相关的配置 pages.json配置路由，窗口样式，原生导航栏，底部原生tabbar uni-scss配置uni-app内置的常用样式变量 三、启动uni-app项目启动uni-app项目，在HBuilderX编辑器中也非常简单，一步搞定 开始编译 编译成功 在浏览器打开http://loaclhost:8080/，如果页面如下图所示，说明项目启动 四、开发阶段 怎么去除原生导航栏 这个项目原型中没有原生导航栏的，所以要把它先去掉。 方法在文档这个地方这个地方。 当navigationStyle设为custom或titleNview设为false时,原生导航栏不显示。所以去除H5端的原生导航栏有两种方法 都是在pages.json文件中 统一去除原生导航栏 123456789\"pages\":[ &#123; \"path\":\"pages/index/index\", \"style\":&#123; \"navigationStyle\":\"custom\", \"navigationBarTitleText\":\"uni-ui基础项目\" &#125; &#125;] 或者，只针对H5端去除原生导航栏。 12345678910\"pages\":[ &#123; \"path\":\"pages/index/index\", \"style\":&#123; “h5”:&#123; \"titleNView\":false &#125; &#125; &#125;] 下面就是去原生导航栏后的效果 路由配置 目前前端项目大多都是用路由来控制页面跳转，所以入坑一个新框架，先要熟悉一下这个框架的路由怎么配置 uni-app的路由配置方式和小程序很像，如果你会小程序，配置起来更容易了。 uni-app项目的路由还是pages.json中pages属性中配置，其实上面已经应用到了 pages属性的值是个数组，数组每项是个json对象，每个路由就配置在json对象中，其中page属性是页面路径，style是配置页面的样式 在uni-app项目中，我们一般把页面写在pages文件夹下，例如pages文件夹下添加一个叫home.vue的文件，文件内容如下 1234567&lt;template&gt; &lt;veiw&gt;我是home页面&lt;/veiw&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 那么我们要在pages.json中这么配置 1234567891011121314\"pages\": [ &#123; \"path\": \"pages/index/index\", \"style\": &#123; \"navigationStyle\": \"custom\" &#125; &#125;, &#123; \"path\": \"pages/home\", \"style\": &#123; \"navigationStyle\": \"custom\" &#125; &#125;], 刷新页面，你会发现浏览器上没有我是home页面 当然这里不是配置错了。只是在uni-app有个规定pages节点的第一项为应用入口页(即首页)。所以我们要改一下。 1234567891011121314\"pages\": [ &#123; \"path\": \"pages/home\", \"style\": &#123; \"navigationStyle\": \"custom\" &#125; &#125;, &#123; \"path\": \"pages/index/index\", \"style\": &#123; \"navigationStyle\": \"custom\" &#125; &#125;,], 这是你会发现，编译失败了 原因就是在uni-app中配置文件,每一项结束尾巴都不能加,(逗号),把逗号去掉，在编译，成功后刷新页面，就会看到home.vue这个页面里面的内容 现在我们把home.vue这个文件删掉，在编译，会报错，编译不成功 提示我们找不到home.vue这个文件，所以在新增/减少页面，都需要对pages数组进行修改 12345678\"pages\": [ &#123; \"path\": \"pages/index/index\", \"style\": &#123; \"navigationStyle\": \"custom\" &#125; &#125;,], 重新编译，编译成功。 怎么引入阿里图标 阿里图标这东西，几乎在每个项目中都会使用到。 在Vue项目，我们引入阿里图标是在public文件夹下的index.html文件，通过link引入的 但是在uni-app项目中没有index.html文件，那么要在哪里引入呢 在前面提到的App.vue是项目页面主入口，那么我们可以尝试在这里引入 在Vue项目中.vue文件中我们是这么引入样式 123&lt;style lang=\"less\" scoped&gt; @import \"./css/index.less\";&lt;/style&gt; 那么尝试在App.vue这么引入阿里图标 123&lt;style&gt; @import url(\"https://at.alicdn.com/t/font_1811528_5xzkmbymkb7.css\");&lt;/style&gt; 然后在pages/index/index.vue文件中这么使用 12345&lt;template&gt; &lt;view&gt; &lt;text class=\"iconfont iconSIMCard\"&gt;&lt;/text&gt; &lt;/view&gt; &lt;/template&gt; 刷新页面。发现引入成功 关于标签的使用 如果你会小程序开发，这一点可以忽略不看。 我们之前开发微信公众号，是用H5开发的，自然可以使用HTML5标签，如常用的div，span，img。 那么在uni-app项目中只能用它自带的组件标签。如&lt;view&gt;&lt;/view&gt;就相当于&lt;div&gt;&lt;/div&gt;,&lt;text&gt;&lt;/text&gt;相当于&lt;span&gt;&lt;/span&gt;，&lt;image&gt;&lt;/image&gt;相当&lt;img/&gt;，具体可点这里看 关于图片路径问题 说到这个路径，我们首先要搞懂几个常识 ~表示Web应用根目录，/也表示根目录,../表示当前目录的上一级目录,./表示当前目录。 在uni-app项目引入图片，要用内置组件标签&lt;image&gt;&lt;/image&gt;，其src属性就是配置图片路径，仅支持相对路径，绝对路径，支持base64码，但自定义组件里面使用&lt;image&gt;时，若src使用相对路径可能出现路径查找失败的情况，故建议使用绝对路径 在项目中我是把图片资源放在根目录的assets/images文件夹中。如果你的页面在pages文件夹中的路径很深，例如 那你是不是要在页面上这么写 12345&lt;template&gt; &lt;view&gt; &lt;image src=\"../../../../assets/images/indeximg1.png\"&gt;&lt;/image&gt; &lt;/view&gt;&lt;/template&gt; 其实我们可以利用~来改造一下 12345&lt;template&gt; &lt;view&gt; &lt;image src=\"~assets/images/indeximg1.png\"&gt;&lt;/image&gt; &lt;/view&gt;&lt;/template&gt; 在less中使用background也可以利用~ 123.home&#123; background:url(~images/card/home.png) no-repeat;&#125; 这样写可以避免因为少些或者多谢../导致的路径错误，配置起来也轻松 另外我们可以向Vue项目中在根目录下添加一个Vue.config文件，来配置webpack，当然在uni-app项目中配置和在Vue项目中配置是有差异,可以点这里看。 我们在vue.config.js文件配置一个路径别名，配置方法和在Vue项目中一样 123456789101112131415161718const path = require('path');function resolve(dir) &#123; return path.resolve(__dirname, dir)&#125;module.exports = &#123; configureWebpack: config =&gt; &#123; return baseConfig = &#123; resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'assets': resolve('assets'), 'css': resolve('assets/css'), 'images': resolve('assets/images'), &#125; &#125;, &#125; &#125;,&#125; 关于第三方组件的使用 在uni-app中使用第三方组件都会下载到components文件夹中。所以引入第三方组件的做法和Vue项目开发一样。 如果使用Popup弹出层，这么引入 1234components: &#123; uniPopup: () =&gt; import('@/components/uni-popup/uni-popup.vue'), uniPopupDialog: () =&gt; import('@/components/uni-popup/uni-popup-dialog.vue'),&#125;, 关于页面的跳转 页面传参 在uni.navigatateTo()中url参数为路径，其后可以带参数，用于页面传参，参数在新页面中onLoad钩子函数接收，如下实例。 123uni.navigateTo(&#123; url: 'test?id=1&amp;name=uniapp'&#125;) 1234567//在test.vue页面接收参数export default &#123; onLoad: function(option)&#123; //option 为object类型，会序列化上个页面传递的参数 console.log(option.id); //打印出上个页面传递的参数 console.log(option.name): //打印出上个页面传递的参数 &#125;&#125; 页面栈 框架以栈的形式管理当前所有页面，记住栈是先进后出的 当用户按左上角返回按钮，安卓用户点击物理back按键时，触发uni.navigateBack，关闭当前页面，也就是将当前页面出栈，返回上一个页面，也就是返回页面栈中最上层的页面。当然uni.navigateBack中Object.delta可以控制返回页面栈中第几层的页面。可以用getCurrentPages()可以得到所有页面栈的对象、 uni.navigateTo()，保留当前页面，将当前页面入栈，再跳转新的页面 uni.redirectTo(),关闭当前页面，不将当前页面入栈，再跳转新的页面 uni.navigateTo()，uni.redirectTo()只能打开非tabBar页面 关于消息弹窗的使用 跟服务端交互时肯定要用消息弹窗，比如报错时给出错误提示。uni-app框架封装几种消息弹窗的足迹。 uni.showToast()显示消息提示弹窗。uni.hideToast()隐藏消息提示框。uni.showModal()显示模态弹窗，类似于标准html的消息框：alert，confirm 关于加载动画的使用 uni.showLoading()显示loading提示框，需主动调用uni.hideLoading()才能关闭提示框。 uni.hideLoading()隐藏loading提示框 showToast和showLoading是底层同一个，所以showToast 和showLoading会相互覆盖，而uni.hideLoading()也会关闭showToast,所以注意调用顺序 关于使用nginx反向代理出现Invalid Host header问题 点开manifest.json文件，在h5中devServer选项中设置&quot;disableHostCheck&quot;:true 关于使用formData格式请求接口 uni-app中是用uni.request()和服务端通信的。其中data参数是传给服务端的数据 最终发送给服务器的数据是String类型，如果传入的data不是String类型，会被转换成String。转换规则如下： 对于GET方法，会将数据转换为query string。例如{name:&#39;name&#39;,age:18}转换为结果为name=name&amp;age=18。 对于POST方法且header[&#39;content-type&#39;]为application/json的数据，会进行JSON序列化 对于POST方法且header[‘content-type’]为application/x-www-form-unlencoded的数据，会将数据转换为query string` 会发现uni.request()不能发送formData类型的数据传给后端。如果要发送formData类型的数据，要用uni.uploadFile()，其作用是将本地资源上传到开发者服务器，客户端发起一个POST请求,其中content-type为multipart/form-data。 formData参数是用uni.uploadFile()上传本地资源中其他额外的form data数据 uni.uploadFile()中几个必填的参数，如url,filePath,name可以随便填写。所有可用uni.uploadFile()发起数据格式为formData的接口请求了。 关于元素尺寸的获取 因为uni-app跨平台时不支持引入jQuery等操作DOM的插件，H5平台可以通过条件编译的方式引入使用。所以在uni-app中最好不要引入jQuery。可以使用uni.createSelectorQuery()创建一个SelectorQuery对象实例来获取DOM信息。 例如要获取&lt;view class=&quot;p-lista&quot;&gt;&lt;/view&gt;的高度。 1234const _this = this;uni.createSelectorQuery().select(\".p-list\").boundingCilentRect(data=&gt;&#123; _this.height= data.height;&#125;).exec() 关于区域上拉刷新功能实现 用uni-app中scroll-view内置组件和第三方uni-load-more组件实现。 注意scroll-view中要设定固定高度才可以生效。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;view class&#x3D;&quot;p-list&quot;&gt; &lt;scroll-view scroll-y&#x3D;&quot;true&quot; @scrolltolower&#x3D;&quot;lower&quot; :style&#x3D;&quot;&#123;height:height+&#39;px&#39;&#125;&quot;&gt; &lt;view v-for&#x3D;&quot;item in list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;view&gt; &lt;uni-load-more :status&#x3D;&quot;status&quot; iconType&#x3D;&quot;auto&quot; v-show&#x3D;&quot;isShow&quot;&gt;&lt;&#x2F;uni-load-more&gt; &lt;&#x2F;scroll-view&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; current:1,&#x2F;&#x2F;页码 list:[], height: 0,&#x2F;&#x2F;列表区域高度 isShow:false, status: &#39;loading&#39;,&#x2F;&#x2F;加载更多的状态 &#125; &#125;, components: &#123; uniLoadMore: () &#x3D;&gt; import(&#39;@&#x2F;components&#x2F;uni-load-more&#x2F;uni-load-more.vue&#39;), &#125;, mounted() &#123; this.getViewHeight(); &#125;, methods: &#123; getViewHeight() &#123; const _this &#x3D; this; uni.createSelectorQuery().select(&quot;.p-list&quot;).boundingClientRect(data &#x3D;&gt; &#123; _this.height &#x3D; data.height; &#125;).exec(); &#125;, lower() &#123; if (this.isShow) return; this.isShow &#x3D; true; this.current++; this.getList(); &#125;, getList()&#123; let data &#x3D; new Object; data.current &#x3D; this.current; data.size &#x3D; 15;&#x2F;&#x2F;每次加载条数 API.getRenewRecord(data) .then(res &#x3D;&gt; &#123; this.isShow &#x3D; false; if (res.code &#x3D;&#x3D; 200) &#123; this.list &#x3D; [...this.list, ...res.data] if (res.data.length &#x3D;&#x3D; 0) &#123; this.status &#x3D; &#39;noMore&#39;; this.isShow &#x3D; true; &#125; &#125; &#125;) .catch(err &#x3D;&gt; &#123; this.isShow &#x3D; false; &#125;) &#125; &#125;&#125;&lt;&#x2F;script&gt; 关于区域下拉刷新功能实现 如果页面头部有固定内容，下拉刷新只能用scroll-view内置组件实现。注意scroll-view中要设定固定高度才可以生效 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;view class&#x3D;&quot;p-list&quot;&gt; &lt;scroll-view scroll-y refresher-enabled :refresher-triggered&#x3D;&quot;triggered&quot; :refresher-threshold&#x3D;&quot;100&quot; @refresherrefresh&#x3D;&quot;onRefresh&quot; :style&#x3D;&quot;&#123;height:height+&#39;px&#39;&#125;&quot;&gt; &lt;view v-for&#x3D;&quot;item in list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;view&gt; &lt;&#x2F;scroll-view&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; current:1,&#x2F;&#x2F;页码 list:[], height: 0,&#x2F;&#x2F;列表区域高度 triggered:false,&#x2F;&#x2F;下拉刷新状态，true开启下拉刷新，false结束下拉刷新 &#125; &#125;, mounted() &#123; this.getViewHeight(); &#125;, methods: &#123; getViewHeight() &#123; const _this &#x3D; this; uni.createSelectorQuery().select(&quot;.p-list&quot;).boundingClientRect(data &#x3D;&gt; &#123; _this.height &#x3D; data.height; &#125;).exec(); &#125;, onRefresh() &#123; if (this.triggered) return; this.triggered &#x3D; true; this.current++; this.getList(); &#125;, getList()&#123; let data &#x3D; new Object; data.current &#x3D; this.current; data.size &#x3D; 15;&#x2F;&#x2F;每次加载条数 API.getRenewRecord(data) .then(res &#x3D;&gt; &#123; this.triggered &#x3D; false; if (res.code &#x3D;&#x3D; 200) &#123; this.list &#x3D; [...res.data,...this.list] &#125; &#125;) .catch(err &#x3D;&gt; &#123; this.triggered &#x3D; false; &#125;) &#125; &#125;&#125;&lt;&#x2F;script&gt; 因为在微信浏览器中，下拉时整个页面会下滑，然后导致scroll-view的下拉刷新卡顿。用以下方法解决 先在pages.json中开启该页面的下拉刷新监听 12345678910&#123; \"pages\":[ \"path\":\"testList\", \"style\":&#123; \"enablePullDownRefresh\": true &#125; ]&#125; 然后在页面中监听下拉刷新，一旦下拉刷新马上执行uni.stopPullDownReFresh把下拉刷新马上关闭 123onPullDownRefresh() &#123; uni.stopPullDownRefresh()&#125;, 同时在App.vue中，把下拉刷新的页面效果隐藏 12345&lt;style&gt; uni-page[data-page=webbsms] uni-page-refresh&#123; display:none; &#125;&lt;/style&gt; IOS 收起软键盘后页面不下滑的解决 1234567891011121314151617&lt;template&gt; &lt;view&gt; &lt;input v-model.true&#x3D;&quot;value&quot; @blur&#x3D;&quot;handleblur&quot;&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;&lt;script&gt; methods:&#123; handleblur()&#123; uni.pageScrollTo(&#123; uni.pageScrollTo(&#123; scrollTop:0, duration:0 &#125;) &#125;) &#125; &#125;&lt;&#x2F;script&gt; IOS不能撑开display:flex镶嵌使用的父级高度 在父级元素加上min-height属性。或者避免嵌套 关于自定义打包后的index.html页面 uni-app项目中默认是没有index.html，不像Vue项目默认带有index.html。那么要用CND引入第三方库，该怎么操作。 首先在根目录下，新建index.html文件 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;title&gt; &lt;%= htmlWebpackPlugin.options.title %&gt; &lt;/title&gt; &lt;script&gt; document.addEventListener('DOMContentLoaded', function() &#123; document.documentElement.style.fontSize = document.documentElement.clientWidth / 20 + 'px' &#125;) &lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"&lt;%= BASE_URL %&gt;static/index.&lt;%= VUE_APP_INDEX_CSS_HASH %&gt;.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong&gt;Please enable JavaScript to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 然后在manifest.json中添加如下配置，即可 123\"h5\":&#123; \"template\":\"index.html\"&#125; 关于首屏优化的操作 开启预加载和摇树优化，然后在manifest.json中添加如下配置，即可 123456789\"h5\":&#123; \"optimization\": &#123; \"prefetch\": true, \"preload\": true, \"treeShaking\": &#123; \"enable\": true &#125; &#125;&#125; 五、部署阶段 H5发布 先配置 然后打包编译 最后打包生成的文件部署到服务器上","categories":[],"tags":[]},{"title":"高频考点","slug":"高频考点","date":"2021-06-02T15:30:53.636Z","updated":"2021-06-08T07:11:48.471Z","comments":true,"path":"posts/63672/","link":"","permalink":"http://blog.liurugang.cn/posts/63672/","excerpt":"","text":"高频考点1. typeof类型判断 typeof 是否能正确判断类型？ instanceof能正确判断对象的原理是什么 type 对于原始类型，除了 null都可以只显示正确的类型 12345typeof 1 //'number'typeof '1' //'string'typeof undefined //'undefined'typeof true //'boolean'typeof Symbol() //'symbol' typeof 对于对象来说，除了函数都会显示object,所以说typeof并不能准确判断变量到底是什么类型 123typeof [] //'object'typeof &#123;&#125; //'object'typeof console.log //'function' 如果我们想判断一个对象的正确类型，这时候可以考虑使用instanceof,因为内部机制是通过原型链来判断的 123456789const Person = function()&#123;&#125;const p1 = new Person()p1 instanceof Person // truevar str = 'hello world'str instanceof String //falsevar str1= new String('hello world')str1 instanceof String //true 对于原始类型来说，逆向直接通过instanceof 来判断类型是不行的 2.类型转换 在JS中类型转换只有三种情况，分别是 转换为布尔值 转换为数字 转换为字符串 转为Boolean 在条件判断时，除了 undefined , null ,false ,NaN,’ ‘,0,-0,其他所有值都转为true，包括所有对象 对象转为原始类型 对象在转换类型的时候，会调用内置的[[ToPrimitive]]函数，对于该函数来说，算法逻辑一般来说如下 如果已经是原型类型了，那就不需要转换了 调用x.valueOf()如果转换为基础类型，就返回转换的值 调用x.toString()，如果转换为基础类型，就返回转换的值 如果没有返回原型类型，就会报错 当然你也可以重写Symbol.toPrimitive，刚方法在转原始类型时调用优先级最高 123456789101112let a = &#123; valueOf()&#123; return 0 &#125;, toString()&#123; return '1' &#125;, [Symbol.toPrimitive]()&#123; return 2 &#125;&#125;1+ a //3 四则运算 它有以下几个特点： 运算中其中一方为字符串，那么久会把另一方也转换为字符串 如果一方不是字符串或数字，那么会将它转换为数字或者字符串 1231+ '1' //'11'true + true //24+ [1,2,3] //\"41,2,3\" 对于第一行代码来说，触发特点一，所以将数字1转换为字符串，得到结果’11‘ 对于第二行代码来说，触发特点二，所以将true转为数字1 对于第三行代码来说，触发特点二，所以将数组通过toString转为字符串1,2,3，得到结果41，2,3 比较运算符 如果是对象，就通过toPrimitive转换为对象 如果是字符串，就通过unicode字符索引来比较 123456789let a =&#123; valueOf()&#123; return 0 &#125;, toString()&#123; return '1' &#125;&#125;a&gt;-1 //true 在以上代码中，因为a是对象，所以会通过valueOf转换为原始类型再比较值 3. This123456789101112function foo()&#123; console.log(this.a)&#125;var a =1foo()const obj = &#123; a:2, foo:foo&#125;obj.foo()const c = new Foo() 对于直接调用foo 来说，不管foo函数放在什么地方，this一定是window 对于obj.foo()来说，我们只需要记住，谁调用了函数，谁就是this,所以在这个场景下foo函数中的this就是obj对象 对于new的方式来说，this被永远绑定在了c上面 不会被任何方式改变this 说完了以上几种情况，其实很多代码中的this应该就没什么问题了，下面让我们看看箭头函数中的this 12345678function a()&#123; return ()=&gt;&#123; return ()=&gt;&#123; console.log(this)//window &#125; &#125;&#125;console.log(a()()())//undefined 首先箭头函数其实是没有this的，箭头函数中的this只取决包裹箭头函数的第一个普通函数的this。在这个例子中，因为包裹箭头函数的第一个普通函数是a,所以此时的this是window。另外对箭头函数使用bind这类函数是无效的 最后种情况也就是bind这些改变上下文的API了，对于这些函数来说，this取决于第一个参数，如果第一个参数为空，那么就是window 无论我们给函数bind几次，fn中的this永远由第一次bind决定，所以结果永远是window 123let a = &#123;&#125;let fn = function()&#123;console.log(this)&#125;fn.bind.bind(a)() //window 以上就是this的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高来决定this最终指向哪里 首先，new的方式优先级最高，接下来是bind这些函数，然后是obj.foo()这种调用方式，最后是foo这种调用方式，同时，箭头函数的this一旦被绑定，就不会再被任何方式所改变 4. == 和===有什么区别 对于==来说，如果对比双方的类型不一样的话，就会进行类型转换 假如我们需要对比x和y是否相同，就会进行如下判断流程 首先会判断两者类型是否相同，相同的话就是比大小了 类型不相同的话，那么就会进行类型转换 会先判断是否在对比null和undefined,是的话就会返回true 判断两者类型是否为string和number，是的话就会将字符串转换为number 判断其中一方是否为boolean.是的话就把boolean转为number再进行判断 判断其中一方是否为Object且另一方为string,number或者symbol，是的话就会把object转为原始类型再进行判断 对于===来说就简单多了，就是判断两者类型和值是否相同 5. 闭包 闭包的定义其实很简单：函数A内部有一个函数B，函数B可以访问到函数A中的变量，那么函数B就是闭包 12345678function A()&#123; let a =1 window.B = function()&#123; console.log(a) &#125;&#125;A()B() //1 闭包存在的意义就是让我们可以间接访问函数内部的变量 经典面试题，循环中说那个闭包解决var定义函数的问题 12345for(var i=1;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i) &#125;,i*1000)&#125; 首先因为setTimeout是个异步函数，所以会先把循环占全部执行完毕，这时候i就是6了，所以会输出一堆6 解决办法有三种 第一种是使用闭包的方式 1234567for(var i=1;i&lt;=5;i++)&#123; ;(function(j)&#123; setTimeout(function timer()&#123; console.log(j) &#125;,j*1000) &#125;)(i)&#125; 在上述代码汇总，我们首先使用了立即执行函数将i传入函数内部，这时候值就被固定在了参数j上面不会改变，当下次执行timer这个闭包的时候，就可以使用外部函数的变量j,从而达到目的 第二种就是使用setTimeout的第三个参数，这个参数会被当做timer函数的参数传入 12345for(var i=1;i&lt;=5;i++)&#123; setTimeout(function timer(j)&#123; console.log(j) &#125;,i*1000,i)&#125; 第三种就是使用let定义i了来解决问题，这个也是最为推荐的方式 12345for(let i=1;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i) &#125;,i*1000)&#125; 6. 深浅拷贝浅拷贝 首先可以通过Object.assign来解决这个问题，很多人认为这个函数是用来深拷贝的，其实并不是，Object.assign只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝 123456let a =&#123; age:1&#125;let b = Object.assign(&#123;&#125;,a)a.age = 2;console.log(b.age) //1 另外我们还可以通过展开运算符...来实现浅拷贝 123456let a =&#123; age:1&#125;let b =&#123;...a&#125;a.age =2console.log(b.age) //1 通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用深拷贝 123456789let a =&#123; age:1, jobs:&#123; first: 'FE' &#125;&#125;let b =&#123;...a&#125;a.jobs.first ='native'console.log(b.jobs.first) //native 深拷贝 这个问题通常可以使用JSON.parse(JSON.stringify(object))来解决 123456789let a = &#123; age:1, jobs:&#123; first:'FE' &#125;&#125;let b = JSON.parse(JSON.stringify(a))a.jobs.first ='native'console.log(b.jobs.first) //FE 但是这个犯法也是有局限性的 会忽略undefined 会忽略symbol 不能序列化函数 不能解决循环引用的对象 7. 原型 原型链就是多个对象通过__proto__的方式连接了起来。为什么obj可以访问到valueof函数，就是因为obj通过原型链找到了valueof函数 Object是所有对象的爸爸，所有对象都可以通过__proto__找到它 Function是所有函数的爸爸，所有函数都可以通过__proto__找到它 函数的prototype是一个对象 对象的__proto__属性指向原型，__proto__将对象和原型连接起来组成了原型链 8. var let 及const区别 函数提升优先变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部 var存在提升，我们能在声明之前使用。let，const因为暂时性死区的原因，不能在声明前使用 var在全局作用域下声明变量会导致变量挂载在window上，其他两者不会 let和const作用基本一致，但是后者声明的变量不能再次赋值 9. 原型继承和class继承首先先来讲下class，其实在JS中并不存在类，class只是语法糖，本质还是函数 12class Person&#123;&#125;Person instanceof Function //true 组合继承 组合继承是最常用的继承方式 1234567891011121314function Parent(value)&#123; this.val =value&#125;Person.prototype.getValue = function()&#123; console.log(this.val)&#125;function Child(value)&#123; Parent.call(this.value)&#125;Child.prototype =new Parent()const child = new Child(1)child.getValue()//1child instanceof Parent //true 以上继承的方式核心是在子类的构造函数中通过Parent.call(this)继承父类的属性，然后改变子类的原型为new Parent()来继承父类的函数 这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费 寄生组合继承 这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行 1234567891011121314151617181920function Parent(value)&#123; this.val = value &#125; Parent.prototype.getValue = function()&#123; console.log(this.val)&#125;function Child(value)&#123; Parent.call(this,value)&#125;Child.prototype = Object.create(Parent.prototype,&#123; constructor:&#123; value:Child, enumerable:false, writable:true, configurable:true &#125;&#125;)const child = new Child(1)child.getValue() //1child.instanceof Parent //true 以上继承实现的核心就是将父类的原型赋值给了子类，并将构造函数设置为子类，这样即解决了无用的父类属性问题，还能正确的找到子类的构造函数。 class继承 以上两种继承方式都是通过原型去解决的，在ES6中，我们可以使用class去实现继承，并且实现起来很简单 1234567891011121314151617class Parent&#123; constructor(value)&#123; this.val = value &#125; getValue()&#123; console.log(this.val) &#125;&#125;class Child extends Parent&#123; constrcutor(value)&#123; super(value) this.val = value &#125;&#125;let child = new Child(1)child.getValue()//1child instanceof Parent //true class 实现继承的核心在于使用extends表明继承自那个父类，并且在子类构造函数中必须嗲偶偶那个super，因为这段代码可以看成Parent.call(this,value) 10. 实现一个简洁版的promise1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//三个常量用于表示状态const PENDING ='pending'const RESOLVED = 'resolved'const REJECTED = 'rejected'function MyPromise(fn)&#123; const that =this; this.state = PENDING //value 变量用于保存resolve或者reject中传入的值 this.value = null //用于保存then中的回调，因为当执行完Promise时状态可能还是等待中，这时候应该把状态存储下来 that.resolvedCallbacks =[] that.rejectedCallbacks =[] function resolve(value)&#123; //首先两个函数都得判断当前状态是否为等待中 if(that.state ===PENDING)&#123; that.state =RESOLVED that.value = value //遍历回调数组并执行 that.resolvedCallbacks.map(cb=&gt;cb(that.value)) &#125; &#125; function reject(value)&#123; if(that.state ===PENDING)&#123; that.state = REJECTED that.value = value that.rejectedCallbacks.map(cb =&gt;cb(that.value)) &#125; &#125; //完成以上两个函数以后，我们就该实现如何执行Promise中传入的函数了 try()&#123; fn(resolve,reject) &#125;catch(e)&#123; reject(e) &#125;&#125;//最后我们来实现较为复杂的then函数MyPromise.prototype.then = function(onFullfilled,onRejected)&#123; const that =this //判断两个参数是否为函数类型，因为这两个参数是可选参数 onFullfilled = typeof onFullfilled === 'function' ? onFullfilled: v=&gt;v onRejected = typeof onRejected === 'function' ? onRejected: throw e //当状态不是等待时，就去执行响应的函数。如果状态是等待态的话，就往回调函数中push if(this.state === PENDING)&#123; this.resolvedCallbacks.push(onFullfilled) this.rejectedCallbacks.push(onRejected) &#125; if(this.state === RESOLVED)&#123; onFullfilled(that.value) &#125; if(this.state === REJECTED)&#123; onRejected(that.value) &#125;&#125; 11. Event Loop进程与线程 JS是单线程执行的 进程描述了CPU在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小的单位，描述了执行一段指令所需要的时间 把这些概念拿到浏览器中国来说，当你打开一个Tab页时，其实就是创建了一个进程，一个进程中可以有很多个线程，比如渲染线程，JS引擎线程，HTTP请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁 上文说到了JS引擎线程和渲染线程，大家应该都知道，在JS运行的时候可能会阻止UI渲染，这说明了两个线程是互斥的，这其中的原因是因为JS可以修改DOM，如果在JS执行的时候UI线程还在工作，就可能导致不能安全的渲染UI。这其实也是单线程的好处，得益于JS是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处 执行栈 可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则 当开始执行JS代码时，首先会执行一个main函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，foo函数后执行，当执行完毕后就从栈中弹出了 1234567function foo()&#123; throw new Error('error')&#125;function bar()&#123; foo()&#125;bar() 浏览器中的Event loop JS是门非阻塞单线程语言，因为在最初JS就是为了和浏览器交互诞生的。如果JS是门多线程语言话，我们在多个线程中处理DOM就可能发生问题 JS在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，就被挂起并加入到Task队列中。一旦执行栈为空，Event Loop就会从Task队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说JS中的异步还是同步行为 1234567console.log('script start')setTimeout(function()&#123; console.log('setTimeout')&#125;,0)console.log('script end') //先后顺序为 script start script end setTimeout 不同的任务源会被分配到不同的Task队列中，任务源可以分为微任务和宏任务。 微任务 process.nextTick promise Object.observe 宏任务 script setTimeout setInterval setImmediate I/O UI rendering setTimeout 所以正确的一次Event Loop 顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有的微任务 必要的话渲染UI 然后开始下一轮 Event loop ，执行宏任务中的异步代码 1234567891011121314console.log('script start')setTimeout(function()&#123; console.log('setTimeout')&#125;，0)new Promise((resolve)=&gt;&#123; console.log('Promise') resolve()&#125;).then(function()&#123; console.log('promise1')&#125;).then(function()&#123; console.log('promise2')&#125;)console.log('script end') 12. 手写 call apply 及bind函数 不传入第一个参数，那么上下文默认为window 改变了this指向，让新的对象可以执行该函数，并能接收参数 实现call 首先context为可选参数，如果不传的话，默认上下文为window 接下来给context创建一个fn属性，并将值设置为需要调用的函数 因为call可以传入多个参数作为调用的参数，所有需要将参数剥离出来 然后调用函数并将对象上的函数删除 1234567891011Function.prototype.myCall = function(context)&#123; if(typeof this !== 'function')&#123; thorw new TypeError('Error') &#125; context = context || window context.fn = this const args = [...arguments].slice(1) const result = context.fn(...args) delete context.fn return result&#125; apply的实现 12345678910111213141516Function.prototype.myApply = function(context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Error') &#125; context = context || window context.fn = this let result // 处理参数和 call 有区别 if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; delete context.fn return result &#125; bind的实现 bind 返回了⼀个函数，对于函数来说有两种⽅式调⽤，⼀种是直接调⽤，⼀种是通过new 的⽅式，我们先来说直接调⽤的⽅式 对于直接调⽤来说，这⾥选择了 apply 的⽅式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2) ，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(…arguments) 最后来说通过 new 的⽅式，在之前的章节中我们学习过如何判断 this ，对于 new 的情况来说，不会被任何⽅式改变 this ，所以对于这种情况我们需要忽略传⼊的 this 123456789101112131415Function.prototype.myBind = function(context)&#123; if(typeof this !== 'function')&#123; throw new TypeError('Error') &#125; const _this =this; const args = [...arguments].slice(1) //返回一个函数 return function F()&#123; //因为返回了一个函数，我们可以new F()，所以需要判断 if(this instanceof F)&#123; return new _this(..args, ...arguments) &#125; return _this.apply(context,args.concat(...arguments)) &#125;&#125; 13. new在调用new的过程中发生四件事情 新生成了一个对象 连接到原型 绑定 this 返回新对象 14. instanceof 的原理instanceof可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的prototype 实现以下instanceof 首先获取类型的原型 然后获得对象的原型 然后一直循环判断对象的原型是否等于类型的原型，知道对象原型为null，因为原型链最终为null 12345678910111213function myInstanceof(left,right)&#123; let prototype = right.prototype left = left.__proto__ while(true)&#123; if(left === null || left === undefined)&#123; return false &#125; if(prototype === left)&#123; return true left = left.__proto__ &#125; &#125;&#125; 15. 事件机制事件触发有三个阶段 window往事件触发处传播，遇到注册的捕获事件会触发 传播到事件触发处触发注册的事件 从事件触发处往window传播，遇到注册的冒泡事件会触发 16. 注册事件 通常我们使用addEventListener注册事件，该函数的三个参数可以是布尔值，也可以是对象。对于布尔值useCapture参数来说，该参数默认值为false，userCapture决定了注册的事件是捕获事件还是冒泡事件。 该参数默认值为false capture： 布尔值，和useCapture作用一样 once: 布尔值，值为true表示该回调只会回调一次，调用后会移除监听 passive： 布尔值，表示永远不会调用preventDefault 一般来说，如果我们只希望事件只触发在目标上，这时候可以使用 stopPropagation来阻止事件的进一步传播，筒仓我们任务stopPropagation是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。 事件代理 如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上 12345678910111213&lt;ul id=\"ul\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; let ul = document.querySelected('#ul') ul.addEventListener('click',(event)=&gt;&#123; console.log(event.target) &#125;)&lt;/script&gt; 事件代理的方式相较于直接给目标注册事件来说，有以下优点 节省内存 不需要给子节点注销事件 17. 跨域 因为浏览器处于安全考虑，有同源策略。如果协议，域名或者端口有一个不同就是跨域，Ajax请求会失败 主要是用来防止CSRF攻击的。简单点说，CSRF攻击是利用用户的登录态发起恶意请求 A网站可以被任意其他来源的Ajax访问到内容。如果你当前A网站还存在登录态，那么对方就可以通过Ajax获取你的任何信息。当然跨域并不能完全阻止CSRF。 JSONP原理 利用&lt;script&gt;标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的JSON数据。JSONP请求一定需要对方的服务器做支持才行 JSON和AJAX对比 JSONP和AJAX相同，都是客户端向服务端发送请求，从服务端获取数据的方式。但是AJAX属于同源策略，JSONP属于非同源策略 JSONP优缺点 JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性，不安全可能会遭到xss攻击 JSONP的实现流程 声明一个回调函数，其函数名当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data) 创建一个&lt;script&gt;标签，把那个跨域的API数据接口地址，赋值给script的src，还要再这个地址中向服务器传递函数名(可以通过问号传参:?callback=show) 服务器接收到请求后，需要进行特殊的处理；把传递进来的函数名和它需要给你的数据拼接成一个字符串； 最后服务器把准备的数据通过http协议返回给客户端，客户端再调用执行之前声明的回调函数，对返回的数据进行操作 cors CORS需要浏览器和后端同时支持。IE8和9通过XDomainRequest来实现 浏览器会自动进行CORS通信，实现CORS通信的关键是后端，只要有段实现了CORS，就实现了跨域。 服务端设置Access-Control-Allow-Origin就可以开始CORS。该属性表示哪些域名可以访问资源，如果设置通配符则表示网站都可以访问资源。 虽然设置CORS和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求 简单请求 只要同时满足以下两大条件，就属于简单请求 条件1：使用下列方法之一 GET HEAD POST 条件2：Content-Type的值仅限于以下三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 请求中任意XMLHttpRequestUpload对象君没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用XMLHttpRequest.upload属性访问 postMessage postMessage是HTML5 XMLHttpRequest 的API，且是位数不多可以跨域操作的window属性之一，它可以用于解决以下方面的问题： 页面和其打开新窗口的数据传递 多窗口之间信息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 postMessage()方法允许来自不不同源的脚本采用异步方式进行有限的通信，可以实现跨文档，多窗口，跨域消息传递 1otherWindow.postMessage(message,targetOrigin, [transfer]) message: 将要发送到其他window的数据 targetOrigin 通过窗口的origin 属性来指定哪些窗口能接收消息事件，其值可以是字符串或者一个URI。在发送消息的时候，如果目标窗口的协议，主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。 123456789101112//a.html&lt;iframe src=\"http://localhost:4000/b.html\" frameborder=\"0\" id=\"frame\" onload=\"load()\"&gt;&lt;/iframe&gt;//内嵌在http://localhost:3000/a.html&lt;script&gt; function load()&#123; let frame = document.getElementById('frame') frame.contentWindow.postMessage('我爱你','http://localhost:4000')//发送数据 window.onMessage = function(e)&#123; //接收返回数据 console.log(e.data) //我不爱你 &#125; &#125;&lt;/script&gt; 12345//b.htmlwindow.onmessage =function(e)&#123; console.log(e.data) //我爱你 e.source.postMessage('我不爱你',e,origin)&#125; websocket websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的券双工通信，同时也是跨域的一种解决方案。webSocket是HTTP都是应用层协议，都基于TCP协议。但是WebSocket是一种双向通信协议，在建立连接之后，WebSocket的server与client都能主动向对方发送或接收数据。 12345678910//socket.html&lt;script&gt; let socket = new WebSocket('ws://localhost:3000'); socket.onopen = function()&#123; socket.send('我爱你'); //向服务器发送数据 &#125; socket.onmessage = function(e)&#123; console.log(e.data); //接收服务器返回的数据 &#125;&lt;/script&gt; 1234567891011// server.jslet express =require('express');let app = express();let webSocket = require('ws')let wss = new WebSocket.Server(&#123;port:3000&#125;)wss.on('connection',function(ws)&#123; ws.on('message',function(data)&#123; console.log(data) ws.send('我不爱你') &#125;)&#125;) document.domain GIA方式只能用于主域名相同的情况下，比如a.test.com和b.test.com适用于该方式 只需要给页面添加document.domain=&#39;test.com&#39;表示主域名都相同就可以实现跨域 18. 存储 cookie`是网站为了标示用户身份而储存用户本地终端上的数据 cookie数据始终在同源的http请求中携带,即会在浏览器和服务器间来回传递 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 存储大小 cookie数据大小不能超过4k sessionStorge和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有限时间 localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage数据在当前浏览器窗口关闭后自动删除 cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 19. 浏览器缓存机制 缓存可以说是性能优化中简单高效的一种优化方式，它可以显著减少网络传输所带来的损耗 对于一个数据请求来说，可以分为发起网络请求，后端处理，浏览器响应三个步骤。 缓存策略 通常浏览器缓存策略分为两种；强缓存和协商缓存，并且缓存策略都是通过设置HTTP Header来实现的 强缓存 强缓存可以通过设置HTTP Header实现:Expires和Cache-Control。强缓存在缓存期间不需要请求，state code 为200 Expires Expires 是HTTP/1的产物，表示资源会在wed,22 Oct 2018 08:41:00 GMT后过期，需要再次请求。并且Expires受限于本地时间，如果修改了本地时间，可能会造成缓存失效 1Expires: Wed, 22 Oct 2018 08:41:00 GMT Cache-control Cache-control出现在HTTP/1.1优先级高于Expires。该属性值表示资源会在30秒后过期，需要再次请求 Cache-Control可以在请求头或者响应头中设置，并且可以组合使用多种指令 1Cache-control: max-age&#x3D;30 从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等 协商缓存 如果缓存过期了，就需要发起验证资源是否有更新。协商缓存可以通过设置两种HTTP Header实现Last-Modified和ETag 当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回304状态码，并且更新浏览器缓存有效期。 Last-modified和if-Modified-since Last-Modified 表示本地文件最后修改日期, if-Modified-Since会将Last-Modified的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回304状态码 但是Last-Modified存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，带还是会造成Last-Modified被修改，服务端不能命中缓存导致发送相同的资源。 因为Last-Modified只是以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源因为以上这些弊端，所以在HTTP/1.1出现了ETag ETag 和if-None-Match ETag类似于文件指纹,If-None-Match会将当前ETag 发送给服务器，询问该资源ETag是否变动，有变动的话就将新的资源发送回来。并且ETag优先级比Last-Modified高 对于频繁变动的资源，首先需要使用Catche-Control:no-cache使浏览器每次都请求服务器，然后配合ETag或者Last-Modified来验证资源是否有效。 20. 浏览器渲染原理 浏览器接收到HTML文件并转换为DOM树 在网络传输的内容其实都是0和1这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。当数据转换为字符串以后，浏览器会将这些字符串通过词法分析转换为标记。这些标记会紧接着转换为Node，最后这些Node会根据不同Node之间的联系构成为一棵DOM树 将CSS文件转换为CSSOM树 其实转换CSS到CSSOM树的过程和上一小节的过程是极其类似的 在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归CSSOM树，然后确定具体的元素到底是什么样式 生成渲染树 当我们生成DOM树和CSSOM树以后，就需要将这两棵树组合为渲染树 在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是display:none的，那么就不会在渲染树中显示 当浏览器生成渲染树以后，就会根据渲染树来进行布局，然后调用GPU绘制，合成图层，显示在屏幕上。 为什么操作DOM慢? 因为DOM是属于渲染引擎中的东西，而JS又是JS引擎中的东西。当我们通过JS操作DOM的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作DOM次数一多，也就等同于一直在进行线程之间的通信，并且操作DOM可能会带来重绘回流的问题，所以也就导致了性能上的问题。 重绘和回流 重绘是当节点需要更改外观而不会影响布局的，比如改变color就叫成为重绘 回流是布局或者几何属性需要改变就成为回流 回流必定发生重绘，重绘不一定会引发回流。回流所需要的成本比重绘高的多，改变父节点的子节点很可能会导致父节点的一系列回流。 以下几个动作可能会导致性能问题 改变window大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 减少重绘和回流 使用visibility替换display:none，因为前者只会引起重绘，后者会引发回流(改变了布局) 不要把节点的属性值放在一个循环里当成循环里的变量 不要使用table布局，可能很小的一个小改动会造成整个table的重新布局 css选择符从右往左匹配查找，避免节点层级过多 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。 21. 安全防范 xss xss，就是攻击者想尽一切办法将可以执行的代码注入到网页中。 xss，可以分为多种类型，但是总体上可以分为两类：持久型和非持久型 持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都收到攻击 举个例子，对于评论功能来说，就得防范持久型xss攻击，因为我可以在评论中输入以下内容 这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到 非持久型相比前者危害就小的多，一般通过修改URL参数的方式加入攻击代码，诱导用户访问链接从而进行攻击 举个例子，如果页面需要从URL中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行 12&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; 对于XSS攻击来说，通常由两种方式可以用来防御 转义字符 首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号，尖括号，斜杠进行转义 12345678910function escape(str) &#123; str = str.replace(/&amp;/g, '&amp;amp;') str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/&gt;/g, '&amp;gt;') str = str.replace(/\"/g, '&amp;quto;') str = str.replace(/'/g, '&amp;#39;') str = str.replace(/`/g, '&amp;#96;') str = str.replace(/\\//g, '&amp;#x2F;') return str &#125; 通过转义可以将攻击代码 alert(1) 变成 // -&gt; &lt;script&gt;alert(1)&lt;&#x2F;script&gt;escape(‘alert(1)‘) CSP CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少XSS攻击 通常可以通过两种方式来开启CSP: 设置HTTP Header中的Content-Security-Policy 设置meta标签的方式&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt; 只允许加载本站资源 1Content-Security-Policy: default-src ‘self’ 只允许加载 HTTPS 协议图⽚ 1Content-Security-Policy: img-src https://* 允许加载任何来源框架 1Content-Security-Policy: child-src 'none' CSRF CSRF 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑 举个例子，假设网站中有一个通过GET请求提交评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口 1&lt;img src=\"http://www.domain.com/xxx?comment='attack'\"/&gt; 如何防御 GET请求不对数据进行修改 不让第三方网站访问到用户Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者Token SameSite 可以对Cookie设置SameSite属性。该属性表示Cookie不随着跨域请求发送，可以很大程度减少CSRF的攻击，但是该属性目前并不是所有浏览器都兼容 Token 服务器下发一个随机Token，每次发起请求时将Token携带上，服务器验证Token是否有效 22. 性能优化 图片优化 计算图片大小 在实际项目中，一张图片可能不需要使用很多颜色去显示，可以通过减少每个像素的调色板来相应缩小图片的大小 图片加载优化 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用CSS去代替 一般图片都用CDN加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片 小图使用base64格式 将多个图标文件整合到一张图片中 选择正确的图片格式 小图使用PNG，其实对于大部分图片这类图片，完全可以使用SVG代替 照片使用JPEG DNS预解析 DNS解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的IP 1&lt;link rel=\"dns-prefetch\" href=\"//blog.poetries.top\"&gt; 节流 考虑一个场景，滚动事件中发起网络请求，但是我们并不希望用户在滚动过程中中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流 123456789101112131415161718192021//func 是用户传入需要防抖的函数//wait是等待时间const throttle = (func,wait=50) =&gt;&#123; //上一次执行该函数的时间 let lastTime = 0 return function(...args)&#123; //当前时间 let now = +new Date() //将当前时间和上一次执行函数时间对比 //如果差值大于设置的等待时间就执行函数 if(now -lastTime &gt;wait)&#123; lastTime =now func.apply(this,args) &#125; &#125;&#125;setInterval( throttle(()=&gt;&#123; console.log(1) &#125;,500)) 防抖 考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望没每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们可以使用防抖 123456789101112131415//func 是用户传入需要防抖的函数//wait是等待时间const debounce = (func,wait=50) =&gt;&#123; //缓存一个定时器id let timer=0 //这里返回的函数是每次用户实际调用的防抖函数 //如果已经设定过定时器了就清空上一次的定时器 //开始一个新的定时器，延迟执行用户传入的方法 return function(..args)&#123; if(timer) clearTimeout(timer) timer = setTimeout(()=&gt;&#123; func.apply(this,args) &#125;,wait) &#125;&#125; 预加载 在开发中，可能遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候可以使用预加载 预加载其实是声明的fetch，强制浏览器请求资源，并不会阻塞onload事件，可以使用以下代码开启预加载 1&lt;link rel=\"preload\" href=\"http://blog.poetries.top\"&gt; 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好 懒加载 懒加载就是将不关键的资源延后加载 懒加载的原理就是只加载自定义区域(通常是可视区域，但也可以是即将进入可视区域)内需要加载的东西。对于图片来说，先设置图片标签的src属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为src属性，这样图片就会去下载资源，实现了图片懒加载 懒加载不仅可以用于图片，也可以使用在别的资源。比如进入可视区域开始播放视频等等 CDN CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源 我们可以将静态资源尽量使用CDN加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个CDN域名。并且对于CDN加载静态资源需要注意CDN域名要与主站不同，否则每次请求都会带上主站的Cookie 23. MVVM/虚拟DOM/前端路由什么是MVVM？与之MVC有什么区别？ view很简单，就是用户看到的视图 Model同样很简单，一般就是本地数据和数据库中的数据 传统的MVC框架通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新 但是MVC有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况 在MVVM架构中，引入了ViewModel的概念。ViewModel只关心数据和业务的处理，不关心view如何处理数据，在这种情况下，view和model都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个ViewModel中，让多个View复用这个ViewModel 对于MVVM来说，其实最重要的并不是通过双向绑定或者其他的方式将View与viewModel绑定起来，而是通过ViewModel将视图中的状态和用户的行为分离出一个抽象，这才是MVVM的精髓 Virtual DOM 设计面试题： 什么是Virtual DOM？为什么Virtual DOM比原生DOM快？ 12345678910const ul =&#123; tag: 'ul', props:&#123; class:'list' &#125;, children:&#123; tag:'li', children:'1' &#125;&#125; 上述代码对应的DOM就是 123&lt;ul class=\"list\"&gt; &lt;li&gt;1&lt;/li&gt;&lt;/ul&gt; 那么既然DOM可以通过JS对象来模拟，反之也可以通过JS对象来渲染出对应的DOM。当然了，通过JS来模拟DOM并渲染对应的DOM只是第一步，难点在于如何判断新旧两个JS对象的最小差异并且实现局部更新DOM 首先DOM是一个多叉树的结构，如果需要完整的对比两棵树的差异，那么需要的时间复杂度会使O(n^3)那么复杂度肯定是不能接受的。于是优化了算法，实现了O(n)的复杂度来对比差异。 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异 一旦节点有子元素，就去判断子元素是否有不同 在第一步算法中我们需要判断新旧节点的tagName是否相同，如果不相同的话就代表节点被替换。如果没有更改tageName的话，就需要判断是否有子元素，有的话就进行第二步算法。 在第二步算法中，我们需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动 举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更 1234//假设这里模拟一个ul，其中包含了5个li[1,2,3,4,5]//这里替换上面的li[1,2,5,4] 从上述例子中，我们可以一眼看出先前的ul中的第三个li被移除了四五替换了位置 当然在判断以上差异的过程汇总，我们还需要判断节点的属性是否有变化等等 当我们判断出以上的差异后，就可以把这些差异记录下来。当对比完两棵树以后，就可以通过去局部更新DOM，实现性能的最优化 将Virtual DOM作为一个兼容层，让我们还能对接非Web端的系统，实现跨端开发 实现组件的高度抽象化 前端路由 Hash模式 History模式 Hash模式 ·www.test.com/#/就是Hash URL，当#后面的哈希值发生变化时，可以通过hashchange事件来监听到URL的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的URL请求永远是www.test.com 123window.addEventListener('hashchange'，()=&gt;&#123; //...具体逻辑&#125;) Hash模式相对来说更简单，并且兼容性也更好 History模式 History 模式是HTML5新推出的功能，主要使用history.pushState和history.replaceState改变URL 通过History模式改变URL同样不会引起页面的刷新，只会更新浏览器的历史记录 1234//新增历史记录history.pushState(stateObject,title,URL)//替换当前历史记录history,replaceState(stateObject,title,URL) 当用户做出浏览器动作时，比如点击后托按钮时触发popState事件 1234window.addEventListener('popState',e=&gt;&#123; //e.state 就是`pushState(stateObject)中的stateObject` console.log(e.state)&#125;) 两种模式对比 hash模式只可以更改#后面的内容，History模式可以通过API设置任意的同源URL History模式可以通过API添加任意类型的数据到历史记录中,Hash模式只能更改哈希值，也就是字符串 Hash模式无需后端配置，并且兼容性好。History模式在用户手动输入地址或者刷新页面的时候发起URL请求，后端需要配置index.html页面用于匹配不到静态资源的时候 24. Vue常考知识点生命周期钩子函数 在beforeCreate钩子函数调用的时候，是获取不到props或者data中的数据的，因为这些数据的初始化都在initState中 然后会执行created钩子函数，在这一步的时候已经可以访问到之前不能访问的数据，但是这时候组件还没被挂载，所以是看不到的 接下来会先执行beforeMounted钩子函数，开始创建VDOM，最后执行mounted钩子，并将VDOM渲染为真实DOM并且渲染数据。组件中如果有子组件的话，会递归挂载组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子 接下来是数据更新时会调用的钩子函数beforeUpdate和updated，这两个钩子函数没有什么好说的，就是分别在数据更新前和更新后调用 另外还有keep-alive独有的生命周期,分别为activated和decativated。用keep-alive包裹的组件在切换时不会进行销毁，而是魂村到内存中并执行deactivated钩子函数，命中缓存渲染后执行actived钩子函数 最后就是销毁组件的钩子函数beforeDestory和destoryed。前者适合移除事件，定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的destoryed钩子函数 组件通信 父子组件通信 兄弟组件通信 跨多层级组件通信 父子通信 父组件通过prop传递数据给子组件，子组件通过emit发送事件传递给父组件，这两种方式是最常用的父子通信实现方法 这种父子通信方式也就是典型的单向数据流，父组件通过props传递数据，子组件不能直接修改props而是必须通过发送事件的方式告知父组件修改数据 当然我们还可以通过访问$parent或者$children对象来访问组件实例中的方法和数据 另外如果你使用Vue2.3及以上版本的话还可以使用$listeners和.sync这两个属性 $listeners属性会将父组件中的v-on事件监听器传递给子组件，子组件可以通过访问$listeners来自定义监听器 .sync属性是个语法糖，可以很简单的实现子组件与父组件通信 123456789// 父组件中&lt;input :value.sync=\"value\"&gt;//以上写法等同于&lt;input :value=\"value\" @update:value=\"v=&gt;value =v\"&gt;//子组件中&lt;script&gt; this.$emit('update:value',1)&lt;/script&gt; 兄弟组件通信 对于这种情况可以通过查找父组件中的子组件实现，也就是this.$parent.$children，在$children中可以通过组件name查询到需要的组件实例，然后进行通信 跨多层次组件通信 d对于这种情况可以使用新增的API provide/ inject，虽然文档中不推荐直接使用在业务中，但是如果用的好的话还是很有用的 假设有父组件A，然后有一个跨多层级的子组件B 1234567891011121314//父组件Aexport default&#123; provide:&#123; data:1 &#125;&#125;//子组件Bexport default&#123; inject:['data'], mounted()&#123; //无论跨基层都能获得父组件的data属性 console.log(this.data) &#125;&#125; 终极办法解决一切通信问题 可以使用Vuex或者Event Bus extend能做什么 这个API很少用到，作用是扩展组件生成一个构造器，通常会与$mount一起使用 1234567891011121314//创建组件构建器let Component = Vue.extend(&#123; template: '&lt;div&gt;test&lt;/div&gt;'&#125;)//挂载到#app上new Component().$mount('#app')//除了上面的方式，还可以用来扩展已有的组件let SuperComponent = Vue.extend(Component)new SuperComponent(&#123; created()&#123; console.log(1) &#125;&#125;)new SuperComponent().$mount('#app') mixin和mixins区别 mixin用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的 123456Vue.mixin(&#123; beforeCreate()&#123; //...逻辑 //这种方式会影响到每个组件的`beforeCreate`钩子函数 &#125;&#125;) 虽然文档不建议我们在应用中直接使用mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的ajax或者一些工具函数等等 mixins应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过mixins混入代码，比如上拉下拉加载数据这种逻辑等等 另外需要注意的是mixins混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并 computed和watch区别 computed是计算属性，依赖其他属性计算值，并且computed的值由缓存，只有当计算值变化才会返回内容 watch监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作 所以一般来说需要依赖别的属性来动态获得值的时候可以使用computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用watch 另外computed和watch还都支持对象的写法 123456789101112131415161718192021222324vm.$watch('obj',&#123; //深度遍历 deep:true //立即触发 immediate： true， //执行的函数 handler: function(val, oldVal)&#123;&#125;&#125;)var vm = new Vue(&#123; data:&#123;a:1&#125;, computed:&#123; aPlus:&#123; //this.aPlus 时触发 get: function()&#123; return this.a +1 &#125;, //this.aPlus =1 时触发 set: function(v)&#123; this.a =v -1 &#125; &#125; &#125;&#125;) keep-alive 组件有什么作用 如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用keep-alice组件包裹需要保存的组件 对于keep-alive组件来说，它拥有两个独有的生命周期函数，分别为activated和deactivated。用keep-alive包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行deactivated钩子函数，命中缓存渲染后执行actived钩子函数 v-show 与v-if区别 v-show只是在display:none和display:block之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换CSS，DOM还是一致保留着的。所以总的来说v-show在初始选时有更高的开销，但是切换开销很小，更适合于频繁切换的场景 v-if的话就得说到Vue底层的编译了。当属性初始为false时，组件就不会被渲染，直到条件为true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景 并且基于v-if的这种惰性机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销 组件中data什么时候可以使用对象 组件复用时所有组件实例都会共享data，如果data是对象的话，就会造成一个组件修改data以后会影响到其他所有组件，所以需要将data写成函数，每次用到就调用一次函数获得新的数据 当我们使用new Vue()的方式的时候，无论我们将data设置为对象还是函数都是可以的，因为new Vue()的方式是生成一个根组件，该组件不会复用，也就不存在共享data的情况 响应式原理 Vue 内部使用了Object.defineProperty()来实现数据响应式，通过这个函数可以监听到set和get的事件 12345678910111213141516171819202122232425262728293031323334var data = &#123;name: 'poetries'&#125;observe(data)let name = data.name //-&gt; get valuedata.name ='yyy' //-&gt;change valuefunction observe(obj)&#123; //判断类型 if(!obj || typeof obj !== 'object')&#123; return &#125; Object.keys(obj).forEach(key=&gt;&#123; defineReactive(obj,key,obj[key]) &#125;) &#125;function defineReactive(obj,key,val)&#123; //递归子属性 observe(val) Object.defineProperty(obj,key,&#123; //可枚举 enumerable: true, //可配置 configurable: true, //自定义函数 get: function reactiveGetter()&#123; console.log('get value') return val &#125;, set: function reactiveaSetter(newVal)&#123; console.log('change value') val = newVal &#125; &#125;)&#125; 以上代码简单的实现了如何监听数据的set和get的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，从而在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集 123&lt;div&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt; 接下来我们先来实现一个Dep类，用于解耦属性的依赖收集和派发更新操作 123456789101112131415161718//通过Dep解耦属性的依赖和更新操作class Dep&#123; constructor()&#123; this.subs =[] &#125; //添加依赖 addSub(sub)&#123; this.subs.push(sub) &#125; //更新 notify()&#123; this.subs.forEach(sub=&gt;&#123; sub.update() &#125;) &#125;&#125;//全局属性，通过该属性配置WatcherDep.target =null 以上的代码实现很简单，当需要依赖收集的时候调用addSub，当需要派发更新的时候调用notify 接下来我们先简单的了解下Vue组件挂载时添加响应式的过程。在组件挂载时，会先对所有需要的属性调用Object.defineProperty()，然后实例化watcher，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集 12345678910111213141516171819class Watcher&#123; constructor(obj,key,cb)&#123; //将`Dep.target`指向自己 //然后触发属性的`getter`添加监听 //最后将`Dep.target置空` Dep.target =this this.cb =cb this.key =key this.obj =obj this.value = obj[key] Dep.target =null &#125; upDate()&#123; //获得新值 this.value = this.obj[this.key] //调用update方法更新Dom this.cb(this.value) &#125;&#125; 以上就是Watcher的简单实现，在执行构造函数的时候将Dep.target指向自身，从而使得收集到了对应的Watcher，在派发更新的时候取出对应的Watcher然后执行update函数 接下来，需要对defineReactive函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码 1234567891011121314151617181920212223function defineReactive(obj,key,val)&#123; //递归子属性 observe(val) let dp = new Dep() Object.defineProperty(obj.key,&#123; enumerable:true, configurable: true, get: function reactiveGetter()&#123; console.log('get value') //将`Watcher`添加到订阅 if(Dep.target)&#123; dp.addSub(Dep.target) &#125; return val &#125;, set: function reactiveSetter(newVal)&#123; console.log('change value') val = newVal //执行 watcher 的 update 方法 dp.notify() &#125; &#125;)&#125; 以上代码实现了一个简单的数据响应式，核心思路就是手动触发一次属性的getter来实现依赖收集 Object.defineProperty的缺陷 如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为Object.defineProperty不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是Vue内部通过重写函数的方式解决了这个问题。 NextTick原理分析 nextTick可以让我们在下次DOM更新循环结束之后执行延迟回调，用于获得更新后的DOM 25. TCP/UDP UDP 与TCP的区别 首先，UDP协议是面向无连接的，也就是不需要在正式传递数据之前先连接器双方。然后UDP协议知识数据报文的搬运工，不保证有序且不丢失的传递到对端，并且UDP协议也没有任何控制流量的算法，总的来说UDP相较于TCP更加轻巧 面对无连接 首先UDP是不需要和TCP一样在发送数据前进行三次握手建立连接的，想法数据就可以发送了 并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作 不可靠性 首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定是不可靠 并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了 再者网络环境时好时坏，但是UDP因为没有拥塞控制，一直会以恒定的速度发送数据 高效 虽然UDP协议不是那么的靠谱，但是正因为它不是那么可靠，所以也没有TCP那么复杂了，需要保证数据不丢失且有序到达。 因此UDP的头部开销小，只有八字节 传输方式 UDP不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是UDP提供了单播，多播，广播的功能 适合使用场景 直播 王者荣耀(游戏，网络游戏) TCP TCP基本是和UDP反着来，建立连接断开连接连接都需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比UDP来说并不那么高效 头部 对于TCP头部来说，以下几个字段是很重要的 Sequence number，这个序号保证了TCP传输的报文都是有序的，对端可以通过需要顺序的拼接报文 Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到 后续在写 26. 设计模式 设计模式总的来说是一个抽象的概念，前人通过无数次的实践总结出的一套写代码的方式，通过这个方式写的代码可以让别人更加容易阅读，维护以及复用 工厂模式 1234567891011121314class Man&#123; constructor(name)&#123; this.name =name &#125; alertName()&#123; alert(this.name) &#125;&#125;class Factory&#123; static create(name)&#123; return new Man(name) &#125;&#125;Factory.create('yck').alertName() 当然工厂模式并不仅仅是用来new 出实例 可以想想一个场景、假设有一份很复杂的代码需要用户去调用，但是用户并不关心这些复杂的代码，只需要你提供给我一个接口去调用，用户只负责传递需要的参数，至于这些参数怎么使用，内部又什么逻辑是不关心的，只需要你最后返回我一个实例。这个构造函数就是工厂 工厂起到的作用就是隐藏了创建实例的复杂度，只需要提供一个接口，简单清晰 在Vue源码中，你也可以看到工厂模式的使用，比如创建异步组件 12345678910111213141516171819export function createComponent ( Ctor: Class&lt;Component&gt; | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag?: string ): VNode | Array&lt;VNode&gt; | void &#123; // 逻辑处理... const vnode = new VNode( `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : ''&#125;`, data, undefined, undefined, undefined, context, &#123; Ctor, propsData, listeners, tag, children &#125;, asyncFactory ) return vnode &#125; 在上述代码中，我们可以看到我们只需要调用createComponent传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能 单例模式 单例模式很常用，比如全局缓存，全局状态管理等等这些只需要一个对象，就可以使用单例模式 单例模式的核心就是保证全局只有一个对象可以访问。因为JS是门无类的语言，所以别的语言实现单例的方式并不能套入JS中，我们只需要用一个变量实例只创建一次就行，以下是如何实现单例模式的例子 12345678910111213141516class Singleton&#123; constructor()&#123;&#125;&#125;Singleton.getInstance =(function()&#123; let instance return function()&#123; if(!instance)&#123; instance = new Singleton() &#125; return instance &#125;&#125;)()let s1 = Singleton.getInstance()let s2 = Singleton.getInstance()console.log(s1 === s2) //true 在Vuex源码中，你也可以看到单例模式的使用，虽然它的实现方式不大一样，通过一个外部变量来控制只安装一次Vuex 123456789let Vue //bind on installexport function install(_Vue)&#123; if(Vue &amp;&amp; _Vue === Vue)&#123; //如果发现Vue有值，就不重新创建实例了 return &#125; Vue = _Vue applyMixin(Vue)&#125; 适配器模式 适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。 以下是如何实现适配器模式的例子 123456789101112131415class Plug&#123; getName()&#123; return '港版插头' &#125;&#125;class Target&#123; constructor()&#123; this.plug =new plug() &#125; getName()&#123; return this,plug.getName()+ '适配器转二脚插头' &#125;&#125;let target = new Target()target.getName() //港版插头 适配器转二脚插头 在Vue中，我们其实使用到适配器模式。比如父组件传递给子组件一个时间戳属性，组件内部需要将时间戳转为正常的日期显示，一般会使用computed来做转换这件事，这个过程就使用了适配器模式 装饰模式 装饰器模式不需要改变已有的接口，作用是给对象添加功能。就像我们经常需要给手机戴个保护套一样，不改变手机自身，给手机添加添加了保护套提供了防摔功能 以下是如何实现装饰器模式的例子，使用了ES7中的装饰器语法 1234567891011function readonly(target,key,descriptor)&#123; descriptor.writable =false return descriptor&#125;class Test&#123; @readonly name ='yck'&#125;let t = new Test()t.yck = '111' //不可修改 代理模式 代理是为了控制对象的访问，不让外部直接访问到对象。在现实生活中，也有很多代理场景。比如你需要买一件国外的产品，这时候你可以通过代购来购买产品 在实际代码中其实代理的场景很多，比如事件代理就用到了代理模式 12345678910111213&lt;ul id=\"ul\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; let ul = document.querySelector('#ul') ul.addEventListener('click',(event)=&gt;&#123; console.log(event.target) &#125;)&lt;/script&gt; 因为存在太多的li，不可能每个都去绑定事件。这时候可以通过父节点绑定一个事件，让父节点作为代理去拿到真实点击的节点 发布-订阅模式 发布-订阅模式也叫做观察者模式。通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。在现实生活中，也有很多类似场景，比如我需要在购物网站上购买一个产品，但是发现该产品目前处于缺货状态，这时候我们可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我 在实际代码中其实发布-订阅模式也很常见，比如我们点击一个按钮触发了点击事件就是使用了该模式 1234567&lt;ul id=\"ul\"&gt;&lt;/ul&gt;&lt;script&gt; let ul =document.querySelector('#ul') ul.addEventListener('click',(event)=&gt;&#123; console.log(event.target) &#125;)&lt;/script&gt; 在Vue中，如何实现响应式也是使用了该模式。对于需要实现响应式的对象来说，在get的时候会进行依赖收集，当改变了对象的属性时，就会触发派发更新","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://blog.liurugang.cn/tags/%E6%80%BB%E7%BB%93/"},{"name":"面试","slug":"面试","permalink":"http://blog.liurugang.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"前端面试题-续","slug":"前端面试题-续","date":"2021-05-27T08:46:02.642Z","updated":"2021-05-27T09:32:12.526Z","comments":true,"path":"posts/25536/","link":"","permalink":"http://blog.liurugang.cn/posts/25536/","excerpt":"","text":"前端面试题基础题HTML，HTTP，web综合问题18.请描述一个cookie，sessionStorage和localStorage的区别？ cookie是网站为了标示用户身份而储存用户本地终端上的数据 cookie数据始终在同源的http请求中携带，记会在浏览器和服务器间来回传递 sessionStorage和 localStorage不会自动把数据发送服务器，仅在本地保存 存储大小： cookie数据大小不能超过4K sessionStorage和localStorage虽然也有存储大小的限制，但是比cookie大得多，可以到达5M或更大 有效时间： localStroage： 储存持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage： 数据在当前浏览器窗口关闭后自动删除 cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 19. Canvas 和SVG有什么区别 svg 绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。Canvas输出的是整个画布 svg输出的图形是矢量图形，后期可以修改参数自由放大缩小，不会失真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿 20. viewport1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0 maximum-scale=1.0 user-scalable\"&gt; width 设置viewport宽度，为一个正整数，或字符串‘device-width’ ‘device-width ’设备宽度 height 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置 initial-scale 默认缩放比例 ，为一个数字，可以带小数 minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数 maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数 user-scalable 是否允许手动缩放 21. 渲染优化 禁止使用iframe 禁止使用gif图片实现loading效果(降低CPU消耗，提高渲染性能) 使用CSS3代码替代JS动画（尽可能避免重绘重排以及回流） 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较消耗CPU 页面中不要出现空的href和src 会阻塞页面其他资源对的加载 用innerHTML代替DOM操作，减少DOM操作次数，优化JavaScript性能 当需要设置的样式很多时设置className，而不是直接操作style 图片预加载，将样式表放在顶部，将脚本放在底部加上时间戳 少用全局变量，缓存DOM节点查找的结果。减少IO读取操作 22.简述一下src与href的区别 src用于替换当前元素，href用于当前文档和引用资源之间确认联系。 src 指向外部资源的位置，指向的内容将会嵌套入文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如JS脚本，img图片等元素 &lt;script src=&quot;js.js&quot;&gt;&lt;/script&gt;当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到该资源加载，编译，执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部 href 是指向网络资源所在位置，建立和当前元素或当前文档之间的链接，如果我们在文档中添加 &lt;link href=&quot;common.css &quot;/&gt;那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方法加载css，而不是使用@import方式 23. 一个页面上有大量的图片(大型电商网站)，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。 图片懒加载，在页面上未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶部的距离与页面的距离，如果前者小于后者，优先加载。 如果为幻灯片，相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先加载。 如果图片为css图片，可以使用CSSsprite，SVGsprite， Iconfont， Base64 等技术 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩特别厉害的缩略图，以提高用户体验。 如果图片展示区域小于图片的真实大小，则因在服务器daunt根据业务需要先行进图片压缩，图片压缩后大小与展示一致","categories":[],"tags":[]},{"title":"基本面分析选股的十大思路","slug":"基本面分析选股的十大思路","date":"2021-02-09T15:01:04.063Z","updated":"2021-05-27T09:32:12.529Z","comments":true,"path":"posts/39011/","link":"","permalink":"http://blog.liurugang.cn/posts/39011/","excerpt":"","text":"基本面分析选股的十大思路一， 10年以上的内在价值增长率这是最重要的经营指标，虽然简单却经常被人忽略 不同的企业有不同的内在价值评估标准，例如银行股最看重的是净资产的增长；以轻资产为代表的格力电器等，看重的则是净利润的增长；而那些尚未盈利的电商，则以营业收入的增长作为参考指标等。 投资者在看财报三大表时，如果非新股的，上市有一段时间的，以应该通过choice金融终端，通过可视化图标，查询过去历年的内在价值增长率情况。时间越久，数据经受得起考验。 有些上市公司，动不动当期财报百分之几百的增长，请您去看看它的背后的原因是什么？能持久吗？或许就离真相不远了。 二，长期的ROE水平这里也涉及到具体情况分析，每个行业甚至每家企业都有着不同的评估体系。 重资产行业一般回报率15%是较为优秀的，而轻资产行业净资产回报率达到30%以上才算优秀。 投资者买股票，就等于成为公司股东，一家上市公司不管有多少理由，最终是否优秀，依然是在不违法的范围内，能给投资人带来多少真正的回报。 ROE净资产收益率，就是反映这一情况的经典指标。 三，行业属性该行业是否需要不断的，巨大的资本开支才能维持？ 这是“一本万利”的优秀模式？ 技术更新，商业模式变更是否缓慢？ 是否存在商业生态系统之外的竞争性力量介入？ 四, 市场容量是否拥有永续的需求存在？瓶颈以及天花板的大致位置在哪里？ 有些行业，其成长空间是注定有限的，这种行业的企业，注定了，是不会有真正意义上的股价大涨的，所谓的上涨，其本质只是跟随大盘上下起舞的波动 而有些行业，即使做到行业前三，甚至老大，都没能怎么盈利，那就不是企业的问题了，而是该行业本身市场容量的问题，比如共享单车。 如果一家共享单车企业已经是行业老大了，依然没能让投资人盈利，这或许从做生意的角度，就不是一笔好生意。 五, 财务报表背后不仅听其言，更要观其行。不要去看这家上市公司在说什么，而是看他做了什么。 本质上，财务报表就是一家企业经营行为的真实描述，三张表的解读，就可以看出管理层是否诚实，经营哲学是否保守还是激进。 六，商业模式长期看是否具有”护城河模型“的特点 曾经美国有一家初创企业A，凭借一个独特的idea，让公司业务蒸蒸日上，结果B企业把它的idea依样画葫芦全部抄走。A起诉B,B一边应诉一边扩大市场份额，A一心一意和法院打着交道。 结果几年之后。A拿着少的可怜的胜诉费，破产了。B发展到了今天 七，股权结构是否有管理层持股？管理层的立场，和股东的立场是否一致？如果一家公司，管理层依靠薪水为生的，那他的最高利益一定不是努力扩大美股收益，而是铺开摊子让自己薪水更高。 股东结果是否有利于管理？如果没有唯一大股东，而是俩个各持15%的股东，小心扯皮。 八，公司治理结构要求是体制精良，已成系统且运行流畅。 公司盈利，要么开源，要么节流。节流，关系到期间费用，也就是利润表中的财务费用，管理费用和销售费用，以及研发费用等，这个费用的多少，以及同等费用能够获得多大效益，都取决于公司治理结构。 九，管理水准最重要的参考指标便是公开言论以及长期财务数据背后透露出的经营哲学，长期是否言行一致，是否符合商业常识，比如研发支出资本化还是费用化，便显示出一家公司会计处理是否保守还是激进等等。 十，最好有5-10年以上的持续经营记录可供考察也就是经历过至少一轮完整对的经济周期波动，只有全面的了解其在波峰波谷的经营表现才能深知此企业的经营哲学，例如是在波峰还是波谷积极扩张之后所面临的经营结果具有天壤之差别。 从以上的这些变量中找到驱动内在价值成长或毁坏股东权益的因素来，并且判断这些因素在未来是否可持续。这样选择优质股就会相对比较轻松。","categories":[],"tags":[]},{"title":"CSS面试","slug":"CSS面试部分","date":"2021-01-31T12:43:44.732Z","updated":"2021-01-31T14:51:27.224Z","comments":true,"path":"posts/520520/","link":"","permalink":"http://blog.liurugang.cn/posts/520520/","excerpt":"","text":"CSS面试部分1. css sprite是什么，有什么优缺点 概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示要显示的背景图案 优点： 减少HTTP请求数，极大地提高页面加载速度 增加图片信息重复度，提高压缩比，减少图片大小 更换风格方便，只需要在一张或几张图片上修改颜色或样式即可实现 缺点 图片合并麻烦 维护麻烦，修改一个图片可能需要从新布局整个图片，样式 2. display:none;与visibility:hidden;的区别 联系：他们都能让元素不可见 区别 display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibi;ity:hidden;不会让元素从渲染树消失，渲染时元素继续占据空间，只是内容不可见 修改常规流中元素的display通常会造成文档重排。修改visiblity属性只会造成元素的重绘 3. link和@import的区别 link是HTML方式，@import是CSS方式 link最大限度支持并行下载，@import过多嵌套导致串行下载 @import必须在样式规则之前，可以在css文件中引用其他文件 总体上来说：link由于@import 4. 如何创建块级格式化上下文，BFC有什么用 创建规则： 根元素 浮动元素(float不取值为none) 绝对定位元素(position取值为absolute或fixed) display取值为inline-block,flex之一的元素 overflow不取值为visibale的元素 作用 可以包含浮动元素 不被浮动元素覆盖 阻止父子元素的margin折叠 5. 清浮动的几种方式，各自的优缺点 父级div定义height 结尾处加空div标签clear:both 父级div定义伪类:after和zoom 父级div定义overflow:hidden 6. css3有哪些新特性 新增各种css选择器 圆角border-radius 多列布局 阴影和反射 文字特性text-shadow 线性渐变 旋转transform css3新增伪类有哪些？ p:first-of-type选择属于其父元素的首个&lt;p&gt;元素的每个&lt;p&gt;元素 p:last-of-type选择属于其父元素的最后&lt;p&gt;元素的每个&lt;p&gt;元素 p:nth-child(2)选择属于其父元素的第二个子元素的每个&lt;p&gt;元素 :before在元素之前添加内容 :after在元素之后添加内容，也可以用来做清浮动 :enabled已启用的表单元素 :disable已经禁用的表单元素 :checked单选框或复选框被选中 7 .介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同？ 有两种：IE盒模型，W3c盒子模型 盒模型：内容（content）,填充(padding),边界(margin)，边框（border） 区别： IE的content部分把border和padding计算了进去 8. 几种常见的CSS布局流体布局 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;流体布局&lt;/title&gt; &lt;style&gt; .left&#123; float:left; width:100px; height: 200px; background: red; &#125; .right&#123; float:right; width: 200px; height: 200px; background: blue; &#125; .main&#123; margin-left: 120px; margin-right: 220px; height: 200px; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 圣杯布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;圣杯布局&lt;/title&gt; &lt;style&gt; .container&#123; margin-left: 120px; margin-right: 220px; &#125; .main&#123; float: left; width: 100%; height: 300px; background: green; &#125; .left&#123; position: relative; left: -120px; float: left; height: 300px; width: 100px; margin-left: -100%; background: red; &#125; .right&#123; position: relative; right: -220px; float: right; height: 300px; width: 200px; margin-left: -220px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;双飞翼布局&lt;/title&gt; &lt;style&gt; .content&#123; float:left; width: 100%; &#125; .main&#123; height: 200px; margin-left: 110px; margin-right: 220px; background: green; &#125; .main:after&#123; content:''; display:block; font-size: 0; height: 0; zoom: 1; clear:both &#125; .left&#123; float: left; height: 200px; width: 100px; margin-left: -100%; background: red; &#125; .right&#123; float: right; height: 200px; width: 200px; margin-left: -200px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"content\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 9.什么是外布局重叠？重叠的结果是什么？ 在css当中,相邻的两个盒子(可能是兄弟关系也可能是祖先关系)的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠。(前提是上下边框，而非左右边框) 折叠结果遵循一下计算规则 两个相邻的外边框都是正数时，折叠结果是他们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值 两个外边框一正一负时，折叠结果是两者的相加的和 10. 水平居中的方法 元素为行内元素，设置父元素text-align:center 元素为宽度固定，设置左右margin为auto 如果元素为绝对定位，设置父元素position为relative，元素设置为left：0;right:0;margin:auto 使用flex-box布局，指定justify-content属性为center display设置为table-ceil 11.垂直居中的方法 使用flex布局设置为align-item:center 绝对定位中设置bottom:0,top:0，并设置margin:auto 绝对定位中固定高度时设置top:50%;margin-top为为高度一半的负值 文本垂直居中设置line-height为height值 12. 重绘和回流是什么，如何避免 DOM变化影响到了元素的几何属性，浏览器重新计算元素的几何属性，其他元素的几何属性和位置也会受到影响，浏览器需要重新构造渲染树，这个过程称为重排。 浏览器将受到影响的部分重新绘制到屏幕上的过程称为重绘 引起重排的原因有： 添加或者删除可见的DOM元素 元素位置，尺寸，内容改变 浏览器页面初始化 浏览器页面初始化 浏览器窗口尺寸改变 触发重绘的操作 visibilty，背景色等属性导致样式的变化 重排一定重绘，重绘不一定重排 提升性能，减少重排重绘方法 将多次改变样式属性的操作合并成一次操作，尽量都是操作class 将多次重排的元素设为absolute或者fixed。这样元素就脱离了文档流，它的变化不会影响到其他元素，比如有动画效果的元素 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排 13. 说一说css3的animation css3的animation是css3新增的动画属性，这个css3动画的每一帧是通过@keyframes来声明的，keyframes声明了动画的名称，通过from，to或者百分比定义 每一帧动画元素的状态，通过animation-name来引用这个动画，同时css3动画也可以定义动画运行的时长，动画开始事件，动画播放方向，动画循环次数，动画播放的方式 常用的属性有：animation-name定义动画名，animation-duration定义动画播放的时长，animation-delay东一动画延迟播放的时间，animation-duration定义动画播放的时长 14. 如何实现小于12px的字体效果 transfrom:scale()这个属性只可以缩放定义宽高的元素，而行内元素是没有宽高的，我么可以加上display:inline-block 15. 解决移动端下1px像素问题 border-image 12border:1px solid transparentborder-image:url('./../../image/96.jpg'2 repeat) 图片的颜色就是此后border的颜色 总结：优点：没有副作用 缺点：border颜色变了就得重新绘制图片;圆角会比较模糊 使用box-shadow实现 1234box-shadow:0 -1px 1px -1px 1px 0 1px -1px 0 1px 1px -1px -1px 0 1px -1px 前面两个值x，y主要控制显示那条边，后面两值控制的是阴影半径，扩展半径。 总结 优点：使用简单，圆角也可以实现 缺点：模拟的实现方法，仔细看就知道这事阴影不是边框 使用伪类(推荐) 1条border 1234567891011121314.setOnePx&#123; position：relative &amp;::after&#123; position:absolute; content:''; background-color:#e5e5e5; display:block; width:100%; height:1px; transform:scale(1,0.5) top:0; left:0; &#125;&#125; 将伪元素设置相对定位，并且和父元素的左上角对齐，将width设置100%，height设置为1px 然后进行再Y方向缩小0..5倍 4条border 12345678910111213141516.setBorderAll&#123; position:relative; &amp;::after&#123; content::\"\"; position:absolute; top:0; left:0; width:200%; height:200%; transform:scale(0.5); transform-origin:left top; border-sizing:border-box; border:1px solid #e5e5e5; border-radius:4px &#125;&#125; 同样为伪类设置相对定位，并且和父元素左上角对齐，将伪元素的长和宽先放大2倍，然后再设置一个边框，以左上角为中心，缩放到原来的0.5倍 总结：全机型兼容，实现了真正的1px而且可以圆角 缺点：暂用了after伪类，可能影响到清浮动 5.设置viewport 的scale值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;html&gt; &lt;head&gt; &lt;title&gt;1px question&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;meta name=\"viewport\" id=\"WebViewport\" content=\"initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"&gt; &lt;style&gt; html &#123; font-size: 1px; &#125; * &#123; padding: 0; margin: 0; &#125; .top_b &#123; border-bottom: 1px solid #E5E5E5; &#125; .a,.b &#123; box-sizing: border-box; margin-top: 1rem; padding: 1rem; font-size: 1.4rem; &#125; .a &#123; width: 100%; &#125; .b &#123; background: #f5f5f5; width: 100%; &#125; &lt;/style&gt; &lt;script&gt; var viewport = document.querySelector(\"meta[name=viewport]\"); //下面是根据设备像素设置viewport if (window.devicePixelRatio == 1) &#123; viewport.setAttribute('content', 'width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no'); &#125; if (window.devicePixelRatio == 2) &#123; viewport.setAttribute('content', 'width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no'); &#125; if (window.devicePixelRatio == 3) &#123; viewport.setAttribute('content', 'width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no'); &#125; var docEl = document.documentElement; var fontsize = 32* (docEl.clientWidth / 750) + 'px'; docEl.style.fontSize = fontsize; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"top_b a\"&gt;下面的底边宽度是虚拟1像素的&lt;/div&gt; &lt;div class=\"b\"&gt;上面的边框宽度是虚拟1像素的&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 总结 优点：全机型兼容，直接写1px不能喝再方便 缺点：使用新的项目，老项目可能改动大 16. 介绍一下flex布局采用flex布局的元素，成为flex容器，简称“容器”，它的所有子元素自动成为容器成员 当使用flex布局时，会存在两根线即主轴(默认水平)，交叉轴(默认垂直)，默认是主轴排列 容器的属性 flex-direction（决定主轴方向） flex-wrap (决定换行形式） justify-content(定义在周周的对齐方式) align-litems(定义在交叉轴的对齐方式) aligin-content(定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用)","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://blog.liurugang.cn/tags/%E6%80%BB%E7%BB%93/"},{"name":"面试","slug":"面试","permalink":"http://blog.liurugang.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"彻底弄懂JavaScript执行机制","slug":"彻底弄懂JavaScript执行机制","date":"2021-01-31T07:50:42.660Z","updated":"2021-01-31T07:51:37.343Z","comments":true,"path":"posts/46815/","link":"","permalink":"http://blog.liurugang.cn/posts/46815/","excerpt":"","text":"彻底弄懂JavaScript执行机制JavaScript事件循环既然JS是单线程，那就像只有一个窗口的银行，客户需要排队一个个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假设我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面股价和页面元素的渲染。而向加载图片音乐之类占用资源大耗时长的任务，就是异步任务。用导图来说明 导图要表达的内容用文字来表述的话： 同步和异步任务分别进入不同的执行“场所”，同步的进入主线程，异步的进入Event Table 并注册函数 当指定的事情完成时，Event Table会将这个任务移除Event Queue 主任务内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主流程执行 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 说了这么多文字，不如直接一段代码更直白： 123456789let data =[];$.ajax(&#123; url:www.javascript.com, data:data, success:()=&gt;&#123; console.log('发送成功!') &#125;&#125;)console.log('代码执行结束') 上面是一段简单的ajax请求代码: ajax进入Event Table,注册回调函数success 执行console.log(&#39;代码执行结束&#39;) ajax事件完成，回调函数success进入Event Queue 主线程从Event Queue去读回调函数success并执行 setTimeoutsetTimeout大家对他的第一印象就是异步可以执行演示执行，我们经常这么实时延迟3秒执行： 123setTimeout(()=&gt;&#123; console.log('延时3秒')&#125;，3000) 渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3毛，实际却5,6秒才执行函数 先看一下例子： 1234setTimeout(()=&gt;&#123; tesk()&#125;,3000)conosole.log('执行console') 根据前面的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是: 12//执行console//task() 去验证一下，结果正确！然后我们修改一下前面的代码： 123456setTimeout(()=&gt;&#123; setTimeout(()=&gt;&#123; tesk() &#125;,3000)&#125;)sleep(100000) 乍一看其实差不多，但是我们把这段代码在chrome执行一下，却发现控制台执行tesk()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这个长时间呢？ 这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： tesk()进入Event Table并注册计时开始 执行sleep函数，很慢，即使仍在继续 3秒到了，计时事件timeout完成，tesk()进入Event Queue，但是sleep很慢，还没有执行完，只好等着 sleep终于执行完了，tesk()终于从Event Queue 进入了主线程执行 我们还经常遇到setTimeout(fn,0)这样的代码，0秒执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程是最早可得的空闲时间执行，意思是不用等多少秒，只要主线程执行栈内同步任务全部执行完成，栈为空马上执行。举例说明： 12345//代码1console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,0); 12345//代码2console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,3000); 代码1的输出结果是： 12//先执行这里//执行啦 代码2的输出结果是： 123//先执行这里//...3s later//执行啦 setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。 唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。 Promise与process.nextTick(callback)传统的定时器我们已经研究过了，接着我们探究Promise与Process.nextTick(callback)的表现。 除了广义的同步任务和异步任务，我们对任务更精细的定义： macro-task(宏任务)：包括整体代码script，setInterval，setTimemout，setImmediate micro-tesk(微任务): Promise, process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval进入相同的Event Queue 事件循环的顺序，决定JS代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕后，再次执行所有的微任务。我们用文章最开始的一段代码说明: 12345678910setTimeout(function()&#123; console.log('setTimeout')&#125;)new Promise(function(reslove)&#123; console.log('promise')&#125;).then(function()&#123; console.log('then')&#125;)console.log('console') 这段代码作为宏任务，进入主线程 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue. 接下来来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue 遇到console.log()立即执行。 好啦。整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 Ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue 开始。我们发现饿了宏任务 Event Queue中setTimeout对应的回调函数，立即执行 结束 事件循环，宏任务，微任务的关系如图所示 我们来分析一段较为复杂的代码，看看你是否真的掌握了JS的执行机制： 12345678910111213141516171819202122232425262728293031323334353637console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;)//1 7 6 8 2 4 3 5 9 11 10 12 第一轮事件循环流程分析如下: 整体script作为第一个宏任务进入主流程，遇到console.log，输出1 遇到setTimeout，器回调函数被分发到宏任务Event Queue 中。我们暂且记为setTimeout1 遇到Process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为Process1 遇到Promise，new Promise直接执行，输出7，then被分发到微任务Event Queue中。我们记为then1 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2 宏任务 微任务 setTimout1 process1 setTimeout2 then1 上表示第一轮事件宏任务结束时各Event Queue的情况，此时已经输出了1,7 我们发现了process1和then1两个微任务 执行process1，输出6 执行then,输出8 好了，第一轮事件循环正式结束，这一轮的结果是输出1,7,6,8。那么第二轮时间循环从setTimeout1宏任务开始 首先输出2，接下来遇到了process.nextTick()同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2. 宏任务 微任务 setTimeout2 process2 then2 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3 输出5 第二轮事件循环结束，第二轮输出2,4,3,5 第三轮事件循环开始，此时只剩setTimeout2了，执行 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 宏任务 微任务 process3 then3 第三轮事件循环宏任务执行结束，执行两个宏任务process3和then3 输出10 输出12 第三轮事件循环结束，第三轮输出9,11,10,12 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12 总结（1）js的异步 我们从最开头就说JavaScript是一门单线程语言，不管是什么新框架新语法糖实现饿的所谓异步，其实都是用同步的方法去模拟的，牢牢把握单线程这点非常重要。 （2）事件循环 Event Loop 事件循环是JS实现异步的一种方式，也是js的执行机制 （3）JavaScript的执行和运行 执行和运行有很大的区别，JavaScript在不同的环境下，比如node，浏览器等执行的方式是不同的。而运行大多指JavaScript解析引擎，是统一的。 （4）最后的最后 javascript是一门单线程语言 Event Loop是JavaScript的执行机制","categories":[],"tags":[]},{"title":"前端安全问题","slug":"前端安全问题","date":"2021-01-31T02:05:56.049Z","updated":"2021-01-31T02:07:14.338Z","comments":true,"path":"posts/5950/","link":"","permalink":"http://blog.liurugang.cn/posts/5950/","excerpt":"","text":"前端安全问题XSS(跨站脚本攻击)XSS 即跨站脚本攻击，是通过攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或获取用户隐私数据的一种攻击方式。 攻击者对客户端网页注入的恶意脚本一般包括JavaScript，有时也会包含HTML和Flash。有多种方式，但他们的共同点为：将一些隐私数据像cookie，session发送给攻击者，将受害者重定向到一个攻击者控制的网站，在受害者的机器上进行一些恶意操作。 XSS攻击可以分为3类：反射型(非持久型)，存储型(持久性)，基于DOM 反射型反射性xss只是简单地把用户输入的数据“反射”给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意连接(攻击者可以将恶意连接发送给受信任用户，比如将恶意连接插入广告的链接中)，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。最简单的示例是访问一个链接，服务端返回一个可执行的脚本 1234567891011const http = require('http');function handleReequest(req, res) &#123; res.setHeader('Access-Control-Allow-Origin', '*'); res.writeHead(200, &#123;'Content-Type': 'text/html; charset=UTF-8'&#125;); res.write('&lt;script&gt;alert(\"反射型 XSS 攻击\")&lt;/script&gt;'); res.end();&#125;const server = new http.Server();server.listen(8001, '127.0.0.1');server.on('request', handleReequest); 存储型存储型XSS会把用户输入的数据“存储”在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种XSS具有很强的稳定性。比较常见的一个场景是攻击者在社区或论坛上写一篇包含恶意JavaScript代码的文章或者评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码 123// 例如在评论中输入以下留言// 如果请求这段留言的时候服务端不做转义处理，请求之后页面会执行这段恶意代码&lt;script&gt;alert('xss 攻击')&lt;/script&gt; 基于DOM基于DOM的XSS攻击是指通过恶意脚本修改页面的DOM结构，是纯粹发生在客户端的攻击 12345678910111213141516171819&lt;h2&gt;XSS: &lt;/h2&gt;&lt;input type=\"text\" id=\"input\"&gt;&lt;button id=\"btn\"&gt;Submit&lt;/button&gt;&lt;div id=\"div\"&gt;&lt;/div&gt;&lt;script&gt; const input = document.getElementById('input'); const btn = document.getElementById('btn'); const div = document.getElementById('div'); let val; input.addEventListener('change', (e) =&gt; &#123; val = e.target.value; &#125;, false); btn.addEventListener('click', () =&gt; &#123; div.innerHTML = `&lt;a href=$&#123;val&#125;&gt;testLink&lt;/a&gt;` &#125;, false);&lt;/script&gt; 点击Submit按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入构造了如下内容： 1onclick=alert(/xss/) 用户提交之后，页面代码就变成了 1&lt;a href onclick=\"alert(/xss/)\"&gt;testLink&lt;/a&gt; XSS攻击防范HTTPOnly防止劫取Cookie：HTTPOnly浏览器将禁止页面的JavaScript访问带有HTTPOnly属性的Cookie。攻击者可以通过注入恶意脚本获取用户的Cookie信息。通常Cookie中都包含了用户的登录凭证信息，攻击者在获取到Cookie之后，则可以发起Cookie劫持攻击。HTTPOnly并非阻止XSS攻击，而是能阻止XSS攻击后的Cookie劫持攻击。 输入检查：不要相信用户的任何输入。对于用户的任何输入要进行检查，过滤和转义。建立可信任的字符和HTML标签白名单。对于特殊字符进行过滤或转码 输出检查：服务端的输入也会存在问题，一般来说，出富文本的输出外，在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。 CSRF(跨站请求伪造)CSRF即跨站请求伪造，是一种劫持受信任的用户向服务器发送非舆情请求的攻击方式。通常情况下，CSRF攻击是攻击者借助受害者的Cookie骗取服务器的信任，可以在受害者毫不知情的情况下以受害者的名义伪造请求发送给攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。 CSRF攻击使登录用户访问攻击者的网站，发起一个请求，由于Cookie中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起CSRF攻击。 在这个攻击过程中，攻击者借助受害者的Cookie骗取服务端的信任，单兵不能拿到Cookie，也不能看到Cookie的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。 但是攻击者无法从返回的结果中得到任何东西，它所能做到的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。例如删除数据，修改数据等 CSRF攻击防范验证码： 验证码被认为是对抗CSRF攻击最简洁有效的防御方法，CSRF攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能很好的遏制CSRF攻击 添加Token验证：要抵御CSRF，关键在于请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。可以在HTTP请求中以参数的形式添加一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或token内容不正确，则认为可能是CSRF攻击而拒绝请求。","categories":[],"tags":[]},{"title":"Nuxt.js爬坑","slug":"Nuxt.js爬坑","date":"2021-01-30T14:47:22.799Z","updated":"2021-01-30T14:48:01.054Z","comments":true,"path":"posts/25/","link":"","permalink":"http://blog.liurugang.cn/posts/25/","excerpt":"","text":"Nuxt.js爬坑1. NuxtServerError connect ECONNREFUSED 127.0.0.1:80原因：asyncData方法异步请求数据时，以为/api/${params.id}这个接口的网站是127.0.0.1:80，所以请求发送给了127.0.0.1:80，而我的接口服务器并没有跑在80端口上，所以报错 解决方案： 将node服务器端口改为127.0.0.1:80 将接口服务器端口改成 127.0.0.1:80 将asyncData方法请求的url加上域名+端口，如下所示 1234567export default&#123; asyncData(&#123;params&#125;&#123; returm axios.get(`https://127.0.0.1:3000/api/$&#123;params.id&#125;`) .then((res)=&gt;&#123; return &#123;title:res.data.title&#125; &#125;) &#125;)&#125; 2.nuxt使用less，sass等预处理器 背景：在组件中&lt;template&gt;，&lt;script&gt;或&lt;style&gt;上使用各种预处理器，加上处理器后，控制台报错 1npm install --save-dev node-sass sass-loader 但是解决过程并不是很顺利，在阅读中文文档时，忽略版本号，按照上面的提示进行操作，发现不能成功，后来各种debug，最后发现了该解决方案，后知后觉的发现了中文文档，如果需要查看文档，一定要看最新版本的英文文档 3. 如何使用px2rem 背景：在css中，写入px，通过px2rem loader将px转成rem 在以前的项目中，是通过px2rem loader实现的，但是在Nuxt.js项目下，添加css loader还是很费力的，因为涉及到vue-loader 想到了一个其他方案，可以使用postcss处理。可以在nuxt.config.js文件中添加配置，也可以在postcss.conf.js文件中添加。 1234567build:&#123; postcss:[ require('postcss-px2rem')(&#123; remUnit:75 //转换基本单位 &#125;) ]&#125; 4. 如何扩展webpack配置 背景：给utils目录添加别名 刚刚说到，Nuxt.js内置了webpack配置，如果想要扩展配置，可以在nuxt.config.js文件中添加。同时也可以在该文件中，将配置信息打印出来。 123456789extend(config,ctx)&#123; console.log('webpack config',config) if(ctx.isClient)&#123; //添加alias配置 Object.assign(config.resolve.alias,&#123; 'utils'：path.resolve(__dirname,'utils') &#125;) &#125;&#125; 5. 如何添加vue plugin 背景：自己封装了一个toast vue plugin,由于vue实例化的过程没有暴露出来，不知道在哪个时机注入进去 可以在nuxt.config.js中添加plugins配置，这样插件就会在Nuxt.js应用初始化之前被加载导入 123mudule.exports=&#123; plugins:['~plugins/toast']&#125; ~plugins/toast.js文件 12345import Vue from 'vue'import toast from '../utils/toast'import '..assets/css/toast.css'Vue.use(toast) 6. 如何修改环境变量NODE_ENV 背景：在项目中，设置3个NODE_ENV的值，来对应不同的版本。development，本地开发；release,预发布版本；production，线上版本。其中，预发布版本比production版本，多出，vconsole 12345//package.json\"script\":&#123; \"buildDev\"：\"cross-env NODE_ENV=release nuxt build &amp;&amp; backpack build\", \"startDev\": \"cross-env NODE_ENV=release PORT=3000 node build/main.js\"&#125; 打印process.env.NODE_ENV依旧是，production. 在backpack的源码中，找到了答案，在执行backpack build命令是会把process.env.NODE_ENV修改为production，并且是写死的不可配置的.. 无奈之下，只能在process.env下，添加__ENV属性，代表NODE_ENV 这时，在页面中打印出来的信息process.env.ENV undefined，但是可以打印出来process.env.NODE_ENV 可以通过配置nuxt.config.js中的env属性，解决该问题 123env:&#123; __ENV:process.env.__ENV&#125; 7. window或document对象未定义？ 背景：在引入第三方插件，或者直接在代码中写window时，控制台会发出警告，window为定义 发生这个问题的原因时，node服务端并没有window或document对象。解决方法，通过process.browser来区分环境 123456if(process.browser)&#123; //引入第三方插件 require('!***') //或者修改window对象下的某一属性 window.mdk=&#123;&#125;&#125; 8. nuxt必须在接口地址前加上访问域名解决：可以使用axios的baseURL来代理 123456import Vue from 'vue'import axios from 'axios'axios.defaults.baseURL =\"http://localhost:3000/\"export default axios 9. 不想服务端渲染的地方12345678(1)&lt;no-ssr&gt;插件或组件&lt;&#x2F;no-ssr&gt;（2）nuxt.config.js里ssr该成falseplugins:[ &#123;src:&#39;~plugins&#x2F;ElementUI&#39;，ssr:false&#125;] 10. 按需引入(UI框架等等)例如使用UI框架：element-ui 先看下，如果不按需引入vendor.js的体积大小为： 第一步，下载依赖 1234//先下载element—uinpm install element-ui --save//如果使用按需引入，必须安装babel-plugin-componentnpm install babel-plugin-component --save-dev 安装好以后，按照nuxt.js中的规则，你需要在plugins/目录下创建相关插件文件 在文件根目录创建plugins/目录，创建名为element-ui.js的文件，内容如下 12345import Vue from 'vue'import &#123;Button&#125; from 'element-ui'export default （）=&gt;&#123; Vue.use(Button)&#125; 第二步，引入插件 在nuxt-config.js中添加配置为：plugins 123456789css:[ 'element-ui/lib/theme-chalk/index.css'], plugins:[ &#123; src:'~/plugins/element-ui', ssr:false //关闭ssr &#125; ] 第三步，配置babel选项 在nuxt.config.js中，配置在build选项中，规则为官网规则： 123456789101112131415161718192021222324build:&#123; babel:&#123; \"plugins\":[ [ \"component\", &#123; \"librayName\":\"element-ui\", \"styleLibrayName\"：\"theme-chalk\" &#125; ] ] &#125;&#125;, extend (config, ctx) &#123; if (ctx.isClient) &#123; config.module.rules.push(&#123; enforce: 'pre', test: /\\.(js|vue)$/, loader: 'eslint-loader', exclude: /(node_modules)/ &#125;) &#125; &#125; &#125; 此时，我们再观察打包以后文件体积大小，如图： 此时，我们成功完成了按需引入配置","categories":[],"tags":[]},{"title":"Nuxt.js介绍","slug":"Nuxt.js介绍","date":"2021-01-30T13:33:47.604Z","updated":"2021-01-30T14:48:01.058Z","comments":true,"path":"posts/60077/","link":"","permalink":"http://blog.liurugang.cn/posts/60077/","excerpt":"","text":"Nuxt爬坑第一节：nuxt.js相关概述nuxt.js简单的说是Vue.js的通用框架，最常用的就是用来做SSR(服务端渲染)，Vue.js是开发SPA(单页应用)的，Nuxt.js这个框架，用Vue开发多页应用，并在服务端完成渲染，可以直接用命令把我们制作的vue项目生成为静态html 1. 那服务器端渲染到底有什么好处？主要的原因是SPA(单页应用)不利于搜素引擎的SEO操作，Nuxt.js适合做新闻，博客，电影，资讯这样的需要搜索引擎提供流量的项目。如果你要做移动端的项目，就没必要使用这个框架了。 2. 什么是SSR?在认识SSR之间，首先对CSR与SSR之间做个对比、 首先看一下传统的web开发，传统的web开发是，客户端向服务端发送请求，服务端查询数据库，拼接HTML字符串(模板)，通过一系列的数据处理之后，把整理好的HTML返回给客户端，浏览器相当于打开了一个页面，这种比如我们经常听说过的jsp，PHP,aspx也是传统的MVC的开发。 SPA应用，到了Vue，React，单页应用优秀的用户体验，逐渐成为了主流，页面整体式javascript渲染出来的，称之为客户端渲染CSR。SPA渲染过程。由客户端访问URL发送请求到服务端，返回HTML结构。客户端接收到了返回结果之后，在客户端开始渲染HTML，渲染时执行对应javascript最后渲染template，渲染完成之后，再次向服务端发送数据请求，注意这里时数据请求，服务端返回json格式数据。客户端接收数据，然后完成最后渲染。 SPA虽然给服务器减轻了压力，但是也是有缺点的： 首屏渲染时间比较长；必须等待javascript加载完毕，并且执行完毕，才能渲染出首屏。 SEO不友好：爬虫只能拿到一个div元素，认为页面是空的，不利用SEO 为了解决如下两个问题，出现了SSR解决方案，后端渲染出首屏的DOM结构返回，前端首先拿到内容带上首屏，后续的页面操作，再用单页路由和渲染，称之为服务端渲染（SSR）。 SSR渲染流程时这样的，客户端发送URL请求到服务端，服务端读取对应的URL的模板信息，在服务端做出html和数据的渲染，渲染完成之后返回html结构，客户端这是拿到的之后首屏页面的html结构。所以用户在浏览器首屏的时候速度会很快，因为客户端不需要再次发送ajax请求。并不是做了SSR我们的页面就不属于SPA应用了，它仍然是一个独立的SPA应用。 SSR是处于CSR与SPA应用之间的一个折中的方案，在渲染首屏的时候再服务端做出了渲染，注意仅仅是首屏，其他页面还是需要在客户端渲染的，在服务端接收请求之后并且渲染出首屏页面，会携带着剩余的路由信息预留给客户端去渲染其他路由的页面。 Nuxt.js的特点(优点)： 基于Vue 自动代码分层 服务端渲染 强大的路由功能，支持异步数据 静态文件服务 ECMAScript6和ECMAScript7的语法支持 打包和压缩javascript和css HTML头部标签管理 本地开发支持热加载 集成ESLint 支持各种样式预编译器SASS,LESS等等 支持HTTP/2推送 第二节：Nuxt环境搭建1. Nuxt.js安装在使用npm前你需要先安装Node到系统中 （1） 用npm来安装vue-cli这个框架 1npm install vue-cli -g 安装完成后使用vue -V 来测试是否安装成功。 （2）使用vue安装nuxt安装好vue-cli后，就可以使用init命令来初始化Nuxt.js项目 1vue init nuxt/starter (3) 使用npm install来安装依赖包 1npm install 这个过程是要等一会的，如果你这个安装失败，可以直接删除项目中的node_modules文件夹后，重新npm install进行安装 （4）使用npm run dev启动服务 （5）在浏览器输入localhost:3000，可以看到结果如下： 2. 第一个Nuxt应用程序安装1234npm i create-nuxt-app -gcreate-nuxt-app my-nuxt-democd my-nuxt-demonpm run dev 安装向导 123456789Project name // 项目名称Project description // 项目描述Use a custom server framework // 选择服务器框架Choose features to install // 选择安装的特性Use a custom UI framework // 选择UI框架Use a custom test framework // 测试框架Choose rendering mode // 渲染模式Universal // 渲染所有连接页面Single Page App // 只渲染当前页面 3. Nuxt渲染流程一个完整的服务器请求到渲染的流程 通过上面的流程图可以看出，当一个客户端请求进入的时候，服务端有通过nuxtServerInit这个命令在Store的action中，在这里接收到客户端请求的时候，可以将一些客户端信息存储到Store中，也就是说可以把服务端存储的一些客户端的一些登录信息存储到Store中。之后使用了中间件机制，中间件其实就是一个函数，会在每个路由执行之前去执行，在这里可以做很多事情，或者说可以理解为是路由器的拦截器的作用。然后再validate执行的时候对客户端携带的参数进行效验，在asyncData与fetch进入正式的渲染周期，asyncData向服务端获取数据，把请求到的数据合并到Vue中的data中 第三节：Nuxt目录结构目录结构介绍123456789101112131415161718└─my-nuxt-demo ├─.nuxt // Nuxt自动生成，临时的用于编辑的文件，build ├─assets // 用于组织未编译的静态资源如LESS、SASS或JavaScript,对于不需要通过 Webpack 处理的静态资源文件，可以放置在 static 目录中 ├─components // 用于自己编写的Vue组件，比如日历组件、分页组件 ├─layouts // 布局目录，用于组织应用的布局组件，不可更改⭐ ├─middleware // 用于存放中间件 ├─node_modules ├─pages // 用于组织应用的路由及视图,Nuxt.js根据该目录结构自动生成对应的路由配置，文件名不可更改⭐ ├─plugins // 用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。 ├─static // 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。 服务器启动的时候，该目录下的文件会映射至应用的根路径 / 下。文件夹名不可更改。⭐ └─store // 用于组织应用的Vuex 状态管理。文件夹名不可更改。⭐ ├─.editorconfig // 开发工具格式配置 ├─.eslintrc.js // ESLint的配置文件，用于检查代码格式 ├─.gitignore // 配置git忽略文件 ├─nuxt.config.js // 用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。文件名不可更改。⭐ ├─package-lock.json // npm自动生成，用于帮助package的统一设置的，yarn也有相同的操作 ├─package.json // npm 包管理配置文件 ├─README.md 配置文件12345678910111213141516171819202122232425262728293031const pkg = require('./package')module.exports = &#123; mode: 'universal', // 当前渲染使用模式 head: &#123; // 页面head配置信息 title: pkg.name, // title meta: [ // meat &#123; charset: 'utf-8' &#125;, &#123; name: 'viewport', content: 'width=device-width, initial-scale=1' &#125;, &#123; hid: 'description', name: 'description', content: pkg.description &#125; ], link: [ // favicon，若引用css不会进行打包处理 &#123; rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' &#125; ] &#125;, loading: &#123; color: '#fff' &#125;, // 页面进度条 css: [ // 全局css（会进行webpack打包处理） 'element-ui/lib/theme-chalk/index.css' ], plugins: [ // 插件 '@/plugins/element-ui' ], modules: [ // 模块 '@nuxtjs/axios', ], axios: &#123;&#125;, build: &#123; // 打包 transpile: [/^element-ui/], extend(config, ctx) &#123; // webpack自定义配置 &#125; &#125;&#125; Nuxt运行命令123456789101112&#123; \"scripts\": &#123; // 开发环境 \"dev\": \"cross-env NODE_ENV=development nodemon server/index.js --watch server\", // 打包 \"build\": \"nuxt build\", // 在服务端运行 \"start\": \"cross-env NODE_ENV=production node server/index.js\", // 生成静态页面 \"generate\": \"nuxt generate\" &#125;&#125; 第四节： Nuxt常用配置项1. 配置IP和端口开发中经常会遇到端口占用或指定IP的情况，我们需要在根目录下的package.json里对config项进行配置。比如现在我们想把IP配置成127.0.0.1，端口设置1000 123456\"config\":&#123; \"nuxt\":&#123; \"host\":'127.0.0.1', \"port\":\"1000\" &#125;&#125; 配置好后，我们在终端输入npm run dev，然后你就会看到服务地址改为了127.0.0.1:1000 2. 配置全局CSS在开发多页项目时，都会定义一个全局的CSS来初始化我们的页面渲染，比如把padding和margin设置成0，网上有非常出名的开源css文件normalize.css。要定义这些配置，需要在nuxt.config.js里进行操作。 比如现在我们要把页面字体设置为红色，就可以在assets/css/common.css文件，然后把字体设置为红色。 /assets/css/common.css 123html&#123; color:red&#125; /nuxt.config.js 1css:['~assets/css/normalize.css'] 设置好后，在终端输入npm run dev然后你会发现字体已经变成了红色 3. 配置webpack的loader在nuxt.config.js里可以对webpack的基本配置进行覆盖的，比如现在我们要配置衣蛾url-loader进行小图片的64位打包。就可以在nuxt.config.js的build选项里进行配置， 12345678910111213141516171819202122232425build: &#123; loaders:[ &#123; test:/\\.(png|jpe?g|gif|svg)$/, loader:\"url-loader\", query:&#123; limit:10000, name:'img/[name].[hash].[ext]' &#125; &#125; ], /* ** Run ESLint on save */ extend (config, &#123; isDev, isClient &#125;) &#123; if (isDev &amp;&amp; isClient) &#123; config.module.rules.push(&#123; enforce: 'pre', test: /\\.(js|vue)$/, loader: 'eslint-loader', exclude: /(node_modules)/ &#125;) &#125; &#125; &#125; 4. 全局修改seo的head信息nuxt.config文件中，修改title为wfaceboss： 1234567891011head&#123; title: 'wfaceboss', meta: [ &#123; charset: 'utf-8' &#125;, &#123; name: 'viewport', content: 'width=device-width, initial-scale=1' &#125;, &#123; hid: 'description', name: 'description', content: 'Nuxt.js project' &#125; ], link: [ &#123; rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' &#125; ]&#125; 修改后重启服务，即运行npm run dev交过如下 第五节： Nuxt的路由配置和参数传递Nuxt.js的路由并不复杂，它给我们进行了封装，让我们节省了很多配置环节 1. 基本路由Nuxt.js依据pages目录结构自动生成vue-router模块的路由配置 假设pages的目录如下 12345└─pages ├─index.vue └─user ├─index.vue ├─one.vue 那么，Nuxt.js自动生成的路由配置如下： 123456789101112131415161718router:&#123; routes:[ &#123; name:'index', path:'/', component:'pages/index.vue' &#125;, &#123; name:'user', path:'/user', component:'pages/user/index.vue' &#125;,&#123; name:'user-one', path：'/user/one', component：'pages/user/one.vue' &#125; ]&#125; 2. 页面跳转 不要写成a标签，因为是重新获取一个新的页面，并不是SPA &lt;nuxt-link to=&quot;/users&quot;&gt;&lt;/nuxt-link&gt; this.$router.push(&#39;/users&#39;) 3.动态路由 在Nuxt.js里面定义带参数的动态路由，需要创建对应的以下划线作为前缀的Vue文件或目录 获取动态参数 4. 跳转路由传递参数并且取值路由进化出那个需要传递参数，我们可以简单的使用params来进行传递参数，我们现在向新闻页面(news)传递个参数，然后在新闻页面进行简单的接收 (1 ) 使用nuxt传递参数 1234567&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;nuxt-link to&#x3D;&quot;&#96;informa&#x2F;$&#123;item.newsCode&#125;-$&#123;item.newType&#125;&#96;&quot;&gt;&lt;&#x2F;nuxt-link&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 注意：name其实指向的是路由，而路由区分大小写，所有to后面区分大小写，建议文件夹都写成小写 （2） 使用nuxt接收参数 1234async asyncData(context)&#123; let newsCode =context.route.params.code.split('-')[0] let newsType = context.route.parmas.code.split('-')[1]&#125; (3) 使用this.$router.push的params传递参数 传递参数： 1this.$router.push(&#123;path:'路由',query:&#123;key:value&#125;&#125;) 参数取值 1this.$router.query.key 5. 路由参数校验nuxt.js可以让你在动态路由对应的页面组件中配置一个validate方法用于效验动态路由参数的有效性。该函数有一个布尔类型的返回值，如果返回true则表示效验通过，如果返回false则表示效验未通过 12345export default&#123; validate(obj)&#123; return /^\\d+$/.test(obj.params.id) &#125;&#125; 6. 嵌套路由 添加一个Vue文件作为父组件 添加一个与父组件同名的文件夹存放子视图组件 在父文件中，添加组件，用于展示匹配到的子视图 第六节：Nuxt的路由动画效果路由的动画效果，也叫做页面的更换效果。Nuxt.js提供两种方法为路由提供动画效果，一种是全局的，一种是针对单独页面制作。 1. 全局路由动画全局动画默认使用page来进行设置，例如现在我们为每个页面都设置一个进入和退出时的渐隐渐现的效果。我们可以现在根目录的assets/css下建立一个normalize.css文件 （1）添加样式文件 /assets/css/normalize.css 123456.page-enter-active, .page-leave-active&#123; transition: opacity 2s&#125;.pgae-enter, .page-leave-active&#123; opacity: 0&#125; (2) 文件配置 然后在nuxt.config.js里加入一个全局的css文件就可以了 1css:['assets/css/main.css'] 这时候在页面切换的时候就会有2秒钟的动画切换效果了，但是你会发现一些页面是没有效果的，这是因为你没有是&lt;nuxt-link&gt;组件来制作跳转连接，你需要进行更改 比如我们上节课做得动态路由新闻页，你就需要改成下面的连接 1&lt;li&gt;&lt;nuxt-link :to=\"&#123;name:'new-id',params:&#123;id:123&#125;&#125;\"&gt;&lt;/nuxt-link&gt;&lt;/li&gt; 改完之后你就可以看到动画效果了 2. 单独设置页面动效相给一个页面单独设置特殊的效果时，我们只要在css里改变默认的page，然后在页面组件的配置中加入transition字段即可。例如，我们想要给about页面加入一个字体放大然后缩小的效果，其他页面没有这个效果 (1) 在全局样式assets/main.css中添加以下内容 12345678.test-enter-active,.test-leave-active&#123; transition:all 2s; font-size:12px;&#125;.test-enter,.test-leave-active&#123; opacity:0; font-size:40px;&#125; (2) 然后在about/index.vue组件中设置 123export default&#123; transition:'test'&#125; 这时候就有了页面切换独特动效了 总结：在需要使用的页面导入即可。 第七节：Nuxt的默认模板和默认布局在开发应用时，经常会用到一些公用的元素，比如网页的标题是一样的，每个页面都是一模一样的标题。这时候我们有两种方法，第一种方法是作一个公用的组件出来，第二种方法是修改默认模板。这两种方法各有利弊，比如公用组件更叫灵活，但是每次都需要我们动手引入；模板比较方便，但是只能每个页面都引入。 1. 默认模板Nuxt为我们提供了超简单的默认模板定制方法，只要在根目录下创建一个app.html就可以实现了。现在我们希望每个页面的最上面都加入“学习nuxt.js”这几个字，我们就可以使用模板来完成 app.html中： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &#123;&#123;HEAD&#125;&#125; &lt;/head&gt; &lt;body&gt; &lt;p&gt;学习nuxt.js&lt;/p&gt; &#123;&#123;APP&#125;&#125; &lt;/body&gt;&lt;/html&gt; 这里的读取的是nuxt.config.js里的消息，就是我们写的apges文件夹下的主体页面了。需要注意的是HEAD和APP都需要大写，如果小写会报错的 注意：如果你建立了默认模板后，记得要重启服务器，否则显示不会成功；但是默认布局是不用重启服务器的。 2. 默认布局默认模板类似的功能还有默认布局，但是从名字上可以看出，默认布局主要针对对于页面的统一布局使用。它在位置根目录下的layouts/default.vue需要注意的是在默认布局里不要加入头部信息，知识关于&lt;template&gt;标签下的内容统一定制。 需求：我们在每个页面的最顶部放入“学习nuxt.js”这几个字，看一下在默认布局开的实现。 12345678&lt;template&gt; &lt;div&gt; &lt;p&gt; 学习nuxt.js &lt;/p&gt; &lt;nuxt&gt;&lt;/nuxt&gt; &lt;/div&gt;&lt;/template&gt; 这里的&lt;nuxt/&gt;就相当于我们每个页面的内容，你也可以把一些通过那个样式放在这个默认布局里，但这会增加页面的复杂程度。 总结：要区分默认模板和默认布局的区别,模板可以定制很多头部信息，包括IE版本的判断；模板只能定制&lt;template&gt;里的内容，根布局有关系。在工作中修改时要看情况来编写代码 第八节：Nuxt插件的使用1. ElementUI使用 下载npm i element-ui -S 在plugins文件夹下面创建ElementUI.js文件 123import Vue from 'vue'import ElementUI from 'element-ui'Vue.use(ElementUI) 在nuxt.config.js中添加配置 123456789css: [ 'element-ui/lib/theme-chalk/index.css'],plugins:[ &#123;src:'~/plugins/ElementUI',ssr:true&#125;], build:&#123; vendor:['element-ui'] &#125; 2. axios的使用 安装npm install --save axios 使用 123456789import axios from 'axios'asyncData(context,callback)&#123; axios.get('http://localhost:3301/in_theaters') .then(res=&gt;&#123; console.log(res) callback(null,&#123;list:res.data&#125;) &#125;)&#125; 为了防止重复打包，在nuxt.config.js中配置 12345module.exports =&#123; build:&#123; vendor:['axios'] &#125;&#125; 第九节： Nuxt的错误页面和个性meta设置当用户输入路由错误的时候，我们需要给他一个明确的指引，所以说在应用程序开发中404页面必不可少的，Nuxt.js支持在默认布局文件夹里建立错误页面 1. 建立错误页面在根目录的layouts文件夹下建立一个error.vue文件，它相当于一个显示应用错误的组件。 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h2 v-if&#x3D;&quot;error.statusCode&#x3D;&#x3D;404&quot;&gt;404页面不存在&lt;&#x2F;h2&gt; &lt;h2 v-else&gt;500服务器错误&lt;&#x2F;h2&gt; &lt;ul&gt; &lt;li&gt;&lt;nuxt-link to&#x3D;&quot;&#x2F;&quot;&gt;HOME&lt;&#x2F;nuxt-link&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props:[&#39;error&#39;],&#125;&lt;&#x2F;script&gt; 代码用v-if进行判断错误类型，需要注意的是这个错误时你需要在&lt;script&gt;里进行声明的，如果不声明程序是找不到err.statusCode的。 这里我也用一个&lt;nuxt-link&gt;的简单写法直接根上路径就可以了。 2. 个性meta设置页面的Meta对于SEO的设置非常重要，比如你现在要做个新闻页面，那为了搜索引擎对新闻的收录，需要每个页面对新闻都有不同的title和meta设置。直接使用head方法来设置头部信息就可以了。我们现在要把New-1这个页面设置成个性的meta和title 我们先把pages/news/index.vue页面的链接进行修改一下，传入一个title，目的是为了在新闻具体页面进行接收title，形成文章的标题。 /pages/news/index.vue 1&lt;li&gt;&lt;nuxt-link :to=\"&#123;name:'news-id',params:&#123;id:123,title:'nuxt.com'&#125;&#125;\"&gt;News-1&lt;/nuxt-link&gt;&lt;/li&gt; 第一步完成后，我们修改/pages/news/_id.vue，让它根据传递值编程独特的meta和title标签。 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt; &lt;h2&gt; News-Content [&#123;&#123;$route.params.id&#125;&#125;] &lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; validate(&#123;params&#125;)&#123; //必须是一个数字 return /^\\d+$/.test(params.id) &#125;， data()&#123; return&#123; title:this.$router.params.title &#125; &#125;, //独立设置head消息 head()&#123; return &#123; title:this.title, meta：[ &#123; hid:'description', name:'news', content:'This is news page' &#125; ] &#125; &#125; &#125;&lt;/script&gt; 注意：为了避免子组件中的meta标签不能正确覆盖父组件中相同的标签而产生重复的现象，建议利用hid键为meta标签配一个唯一的标示编号。 第十节：asyncData方法获取数据Nuxt.js贴心的为我们扩展了Vue.js的方法，增加了asyncData，异步请求数据 1. 造假数据（1）创建远程数据 在这里制作一些假的远程数据，我选择的网站是myjson.com。它是一个json的简单仓库，学习使用非常适合的。我们打开网站，在对话空中输入json代码。这个代码可以随意输入，key和value均采用字符串格式创建 12345&#123; \"name\":\"nuxt\", \"age\":18, \"interest\":\"I love coding!\" &#125; 输入后保存，网站会给你一个地址，这就是你这个json仓库的地址了. （2）安装Axios Vue.js官方推荐使用的远程数据方式就是Axios，所以我们安装官方推荐，来使用Axios。这里我们使用npm来安装axios。直接在终端中输入下面的命令 1npm install axios --save 2. asyncData的promise方法我们在pages下面新建一个文件，叫做asyncData.vue。然后写入下面的代码： 1234567891011121314151617&lt;script&gt;import axios from 'axios' export default&#123; data()&#123; return &#123; name:'hello world' &#125; &#125;, asyncData()&#123; return axios.get('https://api.myjson.com/bins/1ctwlm') .then((res)=&gt;&#123; console.log(res) return &#123;info:res.data&#125; &#125;) &#125; &#125;&lt;/script&gt; 这时候我们可以看到，浏览器中已经能输出结果了，asyncData的方法会把值返回到data中。是组件创建(页面渲染)之前的动作，所以不能使用this.info 一定要return出去获取到的对象，这样就可以在组件中使用，这里返回的数据会和组件中的data合并。这个函数不光在服务端会执行，在客户端同样也会执行。 3. asyncData的promise并发应用1234567891011121314151617181920212223242526async asyncData(context) &#123; let [newDetailRes, hotInformationRes, correlationRes] = await Promise.all([ axios.post('http://www.huanjingwuyou.com/eia/news/detail', &#123; newsCode: newsCode &#125;), axios.post('http://www.huanjingwuyou.com/eia/news/select', &#123; newsType: newsType, // 资讯类型： 3环评资讯 4环评知识 start: 0, // 从第0条开始 pageSize: 10, newsRecommend: true &#125;), axios.post('http://www.huanjingwuyou.com/eia/news/select', &#123; newsType: newsType, // 资讯类型： 3环评资讯 4环评知识 start: 0, // 从第0条开始 pageSize: 3, newsRecommend: false &#125;) ]) return &#123; newDetailList: newDetailRes.data.result, hotNewList: hotInformationRes.data.result.data, newsList: correlationRes.data.result.data, newsCode: newsCode, newsType: newsType &#125;&#125;, 4. asyncData的await方法现在都在用async…await来解决异步改写上面的代码 1234567891011121314&lt;script&gt;import axios from 'axios' export default&#123; data()&#123; return&#123; name:'hello world' &#125; &#125;, async asyncData()&#123; let &#123;data&#125; =await axios.get('https://api.myjson.com/bins/8gdmr') return &#123;info:data&#125; &#125; &#125;&lt;/script&gt; 5. 注意事项+生命周期 asyncData方法会在组件(限于页面组件)每次加载之前被调用 asyncData可以在服务端或路由更新之前被调用 第一个参数被设定为当前页面的上下文对象 Nuxt会将asyncData返回的数据融合到组件的data方法返回的数据一并返回给组件使用 对于asyncData方式是在组件实例化前被调用的，所以在方法内饰没办法通过this引用组件的实例对象 第十一节：静态资源和打包1. 静态资源123(1)静态引入图片在网上任意下载一个图片，放到项目中的static文件夹下面，然后可以使用下面的引入方法进行引用&lt;div&gt;&lt;img src&#x3D;&quot;~static&#x2F;logo.png&quot; &#x2F;&gt;&lt;&#x2F;div&gt; “~”就相当于定位到了项目根目录，这时候图片路径就不会出现错误，就算打包也是正常的。 12（2）CSS引入图片如果在CSS中引入图片，方法和html中直接引入是一样的，也是用“~”符号引入。 1234567&lt;style&gt; .diss&#123; width:300px; height:100px; background-image:url('~static/logo.png') &#125;&lt;/style&gt; 这时候在npm run deb下完全正常的 2. 打包用Nuxt.js制作完成后，你可以打包成静态文件并放在服务器上，进行运行。 在终端中输入： 1npm run generate 然后在dist文件夹下输入live-server基于可以了 总结：Nuxt.js框架非常简单，因为大部分的事情它都为我们做好了，我们只要安装它的规则来编写代码","categories":[],"tags":[]},{"title":"Vue面试题","slug":"Vue面试题","date":"2021-01-29T15:57:13.708Z","updated":"2021-01-29T16:32:01.055Z","comments":true,"path":"posts/719/","link":"","permalink":"http://blog.liurugang.cn/posts/719/","excerpt":"","text":"Vue面试题1. 说说你对SPA单页面的理解，它的优缺点分别是什么？SPA仅在Web页面初始化时加载相应的HTML，JavaScript和CSS。一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现HTML内容的变化，UI与用户的交互，避免页面的重新加载 优点： 用户体验好，快，内容的改变不需要重新加载整个页面，避免可不必要的跳转和重复渲染 SPA对服务器压力小 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理 缺点： 初次加载耗时多；为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript，css统一加载，部分页面按需加载 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理 SEO难度大；由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势 2. v-show 和v-if有什么区别v-if是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；如果在初始化渲染时条件为假，则什么都不做——-知道条件第一次变为真时，才会开始渲染条件块。 v-show就简单得多—–不管初始化条件是什么，元素总是会被渲染，并且只是简单地基于CSS的“display”属性进行切换 所以，v-if适用于运行时很少改变条件，不需要频繁切换条件的场景；v-show则适用于需要非常频繁切换条件的场景 3.class与style如何动态绑定class可以通过对象语法和数组语法进行动态绑定： 对象语法： 123456&lt;div v-bind：class&#x3D;”&#123;active:isActive,&#39;text-danger&#39;:hasError&#125;“&gt;&lt;&#x2F;div&gt;data:&#123; isActive:true, hasError:false&#125; 数组语法 123456&lt;div v-bind:class&#x3D;&quot;[isActive?activeClass:&#39;&#39;,errorClass]&quot;&gt;&lt;&#x2F;div&gt;data:&#123; activeClass:&#39;active&#39;, errorClass:&#39;text-danger&#39;&#125; style也可以通过语法和数组语法进行动态绑定 对象语法 123456&lt;div v-bind:style&#x3D;&quot;&#123;color:activeColor,fontSize:fontSize+&#39;px&#39;&#125;&quot;&gt; data:&#123; activeColor:&#39;red&#39;, fontSize:30 &#125; 数组语法 123456789&lt;div v-bind&#x3D;&quot;[styleColor,styleSize]&quot;&gt;&lt;&#x2F;div&gt;data:&#123; styleColor:&#123; color:&#39;red&#39; &#125;, styleSize:&#123; fontSize:&#39;23px&#39; &#125; &#125; 4. 怎样理解Vue的单向数据流所有的prop都使得其父子prop之间形成了一个单向下行绑定：父级prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父组件的状态，从而导致你的应用的数据流向难以理解。 每次父级组件发生更新时，子组件中所有的prop都会刷新为最新的值，这意味着你不应该在一个子组件内部改变prop。如果你这样做了，Vue会在浏览器的控制台中发生警告。子组件想修改时，只能通过$emit派发一个自定义事件，父组件接收到后，有父组件修改。 有两种常见的视图改变一个prop的情景 这个prop用来传递一个初始值；这个子组件接下来希望将作为一个本地饿的prop数据来使用。在这种情况下，最好定义一个本地的data属性，并将这个prop用作其初始化值： 12345props:['initialCounter'],data:function()&#123; counter: this.initialCounter &#125;&#125; 这个prop以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个prop的值来定义一个计算属性 123456prop:['size'],computed:&#123; normalizedSize:function()&#123; return this.size.trim().toLowerCase() &#125;&#125; 5. computed和watch的区别和运用场景computed：是计算属性，依赖其他属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值 watch:更多的是观察的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作： 运用场景： 当我们需要进行数值计算，并且依赖于其他数据时，应该使用computed，因为可以利用computed的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，这些都是计算属性无法做到的 6. 直接给一个数组项赋值，Vue能检测到变化吗？由于JavaScript的限制，Vue不能检测到一下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem]=newValue 当你修改数组的长度时，例如:vm.items.length=newLength 为了解决第一个问题，Vue提供了以下操作方法： 12345Vue.set(vm.items,indexOfItem,newValue)Vue.$set(vm.items,indexOfItem,newValue)vm.items.splice(indexOfItem,newValue) 为了解决第二个问题，Vue提供了以下操作方法： 1vm.items.splice(newLength) 7. 谈谈你对Vue生命周期的理解 生命周期 Vue实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模板，挂载DOM，渲染，更新 —&gt;渲染，卸载等一系列过程，我们称这是Vue的生命周期。 各个生命周期的作用 beforeCreate 组件实例被创建之初，组件的属性生效之前 created 组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用 beforeMount 在挂载开始之前被调用；相关的render函数首次被调用 mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子 beforeUpdate 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前 update 组件数据更新之后 activited keep-alive 专属，组件被激活时调用 deactivated keep-alive 专属，组件被销毁时调用 beforeDestory 组件销毁前调用 destoryed 组件销毁后调用 8. Vue的父组件和子组件生命周期钩子函数执行顺序Vue的父组件和子组件生命周期钩子函数执行顺序可以归为4个部分 加载渲染过程 父beforeCreate –&gt;父created –&gt;父beforeMount -&gt;子beforeCreate –&gt;子 created —&gt;子beforeMount –&gt;子mounted –&gt;父 mounted 子组件更新过程 ​ 父beforeUpdate –&gt; 子beforeUpdate –&gt;子updated —&gt;父updated 销毁过程 ​ 父beforeDestory —&gt;子beforeDestory —&gt;子destoryed –&gt;父destoryed 9. 在哪个生命周期内调用异步请求？可以在钩子函数created，beforeMounted，mounted中进行调用，因为这三个钩子中data已经被创建，可以将服务端返回的数据进行赋值，但是本人推荐在created钩子中调用异步请求，因为在created钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面loading时间 ssr不支持beforeMount，mounted钩子函数，所以放在created有助于一致性 10. 在什么阶段才能访问操作DOM在钩子函数mounted被调用前，Vue已经将编译好的模板挂载到页面上，所以在mounted中可以访问操作DOM。Vue具体的生命周期可以参考下图 11. 父组件可以监听到子组件的生命周期吗？比如有父组件Parent和子组件Child，如过父组件监听到子组件挂载mounted就做一些逻辑处理，可以通过以下写法实现： 1234567//parent.vue&lt;child @mounted=\"dosomething\"&gt; //child vuemounted()&#123; this.$emit(\"mounted\");&#125; 以上需要手动通过$emit触发父组件的事件，更简单的方式可以在父组件引用子组件时通过@hook来监听即可，如下所示： 1234567891011&#x2F;&#x2F;parent.vue&lt;Child @hook:mounted&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;child&gt;doSomething()&#123; console.log(&#39;父组件监听mounted钩子函数...&#39;)&#125;&#x2F;&#x2F;child.vuemounted()&#123; console.log(&#96;子组件触发mounted钩子函数...&#96;)&#125; 当然@hook方法不仅仅可以监听的是mounted，其他的生命周期事件，例如：created,updated等都可以监听 12. 谈谈你对keep-alive的了解？keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，避免重新渲染，器有以下特性： 一般结合路由和动态组件一起使用，用于缓存组件； 提供include和exclude属性，两者都支持字符串或正则表达式，include表示只有名称匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会被缓存，其中exclude的优先级比include高 对应两个钩子函数actived和deactived，当组件被激活时，触发钩子函数activated，当组件被移除时，触发钩子函数和deactived 13.组件中data为什么是一个函数? 为什么组件中的data必须是一个函数，然而return一个对象，而new Vue实例里，data可以直接是一个对象？ 1234567891011121314//datadata()&#123; return &#123; message:'子组件', childName:this.name &#125;&#125;//new Vuenew Vue(&#123; el:'#app', router, tempate:'&lt;App/&gt;', components:&#123;App&#125;&#125;) 因为组件是用来复用的，而JS里对象是引用关系，如果组件中data是一个对象，那么这样作用域没有隔离，子组件中的data属性值会相互影响，如果组件中data选项时一个函数，那么每个实例可以维护一个被返回对象的独立拷贝，组件实例之间的data属性不会相互影响；而new Vue的实例，是不会被复用的，因此不存在引用对象的问题 14. v-model原理我们在vue项目中主要使用v-model指令在表单input，textarea，select等元素上，创建双向数据绑定，我们知道 v-model本质上不过是语法糖，v-model在内部为不同的输入元素使用不同的属性并跑出不同的事件： text和textarea元素使用value属性和input事件 checkbox和radio使用checked和change事件 select字段将value作为prop将change作为事件 以input表单元素为例 1234&lt;input v-model&#x3D;&quot;something&quot;&gt;&#x2F;&#x2F;相当于&lt;input v-bind&#x3D;&quot;something&quot; v-on:input&#x3D;&quot;something&#x3D;$event.target.value&quot;&gt; 如果在自定义事件中。v-model 默认会利用名为value的prop和名为input的事件，如下所示： 1234567891011121314父组件&lt;ModelChild v-model&#x3D;&quot;message&quot;&gt;&lt;&#x2F;ModelChild&gt;子组件&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;&#x2F;div&gt;props:&#123; value:String&#125;,methods:&#123; test1()&#123; this.$emit(&#39;input&#39;,&#39;小红&#39;) &#125;&#125; 15. Vue组件间通信有哪几种方式Vue组件间的通信是面试常考的知识点之一，Vue组件间通信主要是以下3类通信；父子组件通信，隔代组件通信，兄弟组件通信 (1) props/$emit使用父子组件通信 这种方法是Vue组件的基础 （2）ref与$parent/$children适用于父子组件通信 ref:如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果在子组件上，引用就是指向组件实例 $parent/$children：访问父/子实例 （3） EventBus($emit、$on)适用于父子，隔代，兄弟组件通信 这种方法通过一个空的Vue实例作为中央事件总线(事件中心)，用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子，隔代，兄弟组件 (4) $attrs/$listeners使用隔代组件通信 $attrs：包含了父租用与中不被prop所识别的特性绑定。当一个组件没有声明任何prop时，这里会包含所有副作用的绑定，并且可以通过v-bind:$attrs传入内部组件，通常配合inheritAttrs渲染一起使用 $listeners:包含了父作用域中的v-on事件监听器，它可以通过v-on=&quot;$listeners&quot;传入内部组件 (5) Vuex使用于父子，隔代，兄弟组件通信 Vuex是一个专为Vue.js应用程序开发的状态管理模式。每个Vuex应用的核心就是store（仓库）。“store”基本上就是一个容器，它包含着你的应用大部分的状态(state) Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应的高效更新 改变store中的状态的唯一途径就是显式地提交mutation这样使得我们可以方便地跟踪每一个状态的变化 17. 使用过Vue SSR吗？ 说说SSR？ Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。 即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。 服务端渲染 SSR 的优缺点如下： （1）服务端渲染的优点： 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面； 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间； （2) 服务端渲染的缺点： 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境； 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 18. 能说一下vue-router中常用的hash和history路由模式实现原理吗？(1) hash模式的实现原理 早期的前端路由的实现就是基于location.hash来实现的。其实现原理很简单，location.hash的值就是URL中#后面的内容。比如下面这个网站，它的lcoation.hash的值为#search 1http://www.word.com#search hash路由模式的实现主要基于下面几个特性： URL中hash值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash部分不会被发送 hash值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退，前景按钮控制hash的切换 可以通过a标签，并设置href属性，当用户点击这个标签后。URL的hash值会发生改变；或者使用JavaScript来对location.hash惊醒赋值，改变URL的hash值； 我们可以使用hashchange事件来监听hash值的变化，从而对页面进行跳转 （2）history模式的实现原理 HTML5提供了historyAPI来实现URL的变化，其中做最主要的API有以下两个：history.pushState()和history.replaceState()这两个API在不进行刷新的情况下，浏览器的历史记录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示： 12window.history.pushState(null,null,path)window.history.replaceState(null,null,path) history路由模式的实现主要基于存在下面几个特性： pushState和replaceState两个API来操作实现URL的变化 我们可以使用popState事件来监听url的变化，从而对页面进行跳转 history.pushState()和history,replaceState()不会触发popState事件，这是我们需要手动触发页面跳转 19. 什么是MVVMMVVM源自经典的Model-View-Controller（MVC）模式，MVVM的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM的核心是VIewModel层，它就像是一个中转站，负责Model中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与Model层接口进行数据交互，起承上启下作用如下图所示： (1)View层 View是视图层，也就是用户界面。前端主要由HTML和CSS来构建 (2)Model层 Model是指数据模型，泛指后端进行的业务逻辑处理和数据控制，对于前端来说就是祸端提供的APi接口 （3）ViewModel层 ViewModel是由前端开发人员组织生成和维护的视图数据层，在这一层，前端开发者对从后端获取的Model数据进行转换处理，做二次封装，以生成符合View层使用预期的视图数据模型。 通过一个Vue实例来说明MVVM的具体实现 (1) VIew层 12345678&lt;div id&#x3D;&quot;app&quot;&gt; &lt;p&gt; &#123;&#123;message&#125;&#125; &lt;&#x2F;p&gt; &lt;button v-on:click&#x3D;&quot;showMessage()&quot;&gt; click me &lt;&#x2F;button&gt;&lt;&#x2F;div&gt; (2) ViewModel层 123456789101112131415161718192021var app =new Vue(&#123; el:'#app', data:&#123; message:'Hello Vue' &#125;, methods:&#123; showMessage()&#123; let vm = this; alert(vm.message) &#125; &#125;, created()&#123; let vm =this; ajax(&#123; url:'/your/server/data/api', success(res)&#123; vm.message= res; &#125; &#125;) &#125; &#125;) （3） Model层 12345678&#123; \"url\":'/your/server/data/api', \"res\":&#123; \"success\"：true, “name”:\"IoveC\", \"domain\":\"www.cnblogs.com\" &#125; &#125; 20. Vue是如何实现数据双向绑定的？Vue数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示： 即： 输入框内容变化时，Data中数据同步变化。即View=&gt;Data的变化 Data中数据变化时，文本节点的内容同步变化。即Data=&gt;View的变化 其中，View变化更新Data，可以通过事件绑定的方式来实现，所以Vue的数据双向绑定的工作主要是如何根据Data变化更新View Vue主要通过以下4个不走来实现数据双向绑定的： 实现一个监听器Observer：对数据进行遍历，包括子属性对象的属性，利用Object.defineProperty()对属性加上setter和getter这样的话，给这个对象的某个值赋值就会触发setter，那么就能监听到了数据变化。 实现一个解析器Complie:解析Vue模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变化；收到通知，调用更新函数进行数据更新 实现一个订阅者Watcher：Watcher订阅者是Observer和Complie之间通信的桥梁，主要的任务是订阅Observer中属性值的变化的消息，当收到属性变化的消息时，触发解析器Complie中对应的更新函数。 实现一个订阅器Dep：订阅器采用发布-订阅设计模式，用来收集订阅者Watcher，对监听器Observer和订阅者Watcher进行统一管理 21. Vue框架怎么实现对象和数据的监听？如果被问到Vue怎么实现数据双向绑定的，大家肯定会回答通过Object.defineProperty()对数据进行劫持，但是Object.defineProperty()只能对属性进行数据劫持，不能对整个对象进行劫持，同理也无法对数组进行劫持，Vue是怎么检测到对象和数组的变化，查看相关代码如下 1234567observeArray(items:Array&lt;any&gt;)&#123; for(let i&#x3D;0,i&#x3D;items.length;i&lt;1;i++)&#123; observe(items[i]) &#x2F;&#x2F;observe 功能为检测数据的变化 &#125;&#125;let childOb &#x3D; !shallow &amp;&amp; observe(val) &#x2F;&#x2F; observe 功能检测数据的变化 通过Vue源码查看，Vue框架是通过遍历数组和递归遍历对象，从而达到利用Object.defineProperty()也能对对象和数组进行监听。 22. proxy与Object.defineProperty优劣对比Proxy的优势如下： proxy可以直接监听对象而非属性 Proxy可以直接监听数组的变化 Proxy有多达13中拦截方法，不限于apply，ownKeys,deleteProperty等等Object.defineProperty不具备的 Proxy返回的是一个新的对象，我们可以只操作新的对象达到目的，而Objecct.defineProperty只能遍历对象属性直接修改 Object.defineProperty的优势如下： 兼容性好，支持IE9，而Proxy的存在浏览器兼容器问题，而且无法用polyfill磨平 23.Vue怎么用vm.$set()解决对象新增属性不能响应的问题？受现代JavaScript的限制，Vue无法检测到对象属性的添加或删除。由于Vue会在初始化实例时对属性执行getter/setter转化，所以属性必须在data对象上存在才能让Vue将它转换为响应式的。但是Vue提供了Vue.set(object,propertyName,value)/Vue.$set(object,propertyName,value)来实现对选哪个添加响应式属性，那么框架本身是如何实现的呢？ 查看对应的Vue源码: 12345678910111213141516171819202122232425export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123; // target 为数组 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; // 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误 target.length = Math.max(target.length, key) // 利用数组的splice变异方法触发响应式 target.splice(key, 1, val) return val &#125; // key 已经存在，直接修改属性值 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val return val &#125; const ob = (target: any).__ob__ // target 本身就不是响应式数据, 直接赋值 if (!ob) &#123; target[key] = val return val &#125; // 对属性进行响应式处理 defineReactive(ob.value, key, val) ob.dep.notify() return val&#125; vm.$set的实现原理是： 如果目标是数组，直接使用数组的splice方法触发响应式 如果目标是对象，会先判断属性是否存在，对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用defineReactive方法进行响应式处理(defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法) 24. 虚拟DOM的优缺点优点： 保证性能下限：框架的虚拟DOM需要适配任何上层API可能产生的操作，它的一些DOM操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的DOM操作性能要好很多，因此框架的虚拟DOM至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限。 无需手动操作DOM：我们不需要手动去操作DOM，只需要写好view-Modek的代码逻辑，框架会根据虚拟DOM和数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率 跨平台：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，相比之下虚拟DOM可以更方便地跨平台操作，例如服务器渲染，weex开发等等 缺点： 无法进行极致优化：虽然虚拟DOM+合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化 25. 虚拟DOM实现原理虚拟DOM的实现原理主要包括以下3部分 用JavaScript对象模拟真实DOM树，对真实DOM树进行抽象 diff算法 —比较两棵虚拟DOM树的差异 pach算法—-将两个虚拟DOM对象的差异应用到真正的DOM树 26. Vue中的key有什么用key是Vue中vnode的唯一标识，通过这个key，我们的diff操作可以更准确，更快速。Vue的diff过程可以概括为:oldCh和newCh各有两个头尾的变量oldStartIndex，oldEndIndex和newStartIndex，newEndIndex他们会新节点和旧节点进行两两对比，即一共有4中比较方式：newStartIndex和oldStartIndex， newEndIndex和oldEndIndex，newStartIndex和oldEndIndex，newEndIndex和newStartIndex，如果以上4中比较都没有匹配，如果设置了key，就会用key再进行比较。 所以Vue中key的作用是：key是作为Vue中Vnode的唯一标识，通过这个key我们的diff操作可以更准确，更快速 更准确：因为带key就不是就地复用了，在sameNode函数a.key===b.key对比中可以避免就地复用的情况，所以会更加准确 更快速：利用key的唯一性生成map对象来获取对应节点，比遍历方式更快，源码如下： 123456789function createKeyToOldIdx(children,beginIdx,endIdx)&#123; let i,key const map =&#123;&#125;; for(i=beginIdx;i&lt;=endIdx;++i)&#123; key=children[i].key; if (isDef(key))map[key]=i &#125; return map&#125; 27. 对Vue项目进行哪些优化？（1）代码层面的优化 v-if和v-show区别使用场景 computed和watch区分使用场景 v-for遍历必须为item添加key，且避免同时使用v-if 长列表性能优化 事件的销毁 图片资源懒加载 路由懒加载 第三方插件按需引用 服务端渲染SSR or预渲染 （2）webpack层面的优化 webpack对图片进行压缩 减少ES6转为ES5的冗余代码 提取公共代码 模板预编译 提取组件的CSS VUe项目编译优化 （3）基础的web技术的优化 开启gzip压缩 浏览器缓存 CDN的使用 28. 对于vue3.0特性你有什么了解（1）检测机制的改变 3.0将带来基于Proxy的observer实现，提供全语言覆盖的反应性跟踪。消除了Vue2当基于Object.defineProperty的实现存在的很多限制 只能检测属性，不能检测对象 检测属性的添加和删除 检测数组索引和长度的变更 支持Map，set，weakMap和WeakSet （2）模板 模板方面，改了作用域插槽，把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。 （3）对象式的组件声明方式 3.0修改了组件的声明方式，改成了类式的写法，这样使得和TypeScript的结合更加容易","categories":[],"tags":[]},{"title":"git","slug":"git","date":"2021-01-26T10:50:20.509Z","updated":"2021-01-26T10:51:49.744Z","comments":true,"path":"posts/43167/","link":"","permalink":"http://blog.liurugang.cn/posts/43167/","excerpt":"","text":"gitgit是什么 官方话：Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务 引用廖雪峰老师的话，它能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想要查看某次改动，只需要在软件里喵一眼就可以。 为什么要学习Git 面试要被问。可以应付面试‘ 很多公司开发都用GIt来处理项目。现在不学，以后肯定还要学 在我看来Git是现如今所有程序员都要掌握的，以后与同事共同开发项目必定要用到的，熟练掌握Git命令，可以提高开发效率 安装git windows ​ 直接在官网上去下载。下载完成后，随便在某个文件下右键如果有Git Bash Here 就安装成功了。安装后，还要再命令行输入 12$git config --global user.name \"你的名字\"$git config --global user.email \"你的邮箱\" global表示全局，这台机器所有的GIt仓库都会使用这个配置。允许单个仓库使用其他的名字和邮箱 仓库 本地仓库是对于远程仓库而言的 本地仓库 = 工作区 + 版本区 工作区即磁盘上的文件集合 版本区即.git文件 版本库 = 暂存区(stage) + 分支(master) +指针(head) 以我使用最频繁的git命令为例，即提交到github为例 git init 原本本地仓库只包含着工作区，这是最常见的工作状态。此时，git init一下，表示在本地区域创建了一个.git文件，版本区建立 git add .表示把工作区的所有文件提交到版本区里面的暂存区 当然你也可以通过git add ./xxx/一条条分批添加到暂存区 git commit -m &#39;xxx&#39;把暂存区的所有文件提交到仓库区，暂存区空空荡荡 git remote add origin https://github.com/name/name_canku.git把本地仓库与远程仓库连接起来 git push -u origin master把仓库区的文件提交到远程仓库里 一旦提交了，如果你又没有对工作区做任何修改，那么工作区就是干净的。会有这样的信息noting to commit,working tree clean 提交到Github git init .初始化，表示把这个文件变成Git可以管理的仓库。初始化后打开隐藏的文件可以看到有一个.git文件。 git add . 后面的一个点表示把这个文件全部提交到暂存区。 git add ./readme.md/ 表示把这个文件下面的readme.md文件提交到暂存区。 git commit -m &quot;你要评论一点什么东西&quot; git commit的意思是把暂存区的全部文件提交到本地仓库。-m后接评论。 git remote add origin https://github.com/name/name_cangku.git表示把你本地的仓库与GitHub上的远程仓库连接起来。只需要连接一次，以后提交的时候就可以不用谢这条命令了。name是你的github名字，name_cangku是你的仓库名。注意不要把后面的.git给漏掉了。因为我前面就是这么走过来的，绕了很多弯路。至于如何在GitHub上新建仓库，网上有很多教程，这里不再赘述了。 git push -u origin master 把本地仓库提交到远程仓库。(最后一步)在你的远程仓库上刷新一下就可以看到你提交的文件了。 最后提到的是，在git commit -m &quot;&quot;之前，可以重复git add到暂存区。但是git commit会把你之前存放在暂存区的全部文件一次性全部提交到本地仓库。 版本的回溯与前进提交一个文件，有时候我们会提交很多次，在提交历史中，这样就产生了不同的版本。每次提交，GIt会把他们串成一条时间线。如何回溯到我们提交的上一个版本，用git reset --hard+ 版本号即可。版本可以用git log来查看，每一次的版本都会产生不一样的版本号。回溯之后，git log查看一下发现我们最近的那个版本已经不见了。但是我们还想要前进到最近的版本应该如何？只要git reset --hard +版本号就行。退一步来讲，虽然我们可以通过git reset --hard+ 版本号，靠记住版本号来可以正在不同的版本之间来回穿梭。但是，有时候把版本号弄丢了怎么办？git reflog帮你记录了每一次的命令，这样就可以找到版本号了，这样你又可以通过git reset来版本穿梭了。 撤销 场景1:在工作区时，你修改了一个东西，你想撤销修改，git checkout --file。廖雪峰老师指出撤销修改就回到和版本库一模一样的状态，即用版本库里的版本踢馆工作区的版本。 场景2: 你修改了一个内容，并且已经git add 到暂存区了。向撤销怎么办？回溯版本，git reset --hard --hard + 版本号,再git checkout --file，替换工作区的版本 场景3：你修改了一个内容，并且已经git commit到了master。跟场景2一样，版本回溯，在进行撤销 删除 如果你git add一个文件到暂存区，然后在工作区又把文件删除了，git会知道你删除了文件，如果你把版本库里的文件删除，git rm并且git commit -m &#39;xxx&#39;。 如果你误删了工作区的文件，怎么办？使用撤销命令，git checkout --&lt;file&gt;就可以。这再次证明了撤销命令其实就是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以一键还原 分支分支，就像平行宇宙，廖雪峰老师如是说。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，向提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作 创建与合并分支 在没有其他分支插进来时，只有一个master主分支。每次你git push -u origin master提交就是增加哦一条事件轴，master也会跟着移动 创建一个other的分支，通过other提交，虽然时间轴向前走了，但是主分支还在原来的位置 理论分析完，看一下命令怎么写 创建分支other，切换到other分支 12git branch othergit checkout other 查看当前所有分支 1git branch 12* other master 当前的分支会有一个* 用other提交 12git add .&#x2F;xxx&#x2F;git commit -m &#39;xxx&#39; other分支完成，切换会master 1git checkout master 此时，master分支上并没有other的文件，因为分支还没有合并 合并分支 1git merge other 合并完成之后，就可以在master分支上查看到文件了 删除other分支 1git branch -d other 在以后的工作中，应该是一个开发小组共同开发一个项目，组长会创建很多分支，每一个分支可以交给一个人开发某一个功能，一个小组共同开发而且不会相互干扰。谁的功能完成了，就可以有组长合并一下完成了的分支。 解决合并分支问题 假如有这样一种情况，分支other已经commit了，但是此时指针指回master时，并且master没有合并，而是git add/commit提交了。这样，就产生了冲突，主分支master文件内容与other分支的内容不一样。合并不起来 修改文件的内容，让其保持一致。 git add ``git commit提交 分支合并了 git log --graph 查看分支合并图 git branch -d other删除分支，任务结束。 删除分支 git branch -d + 分支有可能会删除失败，因为会保护没有被合并的分支 git branch -D + 分支强行删除，丢弃没有被合并的分支 多人协作 git remote查看远程库的信息，会显示origin,远程仓库默认名称为origin git remote -v 显示更详细的信息 git push -u origin master推送master分支到origin远程仓库 git push -u origin master推送other到origin远程仓库 抓取分支 产生上图的冲突时， git pull把最新的提交从远程仓库中抓取下来，在本地合并，解决冲突。再进行git push 如果git pull也失败了，还要指定分支之间的链接，这一步git会性你怎么做。然后再git push 廖雪峰老师的总结：多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并 如果合并有冲突，则姐姐冲突，并在本地提交 没有冲突或解决掉冲突后，再用git push origin &lt;branch-nam&gt;推送就能成功 如果git push 提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt;origin/&lt;branch-name&gt; 标签管理 比如一个APP要上线，通常在版本库中打一个标签(tag)，这样就确定了打标签的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照 git的标签虽然是版本库的快照，但是它其实就是指向某个commit的指针。 tag其实就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。比如tagv2,1就是把历史上的一个版本的东西叫做v2.1 创建标签 git branch查看当前分支，git checkout master切换到master分支。 git tag &lt;name&gt;打标签，默认为HEAD。比如git tag v1.0默认标签是打在最新提交的commit上的。如果想要打标签在以前的commit上，要git log找到历史提交的commit id 如果一个commit id是du2nd9，执行git tag v1.0 du2nd9就把这个版本打上了v1.0的标签了 git tag查看所有标签，可以知道历史版本的tag 标签不是按照时间顺序列出，而是按照字母顺序的 git show &lt;tagname&gt;查看标签信息 git tag -a &lt;标签名&gt; -m &quot;说明&quot;，创建带说明的标签。-a指定标签名，-m指定说明文字。用show可以查看说明 操作标签 git tag -d v1.0删除标签。因为创建的标签都只存储在本地，不会自动推送感到远程，所以，打错的标签可以在本地安全删除 git push origin &lt;tagname&gt;推送某个标签到远程 git push origin --tags一次性推送全部尚未推送到远程的本地标签 如果标签推送到远程。git tag -d v1.0先删除本地标签v1.0。git push origin:refs/tags/v1.0删除远程标签v1.0 常用git命令总结 git config --global user.name &quot;你的名字&quot; 让你全部的Git仓库绑定你的名字 git config --global user.email &quot;你的邮箱&quot; 让你全部的Git仓库绑定你的邮箱 git init 初始化你的仓库 git add . 把工作区的文件全部提交到暂存区 git add ./&lt;file&gt;/ 把工作区的&lt;file&gt;文件提交到暂存区 git commit -m &quot;xxx&quot; 把暂存区的所有文件提交到仓库区，暂存区空空荡荡 git remote add origin https://github.com/name/name_cangku.git 把本地仓库与远程仓库连接起来 git push -u origin master 把仓库区的主分支master提交到远程仓库里 git push -u origin &lt;其他分支&gt; 把其他分支提交到远程仓库 git status查看当前仓库的状态 git diff 查看文件修改的具体内容 git log 显示从最近到最远的提交历史 git clone + 仓库地址下载克隆文件 git reset --hard + 版本号 回溯版本，版本号在commit的时候与master跟随在一起 git reflog 显示命令历史 git checkout -- &lt;file&gt; 撤销命令，用版本库里的文件替换掉工作区的文件。我觉得就像是Git世界的ctrl + z git rm 删除版本库的文件 git branch 查看当前所有分支 git branch &lt;分支名字&gt; 创建分支 git checkout &lt;分支名字&gt; 切换到分支 git merge &lt;分支名字&gt; 合并分支 git branch -d &lt;分支名字&gt; 删除分支,有可能会删除失败，因为Git会保护没有被合并的分支 git branch -D + &lt;分支名字&gt; 强行删除，丢弃没被合并的分支 git log --graph 查看分支合并图 git merge --no-ff &lt;分支名字&gt; 合并分支的时候禁用Fast forward模式,因为这个模式会丢失分支历史信息 git stash 当有其他任务插进来时，把当前工作现场“存储”起来,以后恢复后继续工作 git stash list 查看你刚刚“存放”起来的工作去哪里了 git stash apply 恢复却不删除stash内容 git stash drop 删除stash内容 git stash pop 恢复的同时把stash内容也删了 git remote 查看远程库的信息，会显示origin，远程仓库默认名称为origin git remote -v 显示更详细的信息 git pull 把最新的提交从远程仓库中抓取下来，在本地合并,和git push相反 git rebase 把分叉的提交历史“整理”成一条直线，看上去更直观 git tag 查看所有标签，可以知道历史版本的tag git tag &lt;name&gt; 打标签，默认为HEAD。比如`git tag v1.0 git tag &lt;tagName&gt; &lt;版本号&gt; 把版本号打上标签，版本号就是commit时，跟在旁边的一串字母数字 git show &lt;tagName&gt; 查看标签信息 git tag -a &lt;tagName&gt; -m &quot;&lt;说明&gt;&quot; 创建带说明的标签。 -a指定标签名，-m指定说明文字 git tag -d &lt;tagName&gt; 删除标签 git push origin &lt;tagname&gt; 推送某个标签到远程 git push origin --tags 一次性推送全部尚未推送到远程的本地标签 git push origin :refs/tags/&lt;tagname&gt; 删除远程标签` git config --global color.ui true 让Git显示颜色，会让命令输出看起来更醒目 git add -f &lt;file&gt; 强制提交已忽略的的文件 git check-ignore -v &lt;file&gt; 检查为什么Git会忽略该文件","categories":[],"tags":[]},{"title":"JavaScript面试题","slug":"JavaScript面试题","date":"2021-01-26T10:50:14.665Z","updated":"2021-01-26T10:51:49.740Z","comments":true,"path":"posts/53500/","link":"","permalink":"http://blog.liurugang.cn/posts/53500/","excerpt":"","text":"JavaScript面试题1. 闭包 闭包就是能够读取其他函数内部变量的函数 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用域链 闭包的特性： 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 说说你对闭包的理解 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中 闭包的另一个用处，是封装对象的私有属性和私有方法 2. 说说你对作用域链的理解 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的 简单来说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期 3. javascript原型，原型链？有什么特点？ 每个对象都会在其内部初始化一个属性，就是prototype原型)，当我们访问一个对象的属性时，若果这个对象内部不存在这个属性，那么它就会去prototype里面找这个属性，这个prototype又有自己的prototype，于是就这样一直找下去，也就是我们所说的原型链的概念 关系： instance.constructor.prototype =instance.__proto__ 特点： javascript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变 当我们需要一个属性时，JavaScript引擎会先看当前对象是否有这个属性，如果没有的话，就会查找它的prototype对象是否有一个属性，如此递推下去，一直检索到Object内建对象 4. 请解释什么是事件代理 事件代理，又被称之为事件委托，是JavaScript中产能常用绑定事件的常用技巧。顾名思义，”事件代理“即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听对的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以大大提交性能 可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就很好 可以实现当新增子对象时无需再次对其绑定 5. 谈谈this对象的理解 this总是指向函数的直接调用者 如果有new关键字，this指向new出来的那个对象 在事件中，this指向触发这个事件的对象。特殊的是，IE中的attacheEvent中的this总是指向全局对象window 6. 事件模型 w3c中定义事件的发生经历三个阶段：捕获阶段，目标阶段，冒泡阶段 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发 DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件 阻止冒泡：在w3c中使用stopPropagation()方法 阻止捕获；阻止默认事件的行为，在w3c中，使用preventDefault()方法 7. new操作符具体干了什么？ 创建一个空对象，并且this变量引入该对象，同时继承了该函数的原型 属性和方法被加入到this引用的对象中 新创建的对象由this所引用，并且最后隐式的返回this 8. Ajax原理 Ajax的原理简单的来说就是在用户和服务器之间加了一个中间层(AJAX引擎)，通过xmlHttpRequest对象来向服务器发异常请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据 Ajax的过程只涉及Javascript，XMLHttpRequest和DOM。XMLHttpRequest是ajax的核心机制 1234567891011121314151617//1.创建连接var xhr =null；xhr = new XMLHTTPRequest();//2.连接服务器xhr.open('get',url,true)//3.发送请求xhr.send(null)//4.接收请求xhr.onreadystatechange = function()&#123; if(xhr.readyState==4)&#123; if(xhr.status ==200)&#123; success(xhr.responseText) &#125;else&#123; fail&amp;&amp; fail(xhr.status) &#125; &#125;&#125; 9. 谈谈变量提升 当执行JS代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境。在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为undefined，所以在第二阶段，也就是代码执行阶段，我们可以直接提前使用 123456b();//call bconsole.log(a)//undefinedvar a ='hello world'function b()&#123; console.log('call b')&#125; 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升 12345678b()//call b secondfunction b()&#123; console.log('call b first')&#125;function b()&#123; console.log('call b second')&#125;var b = 'Hello world' 10.bind，call，apply区别 call 和apply都是为了解决改变this的指向。作用都是相同的，只是传参的方式不同 除了第一个参数外，call可以接收一个参数列表，apply只接受一个参数数组 12345678910let a =&#123; value:1&#125;function getValue(name,age)&#123; console.log(name) console.log(age) console.log(this.value)&#125;getValue.call(a,'yck','24');getValue.apply(a ['yck','24']) bind和其他两个方法的作用也是一致的，只是该方法会返回一个函数。 11. 如何实现一个call函数实现以下几个函数，可以从几个方面思考 不传入第一个参数，那么默认为window 改变了this指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除 1234567891011Function.prototype.myCall = function(context)&#123; var context = context||window //给context添加一个属性 context.fn =this; //将context后面的参数取出来 var args =[...arguments.slice(1)] var result= context.fn(...args) //删除fn delete context.fn return result&#125; 12. 如何实现一个apply函数123456789101112131415161718192021Function.prototype.myApply = function(context)&#123; var context = context ||window; context.fn = this; var result; //需要判断是否存储第二个参数 //如果存在，就将第二个参数展开 if(arguments[1])&#123; result =context.fn(...arguments[1]) &#125;else&#123; result =context.fn() &#125; delete context.fn return result; &#125; let a = &#123;value:1&#125; function getValue(name,age)&#123; console.log(name) console.log(age) console.log(this.value) &#125; getValue.myApply(a,'yck','24') 13.如何实现apply函数1234567891011121314Function.prototype.myBind =function(context)&#123; if(typeof this!=='function')&#123; throw new TypeError('error') &#125; var _this =this; var args = [...arguments].slice(1) //返回一个函数 return function F()&#123; if(this instanceof F)&#123; return new _this(...args, ...arguments) &#125; return _this.apply(context, args.concat(...arguments)) &#125; &#125; 14. 箭头函数的特点12345678function a()&#123; return ()=&gt;&#123; return ()=&gt;&#123; console.log(this) &#125; &#125;&#125;console.log(a()()()) 箭头函数其实没有this的，这个函数中的this只取决于他外面的第一个不是箭头函数的函数的this。在这个例子中，因为调用a符合前面代码的第一种情况，所以this是window、并且this一旦绑定了上下文，就不会被任何代码改变 15. async，await优缺点 async和await相比直接使用Promise来说，优势在于处理then的调用链，能够更清晰准确的写出代码。缺点在于滥用await可能会导致性能问题，因为await会阻塞代码，也许之后的异步代码并不依赖前者，但仍然需要等待前者完成，导致代码失去了并发性 下面看一个使用await的代码 12345678910var a =0;var b= async()=&gt;&#123; a =a +await 10 console.log('2',a) // '2' 10 a= (await 10) +a console.log('3',a) // '3' 20&#125;b();a++;console.log('1',a)//'1'1 首先函数b先执行，在执行await 10 之前变量a 还是0，因为在await内部实现了generators，generators会保留堆栈中东西，所以这时候a =0,被保留了下来 因为await是异步操作，遇到await会立即返回一个pending状态的Promsie对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行console.log(&#39;1&#39;,a) 这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候a=10 然后后面就是常规执行代码了 16. Promise Promise 是ES6新增的语法，解决了回调地狱问题。 可以把Promise看成一个状态机。初始是pending状态，可以通过函数resolve和reject将状态转变成resolved或者rejected状态，状态一旦改变不能再次变化 then函数会返回一个Promise实例，并且该返回值是一个新的实例而不是之前的实例。 17. instance原理能在实例的原型对象链中找到该构造函数的prototype属性所指向的原型原型，就返回true 123//__proto__:代表原型对象链instance.[__proto__...] === instance.constructor.prototype//return true 18. 执行上下文(EC)执行上下文可以简单理解为一个对象 它包含三个部分： 变量(VO) 作用域链(词法作用域) this指向 它的类型 全局执行上下文 函数执行上下文 evel执行上下文 代码执行过程 创建全局上下文 全局执行上下文逐行自上而下执行。遇到函数时，函数执行上下文(callee)被push到执行栈顶 函数执行上下文(callee)被激活，开始执行函数函数中的代码，全局执行上下文(caller)被挂起 函数执行完后，函数执行上下文(callee)被pop移除执行栈，控制权交还全局上下文(caller)继续执行 19. 对象的拷贝 浅拷贝：以赋值的形式拷贝引用对象，仍指向同一个地址，修改时源对象也会受到影响 Object.assign 展开运算符 深拷贝：完全拷贝一个新对象，修改时源对象不再受到任何影响 JSON.parse(JSON.stringify(obj)):性能最快 具有循环引用的对象时，报错 当值为函数，undefined或symbol时无法拷贝 递归进行注意赋值 20. 防抖与节流防抖与节流函数是一种最常见的高频触发优化方式，能对性能有较大帮助 防抖：将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需要再输入完成后做一次输入校验即可。 1234567891011121314function debounce(fn,wait,immediate)&#123; let timer =null; return function()&#123; let args = arguments let context =this; if(immediate &amp;&amp; !timer)&#123; fn.apply(context,args) &#125; if(timer) clearTimeout(timer) timer = setTimeout(()=&gt;&#123; fn.apply(context,args) &#125;,wait) &#125;&#125; 节流: 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景：滚动条事件或者resize事件，通常每隔100~500ms执行一次即可。 123456789101112131415161718function throttle(fn,wait,immediate)&#123; let timer =null; let callNow =immediate return function()&#123; let context = this, args =arguments; if(callNow)&#123; fn.apply(context,args) callNow =false &#125; if(!timer)&#123; timer =setTimout(()=&gt;&#123; fn.apply(context,args) timer=null &#125;,wait) &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Nuxt.js实战和配置","slug":"Nuxt.js实战和配置","date":"2021-01-26T10:50:10.696Z","updated":"2021-01-26T10:51:49.725Z","comments":true,"path":"posts/39766/","link":"","permalink":"http://blog.liurugang.cn/posts/39766/","excerpt":"","text":"Nuxt.js实战和配置为什么要用Nuxt.js目的是为了利用Nuxt.js的服务端渲染能力来解决Vue项目的SEO问题 Nuxt.js和纯Vue项目的简单对比 build后目标产物不同 vue:dist nuxt:nuxt 页面渲染流程 Vue：客户端渲染，先下载js后，通过ajax来渲染页面 nuxt:服务端渲染，可以做到服务端拼接好html后直接返回，首屏可以无需发起ajax请求 部署流程 Vue：只需要部署dist目录到服务端，没有服务端，需要用nginx等做web服务器； nuxt：需要部署几乎所有文件到服务器，自带服务端，需要pm2管理，若要求用域名，则需要nginx做代理 项目入口 vue：/src/main.js，在main.js可以做一些全局注册的初始化工作；nuxt没有main.js入口文件，项目初始化的操作需要通过nuxt.config.js进行配置指定。 从零搭建一个Nuxt.js项目并配置新建一个项目直接使用脚手架进行安装 1npx create-nuxt-app &lt;项目名&gt; 大概选上面这些选项 Nuxt开发相关生命周期Nuxt扩展了Vue的生命周期，大概如下： 12345678910export default&#123; middleware()&#123;&#125;,//服务端 validate()&#123;&#125;,//服务端 asyncData()&#123;&#125;,//服务端 fetch()&#123;&#125;，//store数据加载 beforeCreate()&#123;&#125;,//服务端和客户端都会执行 created()&#123;&#125;, //服务端和客户端都会执行 beforeMount()&#123;&#125;, mounted()&#123;&#125; //客户端 &#125; asyncData 该方法是Nuxt最大的一个卖点，服务端渲染的能力就在这里，首次渲染务必使用该方法。asyncData会传进一个context参数，通过该参数获得一些信息，如： 123456789export default&#123; asyncData(ctx)&#123; ctx.app //根实例 ctx.route //路由实例 ctx.params //路由参数 ctx.query //路由问好后面的参数 ctx.error //错误处理方法 &#125;&#125; 渲染出错的ajax请求出错的处理 asyncData渲染出错 使用asyncData钩子时可能会由于服务器错误或api错误导致无法渲染，此时页面还未渲染出来，需要针对这种情况做一些处理，当遇到asyncData错误时，跳转到错误页面，nuxt提供了context.error方法用于错误处理，在asyncData1中调用该方法可跳转到错误页面 123456789export default&#123; async asyncData(ctx)&#123; try&#123; throw new Error() &#125;catch&#123; ctx.error(&#123;statusCode:500,message:'服务器来小差'&#125;) &#125; &#125;&#125; 这样，当出现异常时，会跳转到默认的错误页，错误页面可以通过/layout/error.vue自定义 这里会遇到一个问题,context.error的参数必须是类似{statusCode:500.message:&#39;服务器开小差了&#39;},statusCode必须是http状态码，而我们服务端返回的错误往往有一些其他的自定义代码，如{resultCode:10005,resultInfo:&#39;服务器内部错误&#39;},此时需要对返回的api错误进行转换一下。 为了方面，我引入了/plugins/ctx-inject.js为context注册一个全局的错误处理方法： context.$errorHandler(err)。ctx-injecct.js: 12345678910111213141516//为context注册全局的错误处理事件export default(ctx,inject)=&gt;&#123; ctx.$errorHandler =err=&gt;&#123; try&#123; const res =err.data if(res)&#123; //由于nuxt的错误只能识别http的状态码，因此statusCode统一传500.表示服务器异常 ctx.error(&#123;statusCode:500,message:res.resultInfo&#125;) &#125;else&#123; ctx.error(&#123;status:500,message:'服务器开小差'&#125;) &#125; &#125;catch&#123; ctx.error(&#123;status:500,message:'服务器开小差'&#125;) &#125; &#125;&#125; 然后在nuxt.config.js使用该插件： 12345export default&#123; plugins:[ '~/plugins/ctx-injecct.js' ]&#125; 注入完毕，我们可以在asyncData中进行使用 123456789export default&#123; async asyncData(ctx)&#123; try&#123; throw new Error() &#125;catch(err)&#123; ctx.$errorHandler(err) &#125; &#125;&#125; ajax请求错误 对于ajaxx的异常，此时页面已经渲染，出现错误时不必跳转到错误页，可以通过this.$toast.error(res.message)toast出来即可 loading方法 nuxt内置了页面顶部loading进度条推荐使用，提供页面跳转体验。打开：this.$nuxt.$loading.start()完成this.$nuxt.$loading.finish() 打包部署一般来说，部署前可以现在本地打包，本地跑一下，确认无误之后再上传到服务器部署。命令： 1234//打包npm run build//本地跑npm start 除node_modules,.git .env，将其他的文件都上传到服务器，然后通过pm2进行管理，可以在项目根目录建一个pm2.json方面维护： 123456&#123; \"name\":\"nuxt-test\", \"script\":\"./server/index.js\", \"instances\":2, \"cwd\":\".\"&#125; 首次部署或有新到的依赖包，需要在服务器上npm install一次，然后可以用pm2启动进程 12//项目根目录下运行pm2 start ./pm2.json 需要的话，可以设置开机自动启动pm2:pm2 save&amp;&amp;pm2 startup。需要注意，每次部署都得重启一下进程:pm2 reload nuxt-test","categories":[],"tags":[]},{"title":"pm2","slug":"pm2","date":"2021-01-26T10:50:05.436Z","updated":"2021-01-26T10:51:49.733Z","comments":true,"path":"posts/40620/","link":"","permalink":"http://blog.liurugang.cn/posts/40620/","excerpt":"","text":"pm2背景对于线上项目，如果直接用node app 来启动，如果报错了，可能直接停止导致整个服务器崩溃，一般监控node有几种方案 supervisor： 一般用作开发环境的使用 forever：管理多个站点，一般每个站点的访问量不大的情况，不需要监控 PM2:网站的访问量比较大，需要完整的监控页面 PM2的主要特性 内部负载均衡 后台运行 0秒停机重载，我理解大概意思是维护升级的时候不需要停机 具有Ubuntu和CentOS的启动脚本 停止不稳定的进程(避免无限循环) 控制台检测 提供HTTP API 远程控制和实时的API 安装12//全局安装pm2，依赖node和npmnpm install -g pm2 用法 基本启动命令 123//pm2 start//start命令启动对应的node server文件pm2 start ./build/server.js 启动之后，控制台会看到如下消息： 如上图所示，可以看到项目kafazhe启动成功，id是0，并且状态是online 查看详细状态信息 12&#x2F;&#x2F; pm2 show (appname|id)pm2 show kaifazhe 如上图所示，可以查看kaifazhe进程的详细信息 查看所有启动的进程列表 1pm2 list 监控每个node进程对的cpu和内存使用情况 1pm2 monit 可以使用pm2 monit功能监控所有node进程的运行情况，包括各种响应，错误信息 显示所有进程的日志 1pm2 logs 监控运行这些进程的机器的状态 1pm2 web 停止 指定/所有进程 1pm2 stop (id|all) 如图，我们运行了两个服务状态都是online，使用stop 0 之后，kaifazhe的服务编程了stopped，然后使用stop all，所有进程状态变成了stopped 启动 指定/所有进程 1pm2 restart (id|all) 杀死 指定/所有进程 1pm2 delete (id|all) 从上图我们可以看出，restart 0 之后，0进程从stopped状态变成了online，然后我们使用delete 0，进程0 就消失不见了，我们再delete all,可以看到现在没有任何进程在运行。 配置PM2启动文件pm2启动的方式可以进行很多的扩展，比如设置环境，设置错误信息打印，设置输入信息打印等等高级功能。那么一条命令就不能完成这些任务，所有pm2提供了配置文件的方式来启动 pm2.config.js1234567891011121314151617181920212223242526272829303132module.exports = &#123; apps: [ &#123; name: 'kaifazhe', // 应用名称 script: './build/server.js', // 启动文件地址 cwd: './', // 当前工作路径 watch: [ // 监控变化的目录，一旦变化，自动重启 'src', 'build', ], ignore_watch: [ // 忽视这些目录的变化 'node_modules', 'logs', 'public', ], node_args: '--harmony', // node的启动模式 env: &#123; NODE_ENV: 'development', // 设置运行环境，此时process.env.NODE_ENV的值就是development ORIGIN_ADDR: 'http://www.yoduao.com' &#125;, env_production: &#123; NODE_ENV: 'production', &#125;, out_file: './logs/out.log', // 普通日志路径 error_file: './logs/err.log', // 错误日志路径 merge_logs: true, log_date_format: 'YYYY-MM-DD HH:mm Z', &#125;, ],&#125;; 负载均衡pm2厉害的点是，自动给你做负载均衡，只需要一条命令 12345pm2 start server.js -i (number|max)//开启三个进程运行项目pm2 start app.js -i 3//根据机器CPU核数，开启对应数目的进程运行项目pm2 start app.hs 04-i max 配置文件里对应的：&quot;instance&quot;:(number|max) 12//pm2 config.js“instances”:2 //启动两个实例 配合pm2-web实现监控可视化安装1npm install -g pm2-web 使用默认pm2-web会自动启动一个8080，但是我们还是喜欢可控状态，因此安装配置文件的方法启动 1pm2-web --config pm2-web-config.json 1234567&#123; \"www\":&#123; \"host\":\"localhost\", \"address\":\"0.0.0.0\", \"port\":6666 &#125;&#125; 这样你就要可以在浏览器查看可视化的监控状态了","categories":[],"tags":[]},{"title":"html面试题","slug":"html面试题","date":"2021-01-26T08:18:08.423Z","updated":"2021-01-26T10:51:49.747Z","comments":true,"path":"posts/7559/","link":"","permalink":"http://blog.liurugang.cn/posts/7559/","excerpt":"","text":"前端面试题基础篇HTML，HTTP，web综合问题1. 前端需要注意哪些SEO 合理使用title ，description，keywords 语义化的HTML代码 重要内容HTML代码放在最前面 重要内容不要用JS输出 少用iframe 非装饰性图片必须加alt 提高网站访问速度 2. &lt;img&gt;的title和alt有什么区别 title通常当鼠标滑动到元素上的时候显示 alt是img的特有属性，是图片内容的等价描述，用于图片无法加载时显示，读屏器阅读图片。可以提高图片高可访问性。搜索引擎会重点分析 3. HTTP的几种请求方法用途 GET 方法 。 发送一个请求来取得服务器上的某一资源 POST方法。向URL指定的资源提交数据或附加新的数据 DELETE方法。删除服务器上的某资源 CONNECT方法。把请求连接转换到透明的TCP/IP通道4. 从浏览器地址栏输入url到显示页面的步骤 基础版本 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发送请求 服务器交给后台处理完成后返回数据，浏览器接收文件(HTML,JS,CSS,图像等) 浏览器对加载到的资源(HTML,JS,CSS等等)进行语法解析，建立相应的内部数据结构（如DOM树，CSSOM树） 载入解析到的资源文件，渲染页面，完成。 详细版 在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证 检验新鲜通常由两个HTTP头进行控制EXpires和Cache-Control HTTP1.0提供expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-control：max-age=，值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP(GET)请求报文 浏览器获取主机IP地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 DNS缓存 DNS递归查询 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=x的包到服务器端口 服务器发挥SYN=1，ACK=x+1,Seq=Y的响应包 客户端发送ACK=Y+1,Seq =z TCP链接建立以后发送HTTP请求 服务器接收请求并解析，处理程序读取晚会智能请求并准备HTTP响应，可以需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，广播TCP的四次握手如下： 主动方发送Fin=1 Ack=z，Seq=x报文 被动方发送Ack=x+1,Seq=z报文 被动方大宋Fin=1，ACK=x,Seq=Y报文 主动方大宋ACK=Y，Seq=x报文 浏览器检查响应状态码：是否为1xx,3xx,4xx,5xx，这些情况处理与2xx不同 如果资源可缓存，进行缓存 解析HTML文档，构建DOM树，下载资源，构建cssom树，执行JS脚本 构建DOM树 根据HTML规范将字符流解析为标记 词法分析将标记转换为对象并定义属性和规则 根据HTML标记关系将对象组成DOM树 解析构成中遇到图片，样式表，js文件，启动下载 构建CSSOM树 字符流转换成标记流 根据标记创建节点 节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树 从DOM树的根节点遍历所有可见节点 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 JS引擎解析过程 显示页面 5. 如何进行网站性能优化 content方面 减少HTTP请求：合并文件，css精灵(雪碧图），inline Image(内联图片) 减少DNS查询:DNS缓存，将资源分布到恰当数量的主机名 减少DOM元素数量 Cookie方面 减少cookie大小 css方面 将样式表放在页面的顶部 不使用css表达式 使用&lt;link&gt;不使用@import JavaScript方面 将脚本放到页面底部 将JavaScript和css从外部引入 压缩JavaScript和css 删除不需要的脚本 减少DOM访问 图片方面 优化图片：根据实际颜色需要选择色深，压缩 优化css图片 不要在HTML中拉伸图片 6. HTTP状态码及含义 1xx:信息状态码 100 continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 2xx:成功状态码 200 ok 正常返回信息 201 created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 3xx 重定向 301 请求的网页已永久移动到新位置 302 临时性重定向 304 自从上次请求后，请求的网页未修改过 4xx: 客户端错误 400 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发送请求 401 请求未授权 403 禁止访问 404 找不到如何与URI相匹配的资源 5xx: 服务器错误 500 最常见的服务器端错误 503 服务器端暂时无法处理请求 ​ 7. 语义化的理解 用正确的标签做正确的事情 HTML语义化就是让页面的内容结构化，便于对浏览器，搜索引擎解析 在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于SEO 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 8. 介绍一下你对浏览器内核的理解 主要分为两部分：渲染引擎和JS引擎 渲染引擎：负责取得网页的内容，整理讯息，以及计算网页的显示方式，然后会输出至显示器。 jS引擎则：解析和执行JavaScript来实现网页的动态效果 9. HTML5有哪些新特性，移除了哪些元素？新增功能 绘画canvas 用于媒介回放的video和audio元素 本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失 sessionStorage的数据在浏览器关闭后自动删除 语义化更好的内容元素，比如artcle，footer，header，nav，section 表单控件， url，email，time，date 新的技术：webwoker。websocket 移除功能 移除一些标签 之处HTML5新标签 IE8/IE7等浏览器支持通过document.createElement方法产生的标签 可以利用这一特性让这些浏览器支持HTML5新标签 10. 请描述一下cookies，sessionStorage和localStorage的区别？ cookie是网站为了标示用户身份而储存在用户本地终端上的数据 cookie数据始终在同源的http请求中携带(即使不需要)，记会在浏览器和服务器间来回传递 sessionStroage和localStorage不会自动把数据发给服务器，仅在本地保存 存储大小： cookie数据大小不能超过4k sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大的多，可以达到5m或更大 有效时间 localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage数据在当前浏览器窗口关闭后自动删除 cookie设置的cookie在cookie过期时间之前一直有效，即使窗口或浏览器关闭 11. iframe有哪些缺点 iframe会阻塞主页面的Onload事件 搜索引擎的检查程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑着两个缺点。如果需要使用iframe最好是通过JavaScript动态给iframe添加src属性 12. WEB标准以及W3C标准是什么？web标准 html是表现。css是结构，JavaScript是行为 w3c标准 对于表现要求 标签字母要小写 标签要闭合 标签不允许随意嵌套 对于css和js来说 尽量使用外链css样式表和js脚本 样式尽量少用行间样式表，使结构与表现分离，标签id和class等属性命名要做到见文知义 13. Doctype作用？ &lt;!DOCTYPE&gt;声明位于文档中的最前面，处于&lt;html&gt;标签之前。告知浏览器的解析器，用什么文档类型规范来解析这个文档 14. HTML全局属性有哪些 class：为元素设置类标示 data-*: 为元素增加自定义属性 draggable： 设置元素是否可拖拽 id：元素id，文档内唯一 lang；元素内容的语言 style：行内css样式 title：元素相关的建议信息 15. 你能描述一下渐进增强和优雅降级之间的不同吗？ 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果，交互等改进和追加功能达到更好的用户体验 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 区别：优雅降级是从复杂的现状开始，并视图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级(功能衰减)意味着往后看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带 16. 简述一下src与href的区别 src用于替换当前元素，href用于在当前文档和引用资源之间确立关系 src，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如JS脚本img图片和frame等元素 &lt;script src=&quot;js.js&quot;&gt;&lt;/script&gt;当浏览器解析到元素时，会暂停其他资源的下载和处理，直到将该资源加载，编译，执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部 href 指向网络资源所在位置，建立和当前元素或当前文档之间的连接，如果我们在文档中添加&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;&gt;bane浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理 17. 页面访问cookie的限制条件cookie(存储在用户本地终端上的数据) cookie指某些网站为了辨别用户身份，进行session跟踪而存储在用户本地终端上的数据 跨域问题： cookie允许web开发者保留他们的用户的登录状态。但是当你的站点有一个以上的域名时就会出现问题了。在cookie规范上说，一个cookie只能用于一个域名，不能够发给其他的域名。因此在浏览器群中对一个域名设置了一个cookie，这个cookie对其他域名将无效 解决： 通过nginx反向代理 jsonp方式请求 设置了 HTTP only： 如果在cookie中设置了HttpOnly属性，那么通过程序(JS脚本)将无法读取cookie信息，这样能有效的防止XSS攻击 cookie的作用于弊端cookie的作用 可以在客户端保存用户数据，起到简单的缓存和用户身份识别等作用 保存用户的登录状态，用户进行登录，成功登录后，服务器生成特点的cookie返回给客户端，客户端下次访问该域名下的任何页面，将该cookie的信息发送给服务器，服务器经过检验，来判断用户是否登录 记录用户的行为 cookie弊端 增加流量消耗，每次请求都需要带上cookie信息 安全性隐患，cookie使用明文传输，如果cookie被人拦截，那么就可以取得所有session信息 cookie数量和长度的限制。每个域名下最多只能有20条cookie，每个cookie长度不能超过4kb，否则会被截掉","categories":[],"tags":[]},{"title":"剖析JavaScriptAMDCMDCOMMONJSES6模块化","slug":"剖析JavaScriptAMDCMDCOMMONJSES6模块化","date":"2021-01-21T14:39:19.200Z","updated":"2021-01-26T10:51:49.735Z","comments":true,"path":"posts/35712/","link":"","permalink":"http://blog.liurugang.cn/posts/35712/","excerpt":"","text":"剖析JavaScriptAMD/CMD/COMMONJS/ES6模块化CommonJScommonJS出现就是解决原本js文件引入出现的不足点，即模块依赖和全局污染问题。它并不是一个js语言规则，而是对于模块化的一个规范 CommonJS实际上就是用了require这个玩意，只要引用，就会创建一个模块的实例，即实例化 做法是通过requrire引入模块，通过module.exports导出，并且文件加载时同步完成的 对服务端比较友好，内含缓存机制，也就是只要require导入一次模块，那么这个模块就是被缓存，并且还会进行一次比较异同的操作，例如我修改了这个模块，那么将会缓存的模块替换新的模块 在node上运行，不依赖客户端 而当我们引入一个模块后，其实会解析成一个立即执行函数，类似于原本的ES5利用自治性函数封装一样，类似下面，因此，引入模块并不是全局变量 123(function(exports,requrire,module,__filename,__dirname&#123; &#125;)() AMDCommonJS只能在nodejs服务端那边使用，在客户端没法运行。因此AMD诞生，全程异步模块定UI，是通过RequireJS来实现的，区别于CommonJS,它是异步的。 定义模块:define(moduleName,[module],factory); 引入模块：requrie([module],callback) 下面看这个例子： 定义一个模块moduleA 123456define('moduleA',function()&#123; var a =[1,2,3,4,5]; return&#123; a: a.reverse() &#125;&#125;) 再来定义一个模块moduleB，此时它依赖于模块A，按照如下方法进行依赖 123456define('moduleB',[moduleA],function(moduleA)&#123; var b= [6,7,8,9,10]; return&#123; b:moduleA.a.concat(b) &#125;&#125;) 然后在index.js文件中我们需要通过require.config来配置我们的模块路径，如若没有配置的话，就会报错找不到。 123456789101112require.config(&#123; paths:&#123; moduleA:'js/module_a', moduleB:'js/mdoule_b', moduleC:'js/module_c', &#125;&#125;)require(['moduleA','moduleB','moduleC'],function()&#123; console.log(moduleA.a); console.log(moduleB.b); console.log(moduleC.c);&#125;) 注意点：上述依赖模块只有当全部加载完毕后，才会执行后面的回调函数。这种方式就前置依赖 CMD阿里也为模块化做了贡献，推出了CMD全称通用模块定义，同理。它也没法在浏览器端运行 定义模块：define(function(require，exports,module){}) 引入模块：sea.js([module路径],function(moduleA,moduleB,moduleC){}) 下面看这个例子： 定义一个模块moduleA 123456define(function(require,exports,module)&#123; var a=[1,2,3,4,5]; return&#123; a:a.reverse() &#125;&#125;) 再定义一个模块moduleB，此时它依赖于模块A，按照如下方式进行依赖 1234567define(function(require，exports，module)&#123; var moduleA =require('module_a'), b =[6,7,8,9,10]; return &#123; b:moduleA.a.cancat(b) &#125;&#125;) 然后在index.js文件中，我们需要首先通过数组确定模块路径，如下所示 1234seajs.use(['module_a.js','module_b.js'],function(moduleA，moduleB)&#123; console.log(moduleA.a) console.log(moduleB.b)&#125;) 下面总结CMD·相关知识： 通过require加载,define定义，exports导出,module操作模块 而在使用模块时，需要配置相关url，依赖加载完毕之后，再执行回调函数，这里和AMD没啥区别 CMD就行依赖，按需加载，增强了灵活性 ES6模块化导入模块：import module from &#39;模块路径&#39; 导出模块：export module; 下面看这个例子： 定义一个模块moduleA 123export default&#123; a:[1,2,3,4,5].reverse()&#125; 再来定义一个模块moduleB,此时它依赖于模块A，按照如下方式进行依赖 1234import moduleA from './module_a';export default&#123; b:moduleA.a.concat([6.7.8,9,10])&#125; 然后在index.js文件中我们需要配置我们的模块路径，如没有配置的话，就会报错找不到。 123456import moduleA from './module_a';import moduleB from './module_b';import moduleC from './module_c';console.log(moduleA.a)console.log(moduleB.b)console.log(moduleC.c) ES6模块化与commonjs对比 区别1： commonjs模块输出的是一个值的拷贝 ES6输出的是一个值的引用 区别2： commonjs运行在服务端，因此模块是在运行时加载，即程序执行时require才会加载 ES6模块在编译时加载","categories":[],"tags":[]},{"title":"webpack(3)","slug":"webpack(3)","date":"2021-01-20T09:54:16.843Z","updated":"2021-01-20T09:54:17.151Z","comments":true,"path":"posts/61015/","link":"","permalink":"http://blog.liurugang.cn/posts/61015/","excerpt":"","text":"webpack(3)webpack对图片的处理 file-loader：解决引用路径的问题，拿background样式用url引入背景图来说，我们都知道webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在路径的。这就导致图片引入失败。这个问题我们是用file-loader解决的，file-loader可以解析项目中的url引入，根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。 url-loader：如果图片较多，会发很多的http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码。生成dataURL。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被传入DataURL，大于limit的还会使用file-loader进行copy 1npm install --save-dev file-loader url-loader 文件中的图片分为三种，在css中引入，在js中引入，在html中引入 处理css，js中图片 123456789&#123; test: /\\.(png|svg|jpg|gif)$/, use: &#123; loader: 'file-loader', options: &#123; name:'assets/[name].[ext]', &#125; &#125;&#125;, 直接使用file-loader。url-loader进行配置即可，但是要注意在output(出口)中加入publicPath:&#39;/&#39; 123456789module.exports= &#123; entry:__dirname +'/src/index.js'， output:&#123; path:__dirname+'/dist', filename:'bundle.js'， publicPath:'/' //需要在图片上传的时候添加 &#125;&#125;&#125; 在html中的图片不能被直接打包，需要借助html-withimg-loader 1npm install html-withimg-loader --save 在webpack.config.js中配置 1234module.exports =&#123; test:/\\/.(htm|html)$/, use:['html-withimg-loader']&#125; html-webpack-pluginhtmlwenpackplugin会在打包结束后，自动生成一个html文件，并把打包生成的js模块引入到该html中 1npm install --save-dev html-webpack-plugin 配置 1234567891011121314151617181920212223title: ⽤用来⽣生成⻚页⾯面的 title 元素filename: 输出的 HTML ⽂文件名，默认是 index.html, 也可以直接配置带有⼦子⽬目录。template: 模板⽂文件路路径，⽀支持加载器器，⽐比如html!.&#x2F;index.htmlinject: true | &#39;head&#39; | &#39;body&#39; | false ,注⼊入所有的资源到特定的 template 或者 templateContent 中，如果设置为true 或者 body，所有的 javascript 资源将被放置到 body 元素的底部， &#39;head&#39; 将放置到 head 元素中。favicon: 添加特定的 favicon 路路径到输出的 HTML ⽂文件中。minify: &#123;&#125; | false , 传递 html-minifier 选项给 minify输出hash: true | false, 如果为 true, 将添加⼀一个唯⼀一的webpack 编译 hash 到所有包含的脚本和 CSS ⽂文件，对于解除cache 很有⽤用。cache: true | false，如果为 true, 这是默认值，仅仅在⽂文件修改之后才会发布⽂文件。showErrors: true | false, 如果为 true, 这是默认值，错误信息会写⼊入到 HTML ⻚页⾯面中chunks: 允许只添加某些块 (⽐比如，仅仅 unit test 块)chunksSortMode: 允许控制块在添加到⻚页⾯面之前的排序⽅方式，⽀支持的值： &#39;none&#39; | &#39;default&#39; | &#123;function&#125;-default:&#39;auto&#39;excludeChunks: 允许跳过某些块， (⽐比如，跳过单元测试的块) 案例: 123456789101112const path = require(\"path\");const htmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports=&#123; ... plugins:[ new htmlWebpackPlugin(&#123; title:\"My App\", filename:\"app.html\", template:\"./src/index.html\" &#125;) ]&#125; 需要注意想要在打包的html的文件中生成正确的title，需要在原来的html模板上进行以下修改 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;&lt;%= webpackConfig.title %&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"index.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 因为htmlwenpackplugin默认识别的ejs语法 Clean-webpack-plugin1npm install --save-dev clean-webpack-plugin 12345const &#123; CleanWebpackPlugin &#125; = require(\"cleanwebpack-plugin\");...plugins: [new CleanWebpackPlugin()] 需要注意的是引入的时候需要加上括号 mini-css-extract-plugin123456789const MiniCssExtractPlugin = reqirue(\"mini-css-extract-plugin\")&#123; test:/\\.css$/, use:[MiniCssExtractPlugin.loader,\"css-loader\"]&#125;new MiniCssExtractPlugin(&#123; filename:[name][chunkhash:8].css&#125;) 需要注意引入的时候还需要引入loader MiniCssExtractPlugin.loader webpack-dev-server 提升开发效率的利器 每次改完代码都需要重新打包一次，打开浏览器，刷新一次，很麻烦，我们可以安装使用webpackdevserver来改善这块的体验 安装 1npm install webpacl-dev-server -D 配置 修改下package.json 123\"scripts\":&#123; \"server\":\"webpack-dev-server\"&#125; 在webpack.config.js配置： 12345devServer&#123; contentBase:&quot;.&#x2F;dist&quot;, open:true, port:8081&#125; 启动 1npm run server 启动服务后，会发现dist目录没有了，这是因为devServer把打包后的模块不会放在dist目录下，而是放到了内存中，从而提升速度","categories":[],"tags":[]},{"title":"webpack(2)","slug":"webpack(2)","date":"2021-01-20T09:54:16.840Z","updated":"2021-01-20T09:54:17.152Z","comments":true,"path":"posts/32342/","link":"","permalink":"http://blog.liurugang.cn/posts/32342/","excerpt":"","text":"webpack(2)webpack核心内容Entry(入口)Entry是webpack的入口文件，一开始运行webpack它会找到webpack.config.js里的Entry。它会从这里开始着手，构建内部依赖图。入口点可以有一个或多个 entry的类型 string类型 12//一个入口entry:'./src/main.js' array类型 1entry:['./src/main.js','./src/main2.js'] object类型 12345//对象类型entry:&#123; a:'./src/main.js', b:['./src/main1.js','./src/main2.js'] &#125; 只有对象且键值对的形式，才是多入口文件。如果是多入口，就一定要是多出口 例如： 1234567891011121314//多入口文件entry:&#123; index:'./src/main.js', other:'./src/other.js'&#125;output:&#123; path:path.reslove(__dirname,\"./dist\"), filename:\"[name].js\"&#125;//占位符//hash整个项目的hash值，每次构建一次，就会有一个hash值,hash是1-16为数字字母组成的，可以截取[hash:6].js//chuckhash 根据不同入口entry进行依赖解析，构建对应的chunkhash，只要组成entry的模块没有内容改动，则对应的hash不变//name//id 多个入口是，每个入口生成都会生成chuck 1chuck(代码块) = 1bundle(资源文件) output(出口)chuck 如果entry是string类型或者是array类型，只会生成一个chuck 如果entry是一个object，就可能出现多个chuck，这时候的chunck值是object名称。比如上面的a.js,b.jsChuck名称在output可以配置 使用入口名称赋值，[name]为entry的key值 1filename:\"[name].bundle.js\" 使用内部chunk id,从0开始 1filename:\"[id].bundle.js\" 使用每次构建过程中，都会生成一段hash值 1filename:\"[hahs].boundle.js\" 也可以对hash值进行截取 1filename:\"[chunkhash].boundle.js\" pathoutput.path配置输出文件存放在本地的目录，必须是string类型的绝对路径。通常通过Node.js的path模块去获取绝对路径： 1path:path.resolve(__dirname,'dist_[hash]') __dirname就是当前文件所在的文件夹的名字 publicPath对构建出的资源进行一步加载(图片，文件)。加载这些一步资源需要对应的URL地址。默认是空字符串。简单说，就是静态文件托管在cdn上 1234output:&#123; filename:'[name]_[chunkhash:8],js', publicPath:'https://www.qdtalk.com/assets' &#125; 打包编译之后，HTML页面就变成 1&lt;script src=\"https://www.qdtalk.com/assets/a_12345678.js\"&gt;&lt;/script&gt; LoaderLoader在webpack中承担翻译的作用。因为webpack自身只支持js和json文件，把源文件转化翻译后输出的新结果，且一个文件还可以链式的经过多个翻译员翻译 以处理Scss文件为例： scss源码先后交给sass-loader把scss转成css 把sass-loader输出的css交给css-loader处理，找出css中依赖的资源，压缩css等 把css-loader输出的css交给style-loader处理。转换成通过脚本加载的JavaScript代码 常用的Loader 样式：style-loader、css-loader、less-loader、sass-loader等。 文件：raw-loader、file-loader 、url-loader等 编译：babel-loader、coffee-loader 、ts-loader等 校验测试：mocha-loader、jshint-loader 、eslint-loader等 vue-loader、coffee-loader、babel-loader等可以将特定文件格式转成js模块、将其他语言转化为js语言和编译下一代js语言 file-loader、url-loader等可以处理资源，file-loader可以复制和放置资源位置，并可以指定文件名模板，用hash命名更好利用缓存。 url-loader可以将小于配置limit大小的文件转换成内敛Data Url的方式，减少请求。 raw-loader可以将文件已字符串的形式返回 imports-loader、exports-loader等可以向模块注入变量或者提供导出模块功能 expose-loader:暴露对象为全局变量 安装Loader以安装css-loader和style.loader为例，直接在终端： 1npm install css-loader style-loader --save-dev 配置单个Loaderwebpack.config.js中 12345678module.exports =&#123; module:&#123; rules:[&#123; test:/\\.css$/, use:'css-loader' &#125;] &#125;&#125; test后面接一个正则表达式，表示有哪些后缀文件被处理 use:表示应该用什么loader 1234567891011121314module.exports= &#123; module:&#123; rules:[ &#123; test:/\\.css$/, use:[&#123; loader:'style-loader' &#125;,&#123; loader:'css-loader' &#125;] &#125; ] &#125;&#125; 几个重要的loader Babel Babel可以让你使用Es6/7/8写代码而不用顾忌浏览器的问题，babel可以帮你转换代码 安装几个必要的babel库 1234npm i --save-dev babel-loader babel-core babel-preset-env// babel-loader让webpack去处理一些使用了es6的js文件。//babel-core 提供一系列API，其实是让babel-loader去调用babel-core的API。//babel-preset-env 这个库可以根据环境的不同转换代码 配置babel规则。在webpack.json里增加一个babel属性。作用是设置项目中的babel转码规则和使用到的babel插件，格式如下： 1234\"babel\":&#123; “presets”:[\"evn\"], //设定转码规则 \"plugins\":[] //要用到的插件 &#125; 表示告诉npm，在本项目中将使用babel,并且使用babel-preset-env规则进行转码 除了上一种写法，也可以在根目录下面新建.babelrc文件，然后做一下配置 123&#123; \"presets\":[\"babel-preset-env\"]&#125; 配置好babel的规则，但是webpack依然不知道何时使用该规则。我们还要再接着在配置里写入 1use:'babel-loader' 处理图片 1npm i --save-dev url-loader file-loader 在webpack.config.js里面修改配置： 12345678910111213test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,use : [ &#123; loader: 'url-loader', options: &#123; // 限制 图片大小 10000B，小于限制会将图片转换为 base64格式 limit: 10000, // 超出限制，创建的文件格式 // build/images/[图片名].[hash].[图片格式] name: 'images/[name].[hash].[ext]' &#125; &#125;] Plugins(插件)插件用来扩展webpack功能，可以用于执行范围更广的任务，包括打包，优化，压缩，搭建服务器等等，功能十分强大。要是用一个插件，一般是先使用npm包管理器进行安装，然后在配置文件webpack.config.js中的require引入，最后再这个文件下使用new来创建一个实例。loader一次只能处理单个相同类型文件，但是plugins可以对整个过程起作用。 常用的Plugin插件 webpack内置UglifyJsPlugin插件，压缩和混淆代码。 webpack内置CommonsChunkPlugin，提高打包效率，将第三方库和业务代码分开打包 ProvidePlugin：自动加载模块，代替require和import html-webpack-plugin可以根据模板自动生成html代码，并自动引用css和js文件 extract-text-webpack-plugin 将js文件中引用的样式单独抽离成css文件 DefinePlugin 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。 HotModuleReplacementPlugin热更新 optimize-css-assets-webpack-plugin 不同组件中重复的css可以快速去重 webpack-bundle-analyzer 一个webpack的bundle文件分析工具，将bundle文件以可交互缩放的treemap的形式展示 compression-webpack-plugin 生产环境可采用gzip压缩JS和CSS happypack：通过多进程模型，来加速代码构建 一个简单的插件使用 npm install --save-dev html-webpack-glugin安装一个插件。有的插件webpack自带，如果没有，则需要npm安装 const HtmlWebpackPlugin =require(&#39;html-webpack-plugin&#39;)在webpack.config.js中引用 new一个实例 1234567plugins: [ new HtmlWebpackPlugin(&#123; template: &#39;.&#x2F;src&#x2F;index.html&#39;, &#x2F;&#x2F;以src目录下的index.html文件为模板生成html5新文件 filename: &#39;index.html&#39;,&#x2F;&#x2F;指定生成的HTML文件叫啥名 inject: &#39;head&#39;,&#x2F;&#x2F;指定把脚本script标签放在那里，这里放在&lt;head&gt;标签里。还可以放&lt;body&gt; &#125;)] 利用html-webpack-plugin插件自动生成html每次执行webpack打包生成js文件后，都必须在index.html中手动插入打包好的文件的路径。但在真实生产环境中，一次运行webpack后，完整的index.html应该是被自动生成的。例如静态资源，js脚本都被自动插入了。 根目录下的index.html会被html-webpack-plugin作为最终生成对的html文件的模板。打包后，相关引用关系和文件路径都会按照正确的配置被添加进去 12345678910111213141516171819202122const HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;);module.exports &#x3D; &#123; entry: &#123; app: &quot;.&#x2F;src&#x2F;app.js&quot; &#125;, output: &#123; publicPath: __dirname + &quot;&#x2F;dist&#x2F;&quot;, path: path.resolve(__dirname, &quot;dist&quot;), &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: &quot;index.html&quot;, template: &quot;.&#x2F;index.html&quot;, chunks: [&quot;app&quot;], &#x2F;&#x2F; entry中的app入口才会被打包 minify: &#123; &#x2F;&#x2F; 压缩选项 collapseWhitespace: true &#125; &#125;) ]&#125; 最后执行打包命令，然后在dist目录下就给你自动生成了index.html文件。dist目录下的index.html文件是以根目录下的inde.html文件为模板的。 Mode分为开发模式development和生产模式production两种模式的区别在于一个是为生产环境编译打包，一个是为了开发环境编译打包。生产环境模式下，webpack会自动对代码进行压缩等优化，省去了配置的麻烦","categories":[],"tags":[]},{"title":"webpack(1)","slug":"webpack(1)","date":"2021-01-20T09:54:16.837Z","updated":"2021-01-20T09:54:17.150Z","comments":true,"path":"posts/36438/","link":"","permalink":"http://blog.liurugang.cn/posts/36438/","excerpt":"","text":"webpack(1)webpack是什么为什么要使用webpack我们都知道一个大公司的网站往往做的都很炫酷，美观，功能齐全。在这背后前端工程师花了很大的精力去优化。大型网站和大型项目中背后都拥有着复杂的JS代码和很多依赖。为了简化开发的复杂度，往往对程序切割分裂成不同的模块 如图所示，把大型项目切割成很多不同的模块。里面带的箭头可以理解为require。因为两个文件之间相互通联是靠require连接的。好比如，html文件利用link中引入样式一样。webpack整合了项目里的模块打包的更为精简。所以我们需要wepack webpack分析大型项目的结构 找到JS模块以及浏览器不能直接运行的模块(cjs,sass,hbs等等) 将浏览器不能直接处理的文件装换和打包为合适的格式供浏览器直接处理 这样前端工程师即可以更轻松系统的开发，浏览器也能更高效流畅的运行 webpack的工作原理 webpack的工作原理就是webpack分析大型项目的结构，找到浏览器不能直接运行的模块，将浏览器不能直接处理的文件装换和打包为合适的格式供浏览器处理。 webpack安装&amp;使用 初始化项目 1npm inint -y //快速创建nodejs项目 两种webpack安装 12npm install -g webpack webpaack-cli //全局安装(不推荐使用)npm install -D webpack webpack-cli //本地安装 全局安装会将项目锁定在特定的版本的webpack 打包一个简单的文件 在文件夹下新建一个src文件，下面新建一个main.js文件 根目录下新建一个webpack.config.js文件。为什么要建这个文件，因为直接使用webpack。它会寻找webpack.config.js把当当成默认的配置去运行。此时他不需要使用任何参数，就能读取里面的内容12345678//webpack.config.jsmodule.exports= &#123; entry:__dirname+'/src/main.js'，指定入口文件，在src/main.js output:&#123; path:__dirname +‘/dist’,//打包后指定存放的目录，放在dist filename:'bundle.js' //打包后的文件叫做bundls.js &#125;&#125; __dirname是nodejs中一个全局变量，它指定当前执行脚本所在的目录 修改package.json文件，然后在命令行中运行指令npm run build 12345678910111213141516&#123; &quot;name&quot;: &quot;pack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot; &#x2F;&#x2F;需要修改的地方 &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^5.11.1&quot;, &quot;webpack-cli&quot;: &quot;^4.3.1&quot; &#125;&#125;","categories":[],"tags":[]},{"title":"静态博客访问优化之终极解决方案","slug":"静态博客访问优化之终极解决方案","date":"2021-01-20T08:16:31.499Z","updated":"2021-01-20T08:19:44.776Z","comments":true,"path":"posts/57538/","link":"","permalink":"http://blog.liurugang.cn/posts/57538/","excerpt":"","text":"前言 首先本教程是基于 域名已经备案 的前提下进行的，理论上，任何静态页面都可以使用本教程，哪怕是你写的一个小demo网页，想show给别人看，也可以使用，前提是域名已经备案。域名没有备案的也不要灰心，这里我给出三个解决方案： 一、就是去备案（这不废话吗？）备案一般必须要有域名服务商的服务器才行，而买服务器又得花很多钱。（我们玩Hexo的口号是什么？白嫖！）那么没服务器怎么办呢？——备案授权码！上哪搞呢？鲁迅曾经说过：有需求的地方，必有市场！（鲁迅：没错，什么都是我说的！）这就得靠我们强大的某淘了，给个关键字：XXX云服务号 二、就是不备案强行推广一波我的另一篇优化文章，一样可以获得很高的访问速度：Hexo博客优化 三、使用国外的云服务 备案是“中国特色”，国外的服务器是没有备案一说的。可以尝试 谷歌云 或者 亚马逊的AWS，这里不做过多介绍。 核心方案开门见山的说，今天的主角：对象存储 + CDN。 方案其实就是将自己的静态网页文件放到云服务商提供的 对象存储 中，而 对象存储 一般提供的都有pages服务，而且访问速度绝对要远比代码托管平台提供的pages服务快的多，但是这个pages服务，一般只有绑定了域名才可以开启，而且也只能绑定已备案的域名，最重要的是我们还可以使用云服务商提供的CDN，这样又进一步提升了访问速度，这绝对碾压代码托管平台的pages服务，任你再怎么优化也是没有对象存储快的，更何况还有CDN（付费的当然比免费的好用）。 这个方案的好处是：用远低于购买服务器的价格，就可以获得服务器级别甚至更强的访问性能！ 其实会玩的人看到这里，就已经明白怎么搞了，但是为了很多小白我还要再啰嗦一下。 科普 再讲解具体步骤之前，让我们先了解一些基础概念，以便有更好地阅读体验，大佬请忽略 对象存储：即每个文件都是一个对象， 所有的文件实际是都是在同一个文件夹内，只不过其前缀不同罢了，如果不能理解，就当是一个存储文件的网盘吧。 CDN： 全称Content Delivery Network即内容分发网络。 CDN加速意思就是在用户和我们的服务器之间加一个缓存机制，通过这个缓存机制动态获取IP地址根据地理位置，让用户到最近的服务器访问，从而可以得到更快的访问速度。 源站：即真正存储网站的服务器。（这里指的是我们的对象存储服务器） 回源： 是指CDN服务器缓存的资源过期后，从源站获取最新的访问资源，然后再缓存到CDN服务器，供下次访问 各云服务商的价格对比 云服务商有很多，大家可以根据自己的喜好选择，这里我只提供下参考，说的不对的地方请多多指正。 可能很多人会问，说好的白嫖呢？看下价格就明白了，花不了多少钱的。 服务商的选择因素有很多，比如服务、价格、稳定性等，由于我本人接触云服务这方面时间较短，没什么发言权，那我就只谈谈我们这些「平民」最关心的价格这方面，做个价格对比。 提供对象存储的云服务商有：阿里云、腾讯云、七牛云、又拍云等。考虑到各服务商的价格可能会有所变动，本节目前提供的价格参考日期为2019.11.26。 阿里云阿里云官网 先参考阿里云官方的计量项和计费项、OSS计费 和 CDN计费 文档。 CDN的计费方式有两种：按流量计费 和 按带宽峰值 计费，这里推介选择 按流量计费。 OSS计费项有很多（各种请求和以及所占容量大小的计费等，都很少，这里不做比较），对于几十M的静态博客来说： 当只用 OSS 时，主要费用就是 外网流出流量 的费用！ 00:00-08:00（闲时）：0.25元/GB 8:00-24:00（忙时）：0.50元/GB 当使用 OSS+CDN 时，因为CDN需要到源站获取资源，就不需要从外网获取了，所以这时的费用就是 回源流量 + CDN流量费用 0.15元/GB + 0.24元/GB = 0.39元/GB 是不是很便宜？相比于购买服务器。 腾讯云参考腾讯云官方文档 对象存储COS计费 CDN计费 。 当只用COS时 外网下行流量费：0.5元/GB 当用COS + CDN时 回源流量＋CDN流量 = 0.15元/GB + 0.21元/GB = 0.36元/GB 值得一说的是：腾讯云对这两个服务的新用户是有半年的优惠的。 COS：免费50GB 标准存储容量，6个月 CDN：送6个月的免费流量，每月50G，随便High！ 七牛云七牛云官网 七牛的对象存储10G内是免费的 外网流出流量费用：0.29元/GB CDN回源流量费：10G内免费 CDN-HTTP下载流量费：10G内免费 CDN-HTTPS下载流量费：0.28元/GB CDN-HTTP + 对象存储 = 免费 CDN-HTTPS + 对象存储 = 0.28元/GB （因为回源10G内免费，就只剩下CDN流量费了） 七牛是不是很良心？但是有次使用中，七牛的控制台竟然崩了，控制台居然都能崩掉。 总结我还是比较推介大家用七牛云，当然求稳的话还是阿里云，毕竟大公司。 我曾经看过一个关于阿里云、腾讯云、华为云的横向评测：结果就是华为云以很低的延迟和很高的带宽碾压另外两位。 具体配置 各服务商的配置大体相同，不做过多赘述，这里以腾讯云为例 创建存储桶 登录腾讯云，点击右上角控制台，找到云产品，开通对象存储服务。 存储桶列表-&gt;创建存储桶-&gt; 填写信息 所属地域 选择离自己位置最近的即可（创建后不可更改） 访问权限 选择 公有读私有写 标签 无所谓 上传文件到COS中 继续操作，点击左侧 工具-&gt;客户端下载-&gt; 选择对象系统的 COSBrowser 下载 -&gt; 然后安装即可 点击右上角 账号 下的访问管理-&gt;左侧的访问密钥 可能会有风险提示，点击继续使用 复制 SecretId 和 SecretKey 这两个是读写COS的密钥，不能泄露！ 打开 COSBrowser，输入刚才复制的两个值，点击 登录。 在 COSBrowser中，左下角点击 同步 本地文件夹选择 Hexo根目录中的public文件夹 （public文件夹中的文件为Hexo生成的静态网页文件，我们需要将这些文件放到COS中，供别人访问；git部署的文件也是这些文件！） 存储桶目录选择刚才创建的存储桶，存储桶目录留空（目的：将public文件夹中的文件上传到存储桶的根目录） 点击 开始同步 之后可以到网页版的控制台确认文件有没有上传上去。 开启pages服务 回到控制台，对象存储 -&gt; 存储桶列表 -&gt; 基础配置 -&gt; 静态网站 -&gt; 开启 访问节点：即 该COS的访问地址 强制 HTTPS：建议开启 索引文档（主页）：填 index.html 错误文档（404页面）：如果有404页面填上404页面的地址，如果没有留空即可。 重定向规则：设置发生4XX错误时，要填跳转到哪个页面，可以不配置。 保存 之后就可以直接复制 访问节点 的地址到浏览器打开，看能不能访问。 绑定域名并开启CDN 对象存储 -&gt; 存储桶列表 -&gt; 点击刚才创建的存储桶 -&gt; 点击 域名管理 找到 自定义域名加速，点击添加域名（只能添加已备案的域名） 域名：你的域名（将此域名添加到域名解析那里） 加速地域：国内加速 源站类型： 静态网站源站（非常重要！！） 回源鉴权：不用打开（公共读不需要鉴权） CDN 鉴权：不用设置 点击保存即可 复制该项的CNAME，然后配置到域名解析那里。 等待部署，一般5分钟作用；部署成功后试下自己的域名能不能访问 配置HTTPS证书先在域名服务商那里申请好免费https证书 （也可以在其他地方申请），这里以阿里云为例。 然后点击对应项的下载 选择其他 下载后的是一个压缩文件，解压后有两个文件 *.pem 和 *.key，编辑器将其打开。 控制台这边选择 内容分发网络 -&gt; 证书管理 -&gt; 配置证书 域名：选择刚才申请证书的域名 证书来源：自有证书 证书内容：将刚才以.pem结尾文件的内容粘进来 私钥内容：将以.key结尾文件的内容粘进来 回源协议：协议跟随 最后提交即可！ 成功之后就可以使用https协议 剩下的防盗链、IP访问限频配置之类的各自慢慢摸索、不配置也行。 刷新CDN缓存为什么要刷新CDN缓存？ 因为一旦我们更新了博客的内容，而别人访问的却还是CDN节点缓存的内容，这体验就很糟糕 如果你想刷新某个页面 内容分发网络 -&gt; 刷新预热 -&gt; URL刷新 -&gt; 填入URL提交刷新即可 如果你想刷新整站内容 在目录刷新填入URL，选择刷新全部资源，提交刷新即可 总结可能很多小伙伴还有点蒙，让我们来总结一下以后的使用流程： 先生成静态文件（hexo cl&amp;hexo g） 再将生成的文件上传到对象存储，要利用腾讯的上传软件上传 刷新CDN缓存（因为CDN都是有缓存的，你不刷新，别人访问的都是旧资源） 但是这样总归还是有些麻烦，不过云服务商都提供了各种SDK，如果你足够牛逼，你可以手写一个一键上传脚本，并自动更新CDN缓存。如果你跟我一样是个菜鸡，那还是老老实实用服务商给的“轮子”吧。 文章作者:\\ Sky03 文章链接:\\ https://blog.sky03.cn/posts/1663.html 版权声明:\\ 本博客所有文章除特別声明外，均采用 CC BY 4.0 许可协议。转载请注明来源 Sky03 !","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://blog.liurugang.cn/tags/%E6%80%BB%E7%BB%93/"},{"name":"面试","slug":"面试","permalink":"http://blog.liurugang.cn/tags/%E9%9D%A2%E8%AF%95/"}]}